/*! \mainpage Trilinos/Epetra: Linear Algebra Services Package.
\htmlonly
\endhtmlonly

\section Epetra_outline Outline

<ul>
<li>\ref Epetra_intro
<li>\ref Epetra_startup
  <ul>
  <li>\ref Epetra_formulations
  <li>\ref Epetra_trilinos
  <li>\ref Epetra_wrappers
  <li>\ref Epetra_aztec2trilinos
  <li>\ref Epetra_extending
  <li>\ref Epetra_example
  </ul>
<li>\ref Epetra_adapters
<li>\ref Epetra_browser
</ul>

\section Epetra_intro Introduction
Epetra provides the fundamental construction
routines and services function that are required for serial and
parallel linear algebra libraries.  Epetra provides the underlying
foundation for all Trilinos solvers.  

\section Epetra_startup Overview of Epetra.

\subsection Epetra_formulations Epetra Classes

Epetra contains a number of classes.  They can be categorized as follows:

<ul> 

<li> Primary parallel user classes.  These are typically the most important classes for most users.

<ol>

<li> Communicator class: Epetra_Comm -  
     Contains specific information about the parallel machine we are using.  Currently
     supports serial (Epetra_SerialComm), MPI (Epetra_MpiComm) and prototype hybrid MPI/threaded parallel programming models.

<li> Map classes: Epetra_Map, Epetra_LocalMap, Epetra_BlockMap - Contain information used to
                  distribute vectors, matrices and other objects on a parallel (or serial) machine.

<li> Vector class: Epetra_Vector - Real double precision vector
     class.  Supports construction and use of vectors on a parallel machine.  Epetra_FEVector is a specialization of 
     Epetra_Vector to support construction of vectors from finite element applications.  Epetra_Vector \e isa Epetra_MultiVector.
     Thus, any argument that requires an Epetra_MultiVector can also accept an Epetra_Vector.

<li> Multi-vector class: Epetra_MultiVector - Real double precision
     multi-vector class.  Supports construction and use of multi-vectors 
     on a parallel machine.  A multi-vector is a collection vectors.
     It is a generalizaion of a 2D array.  

<li> Sparse row graph class: Epetra_CrsGraph - Allows construction
     of a serial or parallel graph.  The graph determines the communication pattern
     for subsequent matrix objects.  All Epetra sparse matrix classes (Epetra_CrsMatrix, Epetra_VbrMatrix,
     Epetra_FECrsMatrix and Epetra_FEVbrMatrix) have an associated Epetra_CrsGraph.  This graph is either 
     constructed implicitly for the user as part of the construction of the matrix, or is
     passed in to the matrix constructor by the user.  In the latter case the graph is either
     preconstructed by the user or extracted from an existing Epetra sparse matrix object using the Graph()
     accessor method.

<li> Pure virtual row matrix class: Epetra_RowMatrix - Pure virtual class that specifies
     interfaces needed to do most of the common operations required by a row matrix.  
     The Epetra_LinearProblem expects the matrix as a Epetra_RowMatrix.  The
     Epetra_CrsMatrix, Epetra_VbrMatrix,
     Epetra_FECrsMatrix and Epetra_FEVbrMatrix classes implement the Epetra_RowMatrix interface and
     therefore objects from these classes can be used with Epetra_LinearProblem and with
     AztecOO.  AztecOO also provides the Epetra_MsrMatrix class as an Epetra_RowMatrix adapter 
     that accepts an AZ_MATRIX struct (as defined in Aztec 2.1) and provides Epetra_RowMatrix functionality
     using the AZ_Matrix object, without copying matrix data.
\htmlonly
(See the <a href="../../../aztecoo/doc/html/index.html">AztecOO</a> home page for details.)
\endhtmlonly
     Furthermore, any class that implements Epetra_RowMatrix can be used with
     Epetra_LinearProblem and AztecOO.

<li> Easier-to-implement row matrix class: Epetra_BasicRowMatrix - Epetra_RowMatrix has many pure virtual functions 
     that must be implemented by an adaptor.  In many cases these functions can have a reasonable default implementation
     in terms of other functions, or using basic information that can be passed into a constructor.  Epetra_BasicRowMatrix
     is intended to make implementation of Epetra_RowMatrix easier.  All methods are virtual, but almost all methods have
     a default implementation that is reasonable.  For someone who is implementing their first Epetra_RowMatrix adapter,
     Epetra_BasicRowMatrix is probably a good starting point.

<li> Sparse row matrix class: Epetra_CrsMatrix - Real double
     precision sparse matrix class.  Supports construction and use of
     row-wise sparse matrices.  Epetra_FECrsMatrix is a specialization that supports finite
     element applications more naturally.

<li> Sparse block row matrix class:  Epetra_VbrMatrix - Real double 
     precision block sparse matrix class.  Supports construction and use of
     row-wise block sparse matrices.  Epetra_FEVbrMatrix is a specialization that supports finite
     element applications more naturally.

<li> Jagged diagonal sparse matrix class:  Epetra_JadMatrix - Real double 
     precision sparse matrix class for vector processors.  Constructs and updates a jagged-diagonal
     format sparse matrix from an existing Epetra_RowMatrix.  The jagged-diagonal format is one of the
     better sparse matrix data structures for vector and vector-like processors.  Matrix elements are
     organized so that long vector loops can be executed without memory conflicts.  This approach is
     very effective for machines with vector hardware and an interleaved memory system that supports
     high bandwidth irregular-pattern memory access.  Note that this class can take any existing Epetra
     sparse matrix as input, but does not \e require a constructed matrix as input.  If the input Epetra_RowMatrix
     can construct elements on-demand and one-row-at-a-time, then no additional copy of the matrix is needed.

<li> Import/Export classes:  Epetra_Import and Epetra_Export - Constructed from two
     Epetra_BlockMap (or Epetra_Map or Epetra_LocalMap).  Allows
     efficient transfer of objects built using one map to a new
     object with a new map.  Supports local and global permutations,
     overlapping Schwarz operations and many other data movement
     algorithms.
     


</ol>

<li> Primary serial user classes.  These classes provide object oriented interfaces to LAPACK capabilities,
     providing easy access to the most powerful numerical methods in LAPACK.

<ol>

<li> General dense matrix/vector classes: Epetra_SerialDenseMatrix, Epetra_SerialDenseVector - 
     Lightweight dense matrix and vector classes used to define matrices, left-hand-sides and 
     right-hand-sides for the serial solver classes. Epetra_IntSerialDenseVector is also useful for 
     construction of Epetra_Maps and advanced parallel data redistribution requirements.  Also note
     that the C++ standard vector class can be a better alternative to these classes.  However the STL vector
     class can be difficult to debug when memory errors are present.

<li> General dense solver class: Epetra_SerialDenseSolver - Provides dense matrix services such as 
     factorizations, solves, QR, SVD, etc., with special attention focused on numerically robust solutions.

<li> Symmetric dense matrix class: Epetra_SerialSymDenseMatrix - Similar to Epetra_SerialDenseMatrix 
     except focused specifically on symmetric matrices.

<li> Symmetric definite dense solver: Epetra_SerialSpdDenseSolver - Similar to Epetra_SerialDenseSolver 
     except focused specifically on symmetric definite systems.

</ol>

<li> Utility classes. 

<ol>
<li> Timing class: Epetra_Time - Provides timing functions for the
     purposes of performance analysis.

<li> Floating point operation class: Epetra_Flops - Provides floating point operations (FLOPS)
     counting and reporting functions for the purposes of performance analysis.  All Epetra computational
     classes accumulate FLOP counts associated with the \e this object of the computations.

<li> Distributed directory class:  Epetra_Directory - Allows construction of a distributed directory.
     Once constructed, a directory allows one to access randomly distributed objects in an efficient, scalable
     manner.  This class is intended for support of general Epetra_BlockMap and Epetra_Map objects, but is 
     useful in other settings as well.

<li> BLAS wrapper class: Epetra_BLAS - A ``thin'' layer of C++ code wrapping the basic linear algebra subprograms (BLAS).
     This class provides a single instance interface between Epetra and the BLAS.  In this way we can easily
     switch BLAS interfaces and manage the C++/Fortran translation differences that exist between different
     computer systems.  This class also provides a very convenient way to templatize the BLAS.

<li> LAPACK wrapper class: Epetra_LAPACK - A ``thin'' layer of C++ code wrapping LAPACK.  Like Epetra_BLAS,
     it provides nice C++ access to LAPACK.

</ol>
</ul>
     
\subsection Epetra_wrappers Fortran and C Support

Epetra provides a small set of user-extendable Fortran and C interfaces.  These are found in 
Epetra_C_wrappers and Epetra_Fortran_wrappers.  These wrappers are hand-generated, so adding to the list
requires hand-coding.  The Trilinos team is looking at automated techniques to support Fortran and C, but
we have not made any signficant effort in this direction.

\subsection Epetra_trilinos Trilinos and Epetra

Epetra can be used as a stand-alone package.  However, it also provides the foundation for
Trilinos.  Trilinos is a collection of solver packages.  The first available
package is AztecOO, a C++ implementation of the preconditioned iterative solver package Aztec.  
This particular class can be used to solve a linear system as defined by a Epetra_LinearProblem 
object that is passed in at construction.  Alternatively, one may pass in the matrix, initial guess and
right-hand-side as Epetra objects and solves a linear system using preconditioner and
solver options set by the user.

\note AztecOO supports all the functionality of Aztec except for explicit scaling options.  Explicit
scaling is done instead by the Epetra_LinearProblem class (which in turn uses the scaling methods
in the Epetra_RowMatrix and Epetra_MultiVector classes).  Documentation for Aztec can be found
in your Trilinos archive in the file Trilinos/doc/aztec/manual.ps

\subsection Epetra_aztec2trilinos Transition support for current Aztec users

In order to support existing Aztec users, we have developed a few modules that aid in the transition from
Aztec to Trilinos/AztecOO.  The first module is AZOO_iterate().  This function has an identical interface to
AZ_iterate and, for most purpose, these two should be interchangeable.  AZOO_iterate() differs from AZ_iterate in
that it first converts the Aztec objects to Epetra objects using the module Aztec2Epetra().  It then creates an 
Epetra_LinearProblem and performs any requested scaling explicitly,
and then calls AztecOO.  The transition to AZOO_iterate() is meant to be trivial and temporary.  We encourage users 
to customize their own version of AZOO_iterate(), and to eventually build Epetra objects directly.

AztecOO also provides the Epetra_MsrMatrix class as an Epetra_RowMatrix adapter 
that accepts an AZ_MATRIX struct (as defined in Aztec 2.1) and provides Epetra_RowMatrix functionality
using the AZ_MATRIX object, without copying matrix data.  If your application already stores matrix data
in an AZ_MATRIX struct, then you can directly use AztecOO, ML and Ifpack without reimplementing the matrix
construction process using native Epetra sparse matrix classes.

\subsection Epetra_extending Extending Epetra functionality

Epetra, and therefore Trilinos, is easily extended to support new implementations of basic functionality.  Although
Epetra provides serial and MPI support, other parallel communication methods (such as Co-array Fortran, UPC, SHMEM, etc.)
can be implemented because parallel machine functionality is accessed via the abstract Epetra_Comm interface.  Similarly, 
solver algorithms that need access to the action of a linear operator on a vector get access to this functionality via
the Epetra_Operator interface.  Any class (including all Epetra matrix classes, Ifpack and ML preconditioners and AztecOO) 
that implements the Epetra_Operator interface can be used.  The final major abstract interface in Epetra is Epetra_RowMatrix.
Any solver algorithm that needs access to matrix coefficients can obtain this information via the Epetra_RowMatrix interface.
All Epetra sparse matrix classes implement this interface.  AztecOO, Ifpack, ML and other packages access matrix coefficients
via the Epetra_RowMatrix interface.  

By using abstract base classes to access external functionality and then providing a wide range of default
implementations.  Novel adapters to Epetra_Comm have been developed experimentally, but no production code is available
beyond serial and MPI.  Epetra_Operator is commonly extended by users who have complex operators that cannot be explicitly 
constructed but can be implicitly applied.  Examples include ``matrix-free'' methods such as directional derivative approximations
and implicit inverses via iterative methods.  Most preconditioners are easily expressed as Epetra_Operator objects.  Epetra_RowMatrix
is often extended to provide support for alternative data structures, or to eliminate the need to explicitly store matrix coefficients
but instead build them ``on-the-fly'' row-by-row as needed.

Note: Although Epetra_RowMatrix is the base class that is used to access matrix
coefficient information, if you want to provide your own implementation of Epetra_RowMatrix, it is probably best to inherit
from the Epetra_BasicRowMatrix.  Epetra_BasicRowMatrix provides a reasonable implementation of most Epetra_RowMatrix methods
and reduces the number of methods you must implement from 39 to between 4 and 6.  To see an example of how to make your
own Epetra_RowMatrix class using Epetra_BasicRowMatrix as a starting point, see the Epetra_JadMatrix class.

\subsubsection why_not_abstract_vector Why not abstract multivector and vector classes?

Although it may seem logical to have abstract multivector and vector classes, the practival value of such classes is not
as obvious to the Epetra developers, at least at the Epetra level of functionality.  Serious efforts in abstract multivectors/vectors
is \e very important to Trilinos, however our efforts in this area have been focused on the Thyra package.  In Thyra the user will
find a broad set of interfaces and an incredibly useful capability to provide user-defined multivector/vector operations (see the RTOp 
package).  Furthermore, Epetra multivectors/vectors are fully compatible with Thyra.

\subsection Epetra_example Example Codes
The following example code generates a simple tridiagonal matrix of
dimension "n" where "n" is passed in as an argument.  The matrix is
then used by the power method to compute the largest eigenvalue and
corresponding eigenvector.

The point of this example is to illustrate the flow of calls when
using Epetra.  This example program can be found in the file
Trilinos/packages/epetra/examples/petra_power_method/cxx_main.cpp.  

\verbinclude cxx_main.cpp

\section Epetra_adapters Epetra adapters for Thyra and PyTrilinos

The Epetra pacakge can also optionally support adapters to various interfaces.
Support for these adapters can be turned on at configure time.

<ul>

<li> <a href="../../thyra/doc/html/index.html">Epetra to Thyra Operator/Vector Adapters</a>:  These adapters take
Epetra objects and turn them into %Thyra objects.

<li> <a href="../../../pytrilinos/doc/html/index.html">Epetra to PyTrinos Adapters</a>: These are Python wrappers that allow Epetra to be used from Python.

</ul>

\section Epetra_browser Browse all of Epetra as a single doxygen collection

You can browse all of Epetra as a <A HREF="../../browser/doc/html/index.html">single
doxygen collection</A>. Warning, this is not the recommended way to learn
about Epetra software.  However, this is a good way to browse the <a
href="../../browser/doc/html/dirs.html">directory structure of epetra</a>, to <a
href="../../browser/doc/html/files.html">locate files</a>, etc.

*/
