#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

/* %not-for-header */

/* %if-c-only */
/* %if-not-reentrant */
/* %endif */
/* %endif */
/* %ok-for-header */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 37
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* %if-c++-only */
/* The c++ scanner is a mess. The FlexLexer.h header file relies on the
 * following macro. This is required in order to pass the c++-multiple-scanners
 * test in the regression suite. We get reports that it breaks inheritance.
 * We will address this in a future release of flex, or omit the C++ scanner
 * altogether.
 */
#define yyFlexLexer SEAMSFlexLexer
/* %endif */

/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
/* %if-c-only */
/* %endif */

/* %if-tables-serialization */
/* %endif */
/* end standard C headers. */

/* %if-c-or-c++ */
/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t   flex_int8_t;
typedef uint8_t  flex_uint8_t;
typedef int16_t  flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t  flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char        flex_int8_t;
typedef short int          flex_int16_t;
typedef int                flex_int32_t;
typedef unsigned char      flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int       flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* %endif */

/* %if-c++-only */
/* begin standard C++ headers. */
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <errno.h>
#include <iostream>
/* end standard C++ headers. */
/* %endif */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else /* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined(__STDC__)

#define YY_USE_CONST

#endif /* defined (__STDC__) */
#endif /* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* %not-for-header */

/* Returned upon end-of-file. */
#define YY_NULL 0
/* %ok-for-header */

/* %not-for-header */

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int)(unsigned char)c)
/* %ok-for-header */

/* %if-reentrant */
/* %endif */

/* %if-not-reentrant */

/* %endif */

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

/* %if-not-reentrant */
extern yy_size_t yyleng;
/* %endif */

/* %if-c-only */
/* %if-not-reentrant */
/* %endif */
/* %endif */

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

#define YY_LESS_LINENO(n)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                                  \
  do {                                                                                             \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    *yy_cp                                = (yy_hold_char);                                        \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;        \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                                                 \
  } while (0)

#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
  /* %if-c-only */
  /* %endif */

  /* %if-c++-only */
  std::istream *yy_input_file;
  /* %endif */

  char *yy_ch_buf;  /* input buffer */
  char *yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  yy_size_t yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  yy_size_t yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* %if-c-only Standard (non-C++) definition */
/* %not-for-header */

/* %if-not-reentrant */
/* %endif */
/* %ok-for-header */

/* %endif */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* %if-c-only Standard (non-C++) definition */
/* %if-not-reentrant */
/* %not-for-header */

/* %ok-for-header */

/* %endif */
/* %endif */

void *SEAMSalloc(yy_size_t);
void *SEAMSrealloc(void *, yy_size_t);
void  SEAMSfree(void *);

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive)                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER) {                                                                      \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                                  \
  }

#define yy_set_bol(at_bol)                                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER) {                                                                      \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                                  \
  }

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
/* Begin user sect3 */

#define FLEX_DEBUG

typedef unsigned char YY_CHAR;

#define yytext_ptr yytext
#define YY_INTERACTIVE

#include <FlexLexer.h>

/* %if-c-only Standard (non-C++) definition */
/* %endif */

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                                        \
  (yytext_ptr) = yy_bp;                                                                            \
  /* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */                         \
  yyleng         = (size_t)(yy_cp - yy_bp);                                                        \
  (yy_hold_char) = *yy_cp;                                                                         \
  *yy_cp         = '\0';                                                                           \
  /* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */                        \
  (yy_c_buf_p) = yy_cp;

/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
#define YY_NUM_RULES 102
#define YY_END_OF_BUFFER 103
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
{
  flex_int32_t yy_verify;
  flex_int32_t yy_nxt;
};
static yyconst flex_int16_t yy_accept[703] = {
    0,  0,  0,   52,  52,  0,   0,   41,  41,  0,   0,  2,   2,   0,   0,   0,   0,
    0,  0,  0,   0,   0,   0,   103, 100, 100, 101, 98, 99,  99,  99,  100, 95,  52,
    72, 87, 100, 69,  100, 100, 73,  74,  65,  63,  75, 64,  51,  68,  50,  77,  76,
    79, 54, 80,  78,  53,  53,  53,  88,  89,  70,  95, 100, 92,  66,  100, 100, 98,
    99, 99, 99,  100, 95,  44,  44,  45,  41,  44,  41, 41,  41,  41,  44,  44,  100,
    3,  3,  4,   2,   3,   2,   2,   2,   2,   3,   3,  100, 100, 35,  98,  99,

    99, 99, 100, 95,  100, 100, 98,  100, 100, 99,  99, 99,  100, 95,  100, 100, 19,
    98, 99, 99,  99,  100, 95,  100, 100, 23,  98,  99, 99,  99,  100, 95,  100, 100,
    27, 98, 99,  99,  99,  100, 95,  0,   0,   99,  99, 99,  93,  94,  0,   0,   0,
    0,  0,  0,   0,   0,   0,   0,   52,  0,   84,  0,  90,  85,  0,   91,  71,  57,
    61, 55, 62,  56,  51,  0,   67,  58,  51,  50,  0,  81,  83,  82,  53,  53,  53,
    59, 0,  86,  0,   0,   0,   0,   99,  99,  99,  93, 94,  0,   0,   0,

    41, 41, 41,  41,  41,  42,  43,  0,   0,   0,   0,  2,   2,   2,   2,   2,   0,
    0,  35, 0,   0,   99,  99,  99,  93,  94,  0,   0,  0,   0,   0,   0,   0,   0,
    0,  0,  0,   0,   0,   99,  99,  99,  93,  94,  0,  0,   19,  0,   0,   99,  99,
    99, 93, 94,  0,   0,   0,   0,   23,  0,   0,   99, 99,  99,  93,  94,  0,   0,
    0,  0,  27,  0,   0,   99,  99,  99,  93,  94,  0,  0,   0,   0,   0,   99,  99,
    0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,  0,   0,   60,  0,

    51, 0,  50,  53,  53,  0,   49,  99,  99,  0,   0,  41,  41,  0,   0,   0,   2,
    2,  0,  99,  99,  0,   0,   0,   0,   0,   13,  0,  0,   0,   0,   0,   0,   0,
    99, 99, 0,   0,   99,  99,  0,   0,   0,   0,   99, 99,  0,   0,   0,   0,   99,
    99, 0,  0,   0,   0,   0,   0,   96,  97,  0,   0,  0,   0,   0,   0,   0,   0,
    0,  0,  0,   0,   0,   0,   53,  53,  49,  96,  97, 0,   0,   41,  41,  0,   0,
    0,  37, 0,   0,   2,   2,   0,   96,  97,  0,   0,  0,   0,   0,   0,

    0,  15, 0,   0,   13,  0,   0,   14,  0,   96,  97, 0,   0,   96,  97,  0,   0,
    0,  0,  96,  97,  0,   0,   0,   0,   96,  97,  0,  0,   0,   0,   0,   0,   0,
    0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,  0,   0,   0,   0,   0,   0,
    0,  0,  0,   0,   0,   0,   33,  0,   0,   0,   0,  0,   0,   0,   0,   0,   0,
    0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,  0,   0,   0,   0,   6,   0,
    0,  0,  0,   0,   0,   0,   12,  0,   0,   0,   0,  0,   0,   0,   0,

    0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,  0,   0,   0,   0,   0,   0,
    0,  0,  0,   0,   0,   0,   0,   24,  0,   0,   0,  0,   0,   39,  0,   0,   0,
    29, 0,  0,   0,   0,   0,   0,   0,   0,   0,   0,  0,   36,  0,   0,   0,   35,
    0,  0,  0,   0,   0,   0,   0,   0,   0,   19,  0,  0,   0,   17,  0,   0,   23,
    0,  0,  0,   21,  0,   27,  0,   0,   0,   0,   0,  0,   0,   46,  0,   0,   30,
    0,  8,  0,   0,   0,   0,   49,  0,   0,   0,   40, 0,   38,  0,   0,

    31, 0,  32,  0,   0,   0,   0,   0,   0,   0,   19, 0,   0,   0,   23,  0,   0,
    27, 0,  0,   0,   0,   0,   0,   0,   47,  0,   0,  0,   0,   39,  0,   49,  0,
    0,  34, 0,   15,  0,   0,   0,   0,   16,  0,   0,  20,  0,   0,   0,   0,   48,
    0,  7,  0,   0,   0,   25,  0,   46,  0,   0,   0,  15,  0,   0,   0,   0,   25,
    0,  9,  0,   0,   0,   0,   0,   0,   0,   18,  0,  22,  0,   0,   0,   0,   0,
    28, 0,  0,   26,  0,   0,   0,   0,   0,   0,   5,  0,   0,   10,  1,

    11, 0};

static yyconst flex_int32_t yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  2,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  4,  5,  6,  1,  7,  8,  9,  10, 11, 12,
    13, 14, 15, 16, 17, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 21, 22, 23, 24,
    25, 1,  26, 27, 28, 29, 30, 31, 29, 32, 33, 29, 29, 34, 35, 36, 37, 29, 38, 39, 29,
    40, 41, 42, 29, 43, 29, 29, 44, 45, 46, 47, 29, 1,  48, 49, 50, 51,

    52, 53, 29, 54, 55, 29, 29, 56, 29, 57, 58, 59, 38, 60, 61, 62, 63, 29, 64, 43, 29,
    29, 65, 66, 67, 68, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};

static yyconst flex_int32_t yy_meta[69] = {0, 1, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                           1, 5, 6, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                                           5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5,
                                           5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 1, 1, 1};

static yyconst flex_int16_t yy_base[752] = {
    0,    0,    0,    68,   0,    136,  0,    204,  0,    271,  272,  337,  0,    405,  0,
    473,  0,    541,  0,    609,  0,    677,  0,    2511, 2512, 744,  2512, 2512, 0,    2467,
    236,  213,  808,  748,  2512, 2486, 276,  2512, 2499, 2497, 2512, 2512, 268,  269,  2512,
    270,  265,  267,  270,  2512, 2512, 2483, 2482, 2481, 2512, 0,    2460, 247,  2512, 2512,
    2479, 264,  2435, 2512, 2512, 2488, 749,  2487, 864,  2455, 255,  735,  737,  2512, 752,
    2512, 753,  2512, 756,  293,  755,  756,  236,  775,  760,  2512, 761,  2512, 764,  2512,
    767,  294,  768,  774,  237,  277,  2494, 778,  2512, 2493, 932,

    2452, 264,  768,  801,  2482, 781,  2481, 989,  990,  1042, 2449, 265,  780,  810,  2488,
    1109, 2512, 2487, 1174, 2446, 267,  784,  1111, 2485, 1241, 2512, 2484, 1306, 2443, 268,
    787,  1112, 2482, 1373, 2512, 2481, 1438, 2440, 270,  1504, 1119, 1507, 2440, 0,    279,
    740,  2512, 2512, 1114, 2426, 975,  771,  2422, 2442, 2448, 2425, 264,  717,  1508, 771,
    2512, 320,  2512, 2512, 2466, 2512, 2452, 2512, 2512, 2512, 2512, 2512, 985,  997,  2512,
    2512, 987,  993,  1008, 2512, 2512, 2512, 0,    806,  981,  2512, 268,  2512, 2462, 1511,
    1512, 1105, 0,    985,  1092, 2461, 2460, 1116, 1515, 1244,

    1516, 1519, 787,  1243, 1245, 2512, 2512, 1249, 969,  2418, 1523, 1524, 1520, 1001, 1248,
    1250, 2440, 2466, 2512, 1527, 1375, 0,    1093, 1096, 2465, 2464, 1376, 1378, 2454, 1368,
    1530, 1243, 1532, 1245, 1120, 1370, 1250, 1371, 1142, 0,    1097, 1098, 2453, 2452, 1372,
    2460, 2512, 1535, 1549, 0,    1100, 1107, 2459, 2458, 1255, 1505, 1533, 2457, 2512, 1543,
    1564, 0,    1217, 1227, 2456, 2455, 1537, 1546, 1538, 2454, 2512, 1552, 1607, 0,    1233,
    1234, 2453, 2452, 1611, 1550, 800,  1382, 1562, 1231, 1347, 2397, 2396, 2420, 2390, 2399,
    2414, 977,  2398, 2389, 2416, 2406, 2391, 2392, 2512, 2423,

    2422, 2421, 2420, 1349, 1351, 1556, 1026, 1352, 1353, 1521, 804,  1620, 1624, 2382, 2376,
    1623, 1625, 1626, 2397, 1354, 1355, 796,  1571, 1639, 1282, 1394, 2512, 1554, 1395, 1108,
    1131, 1400, 1272, 1406, 1359, 1360, 1575, 1581, 1362, 1364, 1573, 1623, 1601, 1635, 1508,
    1593, 1636, 1644, 1632, 1645, 1609, 1611, 1650, 1651, 1653, 1664, 1383, 1665, 0,    0,
    2384, 2384, 2396, 2380, 1636, 2390, 2378, 2378, 2372, 2368, 2398, 2398, 2376, 1637, 0,
    0,    2420, 0,    0,    1663, 1664, 1539, 1675, 2361, 2369, 1697, 2512, 2368, 2368, 1698,
    1702, 2391, 0,    0,    1669, 1678, 1724, 2414, 1682, 1686,

    1407, 2512, 1697, 1711, 2512, 1717, 1727, 2512, 1728, 0,    0,    1665, 1712, 0,    0,
    1710, 1707, 1735, 1729, 0,    0,    1733, 1740, 1741, 1739, 0,    0,    1738, 1747, 1745,
    1749, 1746, 1748, 2355, 2359, 1735, 2347, 2360, 2372, 2358, 2358, 2346, 1751, 2376, 2381,
    2343, 2341, 1744, 1751, 2352, 1750, 2350, 2350, 2375, 1751, 1754, 2397, 2512, 1755, 1758,
    1768, 1770, 1773, 1748, 1753, 1763, 1769, 1774, 1776, 1810, 1783, 1784, 1813, 1816, 1820,
    1817, 1823, 1826, 2396, 1825, 1827, 2335, 2360, 2512, 2393, 2328, 2368, 1831, 2340, 2341,
    1835, 2512, 2354, 2350, 2102, 2089, 1829, 1826, 1807, 2084,

    1845, 2079, 2072, 2108, 1840, 1850, 1841, 1845, 1838, 1852, 2107, 1855, 1856, 1861, 2106,
    1864, 2104, 1857, 1865, 1873, 2103, 2102, 1866, 2100, 2512, 1870, 1877, 2051, 999,  2098,
    2512, 2097, 2072, 1881, 2512, 1885, 2046, 2029, 2062, 2032, 2031, 1892, 1897, 1894, 2089,
    1908, 2512, 1914, 2058, 2087, 2512, 2086, 1925, 2085, 1935, 1899, 1918, 1928, 1900, 2084,
    2512, 2083, 1910, 2081, 2512, 1912, 2080, 2512, 2079, 1914, 2078, 2512, 2077, 2512, 2076,
    1879, 1931, 2025, 2045, 2063, 2070, 2512, 2038, 1940, 2512, 1941, 2512, 2036, 1945, 2020,
    1951, 1945, 1947, 1963, 2066, 2512, 1970, 2512, 2033, 2062,

    2512, 2061, 2512, 1975, 2060, 1959, 1977, 1979, 1932, 2059, 2512, 2058, 1953, 2057, 2512,
    2055, 2054, 2512, 1992, 817,  1995, 2044, 1988, 2024, 1996, 2512, 2042, 1999, 2049, 1997,
    2031, 2011, 1980, 2015, 2006, 2512, 2005, 2512, 2007, 2013, 1965, 2002, 2512, 1973, 1985,
    2512, 2018, 1984, 1981, 2025, 2512, 1894, 2512, 1949, 1844, 1868, 2512, 2000, 1867, 1710,
    2025, 2028, 2512, 2030, 1675, 1561, 1560, 2512, 2041, 2512, 1514, 1514, 2037, 1417, 1365,
    2035, 1289, 2512, 1287, 2512, 2046, 1284, 1088, 1274, 1258, 2512, 1228, 1253, 2512, 1113,
    1021, 729,  774,  772,  268,  2512, 265,  248,  2512, 2512,

    2512, 2512, 2109, 2115, 2121, 2123, 2129, 2134, 2136, 2141, 2143, 2149, 2155, 2161, 2167,
    2173, 2179, 2185, 2191, 2197, 2203, 2209, 2215, 2221, 2227, 2233, 2239, 2245, 2251, 2257,
    2263, 2269, 2275, 2281, 2287, 2293, 2299, 2305, 2311, 2317, 2323, 2329, 2335, 2341, 2347,
    2353, 2359, 2365, 2371, 2377, 2383};

static yyconst flex_int16_t yy_def[752] = {
    0,   702, 1,   702, 3,   702, 5,   702, 7,   1,   1,   702, 11,  702, 13,  702, 15,
    702, 17,  702, 19,  702, 21,  702, 702, 702, 702, 702, 703, 703, 703, 702, 702, 702,
    702, 702, 704, 702, 702, 705, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 706, 706, 706, 702, 702, 702, 702, 702, 702, 702, 707, 707, 707,
    702, 68,  68,  707, 707, 702, 702, 702, 708, 702, 708, 709, 709, 709, 702, 702, 702,
    702, 702, 702, 710, 702, 710, 711, 711, 711, 702, 702, 712, 712, 702, 712, 702,

    100, 100, 712, 712, 713, 713, 713, 713, 713, 702, 110, 110, 713, 713, 714, 714, 702,
    714, 702, 119, 119, 714, 714, 715, 715, 702, 715, 702, 128, 128, 715, 715, 716, 716,
    702, 716, 702, 137, 137, 716, 716, 702, 32,  703, 703, 703, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 704, 702, 702, 705, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 706, 706, 706,
    702, 702, 702, 707, 707, 707, 707, 68,  68,  68,  707, 707, 707, 702, 702,

    708, 708, 709, 709, 709, 702, 702, 702, 702, 702, 702, 710, 710, 711, 711, 711, 702,
    712, 702, 712, 712, 100, 100, 100, 712, 712, 712, 712, 713, 713, 713, 713, 717, 713,
    713, 713, 713, 713, 713, 110, 110, 110, 713, 713, 713, 714, 702, 714, 714, 119, 119,
    119, 714, 714, 714, 714, 714, 715, 702, 715, 715, 128, 128, 128, 715, 715, 715, 715,
    715, 716, 702, 716, 716, 137, 137, 137, 716, 716, 716, 716, 716, 716, 716, 703, 703,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,

    702, 702, 702, 706, 706, 707, 707, 68,  68,  707, 707, 709, 709, 702, 702, 702, 711,
    711, 702, 100, 100, 712, 712, 712, 718, 717, 702, 717, 719, 713, 713, 720, 713, 713,
    110, 110, 713, 713, 119, 119, 714, 714, 714, 714, 128, 128, 715, 715, 715, 715, 137,
    137, 716, 716, 716, 716, 716, 716, 703, 703, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 706, 706, 702, 68,  68,  707, 707, 709, 709, 702, 702,
    702, 702, 702, 702, 711, 711, 702, 100, 100, 712, 712, 712, 721, 712, 712,

    718, 702, 718, 719, 702, 719, 720, 702, 720, 110, 110, 713, 713, 119, 119, 714, 714,
    714, 714, 128, 128, 715, 715, 715, 715, 137, 137, 716, 716, 716, 716, 716, 716, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 707, 707, 702, 702,
    702, 702, 702, 712, 712, 721, 702, 712, 712, 718, 719, 720, 713, 713, 714, 714, 714,
    714, 714, 715, 715, 715, 715, 715, 716, 716, 716, 722, 716, 716, 702, 702, 702, 723,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 724, 707, 702, 702,

    702, 702, 702, 725, 712, 712, 712, 726, 713, 714, 727, 714, 714, 714, 728, 715, 729,
    715, 715, 715, 730, 731, 716, 722, 702, 716, 716, 702, 702, 723, 702, 732, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 724, 724, 733, 734, 702, 702, 702, 702, 725, 702,
    735, 712, 736, 712, 726, 726, 737, 714, 727, 702, 738, 714, 728, 702, 715, 729, 702,
    739, 715, 730, 702, 731, 702, 740, 716, 716, 702, 702, 702, 732, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 724, 724, 733, 733, 734, 702, 702, 702, 702, 735,

    702, 736, 702, 712, 741, 742, 737, 737, 714, 738, 702, 743, 715, 739, 702, 744, 740,
    702, 716, 716, 702, 702, 702, 702, 702, 702, 702, 702, 745, 702, 702, 733, 733, 702,
    741, 702, 742, 702, 742, 746, 714, 743, 702, 715, 744, 702, 716, 747, 716, 702, 702,
    702, 702, 702, 702, 745, 702, 702, 702, 702, 742, 746, 702, 746, 748, 749, 747, 702,
    716, 702, 702, 702, 702, 750, 702, 746, 748, 702, 749, 702, 716, 751, 702, 702, 750,
    702, 702, 751, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,

    702, 0,   702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702};

static yyconst flex_int16_t yy_nxt[2581] = {
    0,   24,  25,  26,  25,  24,  24,  27,  24,  24,  24,  24,  24,  24,  24,  24,  24,
    24,  24,  24,  24,  24,  24,  24,  24,  24,  28,  28,  28,  28,  29,  28,  28,  28,
    28,  28,  28,  28,  30,  28,  28,  28,  28,  28,  24,  31,  24,  24,  28,  28,  28,
    28,  29,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  28,  32,  24,  24,
    24,  24,  33,  34,  33,  35,  36,  27,  37,  38,  39,  40,  41,  42,  43,  44,  45,
    46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  55,  55,  55,  56,  55,  55,

    55,  55,  55,  55,  55,  57,  55,  55,  55,  55,  55,  58,  31,  59,  60,  55,  55,
    55,  55,  56,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  55,  61,  62,
    63,  64,  65,  66,  26,  66,  65,  65,  67,  65,  65,  65,  65,  65,  65,  65,  65,
    65,  65,  65,  65,  65,  65,  65,  65,  65,  65,  68,  68,  68,  68,  69,  68,  68,
    68,  68,  68,  68,  68,  70,  68,  68,  68,  68,  68,  65,  71,  65,  65,  68,  68,
    68,  68,  69,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,

    72,  65,  65,  65,  73,  74,  75,  76,  73,  73,  77,  73,  73,  73,  73,  73,  73,
    73,  73,  73,  73,  73,  78,  73,  73,  73,  73,  73,  73,  79,  79,  79,  79,  80,
    79,  79,  79,  79,  79,  79,  79,  81,  79,  79,  79,  79,  79,  73,  82,  73,  73,
    79,  79,  79,  79,  80,  79,  79,  79,  79,  79,  79,  79,  79,  79,  79,  79,  79,
    83,  73,  73,  73,  84,  84,  84,  84,  146, 147, 163, 148, 167, 163, 169, 173, 175,
    171, 177, 185, 178, 176, 168, 170, 172, 187, 174, 195, 202, 213, 146, 179,

    206, 147, 207, 148, 224, 242, 187, 252, 264, 185, 276, 284, 144, 144, 701, 187, 174,
    195, 217, 289, 298, 179, 163, 289, 290, 163, 224, 242, 187, 252, 264, 700, 276, 284,
    699, 61,  61,  85,  86,  87,  88,  85,  85,  89,  85,  85,  85,  85,  85,  85,  85,
    85,  85,  85,  85,  90,  85,  85,  85,  85,  85,  85,  91,  91,  91,  91,  92,  91,
    91,  91,  91,  91,  91,  91,  93,  91,  91,  91,  91,  91,  85,  94,  85,  85,  91,
    91,  91,  91,  92,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,  91,

    91,  95,  85,  85,  85,  96,  97,  98,  97,  96,  96,  99,  96,  96,  96,  96,  96,
    96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  96,  100, 100, 100, 100,
    101, 100, 100, 100, 100, 100, 100, 100, 102, 100, 100, 100, 100, 100, 96,  103, 96,
    96,  100, 100, 100, 100, 101, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
    100, 104, 96,  96,  96,  105, 106, 26,  106, 105, 105, 107, 105, 105, 105, 105, 105,
    105, 105, 105, 105, 108, 105, 109, 105, 105, 105, 105, 105, 105, 110, 110,

    110, 110, 111, 110, 110, 110, 110, 110, 110, 110, 112, 110, 110, 110, 110, 110, 105,
    113, 105, 105, 110, 110, 110, 110, 111, 110, 110, 110, 110, 110, 110, 110, 110, 110,
    110, 110, 110, 114, 105, 105, 105, 115, 116, 117, 116, 115, 115, 118, 115, 115, 115,
    115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 115, 119, 119,
    119, 119, 120, 119, 119, 119, 119, 119, 119, 119, 121, 119, 119, 119, 119, 119, 115,
    122, 115, 115, 119, 119, 119, 119, 120, 119, 119, 119, 119, 119, 119, 119,

    119, 119, 119, 119, 119, 123, 115, 115, 115, 124, 125, 126, 125, 124, 124, 127, 124,
    124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124,
    128, 128, 128, 128, 129, 128, 128, 128, 128, 128, 128, 128, 130, 128, 128, 128, 128,
    128, 124, 131, 124, 124, 128, 128, 128, 128, 129, 128, 128, 128, 128, 128, 128, 128,
    128, 128, 128, 128, 128, 132, 124, 124, 124, 133, 134, 135, 134, 133, 133, 136, 133,
    133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133, 133,

    133, 133, 137, 137, 137, 137, 138, 137, 137, 137, 137, 137, 137, 137, 139, 137, 137,
    137, 137, 137, 133, 140, 133, 133, 137, 137, 137, 137, 138, 137, 137, 137, 137, 137,
    137, 137, 137, 137, 137, 137, 137, 141, 133, 133, 133, 142, 190, 142, 190, 159, 191,
    159, 191, 199, 199, 199, 201, 702, 202, 202, 190, 211, 211, 211, 211, 211, 198, 212,
    702, 292, 219, 213, 285, 293, 144, 144, 208, 213, 208, 220, 219, 220, 231, 698, 231,
    697, 247, 144, 198, 259, 202, 230, 230, 144, 285, 696, 205, 204, 219, 196,

    187, 197, 271, 219, 209, 291, 144, 210, 143, 149, 215, 149, 160, 192, 216, 190, 200,
    200, 205, 271, 702, 230, 187, 292, 160, 160, 209, 293, 160, 210, 227, 702, 225, 228,
    226, 150, 216, 151, 304, 245, 152, 153, 221, 154, 243, 232, 244, 356, 253, 155, 254,
    265, 227, 266, 381, 228, 395, 150, 156, 157, 304, 245, 158, 153, 189, 189, 649, 189,
    189, 189, 189, 189, 189, 189, 189, 190, 189, 189, 189, 189, 189, 189, 193, 193, 189,
    189, 189, 189, 189, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193,

    193, 193, 193, 193, 193, 193, 193, 189, 189, 189, 189, 193, 193, 193, 193, 193, 193,
    193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 189, 189, 189, 189, 218, 218,
    219, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 222,
    222, 218, 218, 218, 218, 218, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222,
    222, 222, 222, 222, 222, 222, 222, 218, 218, 218, 218, 222, 222, 222, 222, 222, 222,
    222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 222, 218, 218, 218, 218,

    233, 236, 288, 173, 213, 173, 237, 234, 238, 177, 300, 178, 300, 305, 174, 301, 174,
    308, 235, 239, 144, 302, 179, 302, 315, 290, 303, 367, 377, 579, 289, 290, 695, 368,
    580, 305, 174, 190, 174, 308, 235, 239, 229, 229, 179, 229, 229, 229, 229, 229, 229,
    229, 229, 230, 229, 229, 229, 229, 229, 229, 240, 240, 229, 229, 229, 229, 229, 240,
    240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,
    229, 229, 229, 229, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240,

    240, 240, 240, 240, 240, 240, 229, 229, 229, 229, 248, 247, 248, 247, 259, 149, 190,
    149, 690, 230, 279, 271, 279, 691, 309, 320, 331, 190, 321, 335, 336, 230, 339, 330,
    198, 330, 255, 267, 331, 340, 256, 268, 233, 694, 257, 269, 309, 320, 280, 331, 321,
    335, 336, 230, 339, 333, 198, 333, 255, 267, 334, 340, 256, 268, 156, 286, 257, 269,
    281, 282, 283, 310, 311, 249, 246, 246, 247, 246, 246, 246, 246, 246, 246, 246, 246,
    246, 246, 246, 246, 246, 246, 246, 250, 250, 246, 246, 246, 246, 246, 250,

    250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
    246, 246, 246, 246, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250,
    250, 250, 250, 250, 246, 246, 246, 246, 260, 259, 260, 208, 202, 208, 202, 345, 208,
    213, 208, 213, 230, 689, 233, 247, 693, 346, 686, 233, 144, 234, 144, 351, 352, 144,
    234, 144, 359, 345, 245, 209, 235, 312, 210, 313, 314, 235, 317, 346, 318, 230, 402,
    692, 689, 351, 352, 680, 334, 678, 359, 403, 245, 209, 235, 312, 210, 313,

    314, 235, 317, 341, 318, 261, 258, 258, 259, 258, 258, 258, 258, 258, 258, 258, 258,
    258, 258, 258, 258, 258, 258, 258, 262, 262, 258, 258, 258, 258, 258, 262, 262, 262,
    262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 258, 258,
    258, 258, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262, 262,
    262, 262, 258, 258, 258, 258, 272, 271, 272, 219, 219, 230, 219, 230, 236, 230, 271,
    271, 360, 237, 375, 238, 376, 378, 379, 393, 394, 687, 327, 405, 410, 411,

    239, 414, 408, 415, 227, 328, 406, 228, 360, 402, 375, 409, 376, 378, 379, 393, 394,
    236, 403, 686, 410, 411, 239, 414, 334, 415, 227, 337, 338, 228, 324, 322, 323, 357,
    325, 432, 332, 273, 270, 270, 271, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270,
    270, 270, 270, 270, 270, 274, 274, 270, 270, 270, 270, 270, 274, 274, 274, 274, 274,
    274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 270, 270, 270, 270,
    274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274,

    274, 274, 270, 270, 270, 270, 271, 247, 142, 159, 142, 159, 306, 191, 306, 191, 199,
    199, 199, 201, 702, 702, 190, 190, 211, 211, 211, 212, 220, 219, 220, 231, 190, 231,
    327, 247, 248, 247, 248, 259, 259, 230, 202, 328, 260, 259, 260, 420, 259, 684, 683,
    247, 271, 272, 271, 272, 327, 306, 144, 306, 342, 343, 668, 680, 271, 328, 259, 190,
    277, 420, 278, 143, 160, 219, 255, 247, 192, 307, 256, 200, 200, 380, 257, 702, 702,
    347, 230, 160, 160, 267, 344, 221, 230, 268, 232, 350, 255, 269, 329, 249,

    256, 348, 349, 247, 257, 354, 355, 261, 279, 271, 279, 267, 279, 271, 279, 268, 273,
    354, 358, 269, 329, 396, 307, 202, 386, 247, 386, 202, 213, 213, 416, 413, 421, 387,
    259, 412, 280, 247, 259, 144, 397, 219, 397, 144, 144, 144, 259, 259, 426, 398, 427,
    418, 271, 271, 421, 271, 281, 282, 283, 382, 281, 282, 353, 383, 390, 391, 271, 271,
    438, 438, 426, 219, 427, 388, 190, 190, 230, 678, 202, 389, 219, 382, 424, 417, 219,
    383, 390, 391, 219, 399, 438, 438, 419, 422, 144, 400, 449, 447, 386, 402,

    386, 213, 425, 430, 423, 213, 428, 387, 403, 247, 456, 429, 247, 405, 448, 433, 464,
    144, 449, 405, 455, 144, 406, 230, 431, 397, 219, 397, 406, 408, 408, 247, 456, 459,
    398, 259, 460, 247, 409, 409, 271, 259, 259, 259, 465, 483, 675, 271, 271, 271, 271,
    271, 491, 219, 491, 190, 219, 219, 467, 230, 219, 492, 190, 461, 230, 247, 465, 468,
    469, 466, 402, 247, 405, 473, 474, 408, 247, 478, 247, 403, 478, 406, 500, 462, 409,
    259, 259, 470, 476, 468, 469, 472, 471, 480, 463, 473, 474, 475, 477, 478,

    479, 484, 478, 498, 500, 509, 505, 506, 481, 507, 497, 514, 247, 514, 508, 259, 485,
    504, 259, 271, 515, 520, 259, 520, 510, 271, 512, 271, 271, 271, 521, 531, 534, 513,
    534, 511, 491, 190, 491, 500, 543, 535, 219, 219, 516, 492, 546, 531, 546, 230, 517,
    553, 219, 553, 247, 547, 557, 247, 247, 259, 554, 500, 514, 247, 514, 518, 259, 259,
    271, 377, 657, 515, 271, 519, 520, 259, 520, 481, 523, 271, 672, 271, 534, 521, 534,
    559, 584, 526, 584, 522, 527, 535, 544, 555, 531, 585, 582, 566, 591, 531,

    591, 531, 247, 543, 558, 594, 552, 559, 543, 546, 557, 546, 247, 563, 259, 597, 259,
    597, 547, 566, 531, 562, 570, 569, 598, 576, 553, 219, 553, 557, 582, 577, 575, 271,
    247, 554, 604, 219, 604, 608, 619, 584, 625, 584, 625, 605, 628, 631, 628, 582, 585,
    626, 591, 531, 591, 259, 543, 609, 594, 671, 670, 638, 543, 592, 632, 582, 632, 247,
    612, 613, 639, 597, 616, 597, 594, 259, 604, 219, 604, 582, 598, 582, 659, 271, 606,
    605, 668, 646, 608, 641, 608, 594, 620, 647, 271, 647, 650, 625, 650, 625,

    628, 673, 628, 673, 643, 651, 626, 638, 636, 638, 644, 629, 632, 582, 632, 663, 639,
    592, 639, 647, 271, 647, 594, 665, 664, 660, 650, 638, 650, 633, 663, 666, 663, 377,
    669, 651, 639, 663, 673, 664, 673, 664, 681, 271, 681, 640, 664, 681, 271, 681, 658,
    657, 655, 654, 653, 652, 618, 646, 648, 615, 643, 611, 636, 603, 601, 629, 674, 634,
    596, 630, 627, 624, 582, 661, 623, 622, 621, 633, 618, 574, 572, 615, 568, 565, 648,
    611, 561, 603, 601, 551, 599, 596, 590, 589, 588, 587, 676, 586, 583, 582,

    531, 578, 525, 674, 574, 572, 568, 682, 565, 561, 551, 549, 682, 144, 144, 162, 162,
    162, 162, 162, 162, 165, 165, 165, 165, 165, 165, 183, 183, 189, 189, 548, 189, 189,
    189, 202, 545, 202, 202, 203, 203, 203, 213, 541, 213, 213, 214, 214, 214, 218, 218,
    218, 218, 218, 218, 229, 229, 540, 229, 229, 229, 246, 246, 246, 246, 246, 246, 258,
    258, 258, 258, 258, 258, 270, 270, 270, 270, 270, 270, 326, 326, 326, 326, 326, 326,
    401, 401, 401, 401, 401, 401, 404, 404, 404, 404, 404, 404, 407, 407, 407,

    407, 407, 407, 457, 457, 457, 457, 457, 457, 524, 524, 524, 524, 524, 524, 530, 530,
    530, 530, 530, 530, 542, 542, 542, 542, 542, 542, 550, 550, 550, 550, 550, 550, 556,
    556, 556, 556, 556, 556, 560, 560, 560, 560, 560, 560, 564, 564, 564, 564, 564, 564,
    567, 567, 567, 567, 567, 567, 571, 571, 571, 571, 571, 571, 573, 573, 573, 573, 573,
    573, 581, 581, 581, 581, 581, 581, 593, 593, 593, 593, 593, 593, 595, 595, 595, 595,
    595, 595, 600, 600, 600, 600, 600, 600, 602, 602, 602, 602, 602, 602, 607,

    607, 607, 607, 607, 607, 610, 610, 610, 610, 610, 610, 614, 614, 614, 614, 614, 614,
    617, 617, 617, 617, 617, 617, 635, 635, 635, 635, 635, 635, 637, 637, 637, 637, 637,
    637, 642, 642, 642, 642, 642, 642, 645, 645, 645, 645, 645, 645, 656, 656, 656, 656,
    656, 656, 662, 662, 662, 662, 662, 662, 667, 667, 667, 667, 667, 667, 677, 677, 677,
    677, 677, 677, 679, 679, 679, 679, 679, 679, 685, 685, 685, 685, 685, 685, 688, 688,
    688, 688, 688, 688, 539, 538, 537, 536, 533, 532, 531, 529, 528, 525, 458,

    503, 502, 501, 499, 496, 495, 494, 493, 490, 489, 488, 487, 486, 485, 482, 447, 458,
    454, 453, 452, 451, 450, 377, 446, 445, 444, 443, 442, 441, 440, 439, 437, 436, 435,
    434, 392, 385, 384, 303, 303, 301, 301, 374, 373, 372, 371, 370, 369, 366, 365, 364,
    363, 362, 361, 271, 271, 271, 259, 259, 259, 247, 247, 247, 230, 230, 230, 219, 219,
    219, 319, 316, 190, 190, 190, 299, 166, 297, 296, 295, 294, 287, 702, 275, 271, 271,
    263, 259, 259, 251, 247, 247, 241, 230, 230, 223, 219, 219, 194, 190, 190,

    188, 186, 184, 182, 181, 180, 166, 164, 161, 145, 702, 23,  702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702};

static yyconst flex_int16_t yy_chk[2581] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,

    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,

    5,   5,   5,   5,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   9,   10,  9,   10,  30,  31,  36,  31,  42,  36,  43,  46,  47,
    45,  48,  57,  48,  47,  42,  43,  45,  61,  46,  70,  79,  91,  30,  48,

    82,  94,  82,  94,  102, 112, 95,  121, 130, 57,  139, 145, 79,  91,  698, 61,  46,
    70,  95,  157, 157, 48,  162, 187, 187, 162, 102, 112, 95,  121, 130, 697, 139, 145,
    695, 9,   10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
    11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
    11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
    11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,

    11,  11,  11,  11,  11,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
    13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
    13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
    13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
    13,  13,  13,  13,  13,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,
    15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,

    15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,
    15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,
    15,  15,  15,  15,  15,  15,  15,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,

    17,  17,  17,  17,  17,  17,  17,  17,  17,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  21,  21,  21,  21,  21,  21,  21,  21,
    21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,

    21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,
    21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,
    21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  25,  71,  25,  72,  33,  66,
    33,  66,  74,  76,  74,  76,  78,  80,  81,  66,  84,  86,  84,  86,  88,  72,  88,
    90,  158, 103, 92,  146, 158, 80,  81,  83,  93,  83,  97,  97,  97,  106, 694, 106,
    693, 122, 92,  72,  131, 203, 113, 106, 93,  146, 692, 81,  80,  322, 71,

    160, 71,  281, 104, 83,  152, 203, 83,  25,  32,  92,  32,  33,  66,  93,  311, 74,
    76,  81,  620, 78,  114, 160, 152, 84,  86,  83,  152, 88,  83,  104, 90,  103, 104,
    103, 32,  93,  32,  184, 114, 32,  32,  97,  32,  113, 106, 113, 281, 122, 32,  122,
    131, 104, 131, 311, 104, 322, 32,  32,  32,  184, 114, 32,  32,  68,  68,  620, 68,
    68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,
    68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,

    68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,
    68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  68,  100, 100,
    100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
    100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
    100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
    100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,

    108, 109, 151, 173, 214, 177, 109, 108, 109, 178, 174, 178, 174, 185, 173, 174, 177,
    194, 108, 109, 214, 179, 178, 179, 209, 209, 179, 292, 307, 529, 151, 151, 691, 292,
    529, 185, 173, 307, 177, 194, 108, 109, 110, 110, 178, 110, 110, 110, 110, 110, 110,
    110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
    110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,
    110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 110,

    110, 110, 110, 110, 110, 110, 110, 110, 110, 110, 116, 116, 116, 123, 132, 149, 192,
    149, 683, 330, 141, 141, 141, 683, 195, 223, 330, 198, 224, 241, 242, 235, 251, 235,
    192, 235, 123, 132, 235, 252, 123, 132, 331, 690, 123, 132, 195, 223, 141, 331, 224,
    241, 242, 239, 251, 239, 192, 239, 123, 132, 239, 252, 123, 132, 149, 149, 123, 132,
    141, 141, 141, 198, 198, 116, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,

    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,
    119, 119, 119, 119, 119, 119, 119, 119, 125, 125, 125, 200, 204, 200, 205, 263, 208,
    215, 208, 216, 232, 688, 234, 255, 687, 264, 685, 237, 204, 234, 205, 275, 276, 215,
    237, 216, 284, 263, 232, 200, 234, 204, 200, 205, 208, 237, 215, 264, 216, 333, 325,
    684, 682, 275, 276, 679, 333, 677, 284, 325, 232, 200, 234, 204, 200, 205,

    208, 237, 215, 255, 216, 125, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    128, 128, 128, 128, 128, 128, 134, 134, 134, 221, 227, 230, 228, 236, 238, 245, 282,
    357, 285, 238, 304, 238, 305, 308, 309, 320, 321, 675, 326, 329, 335, 336,

    238, 339, 332, 340, 221, 326, 329, 221, 285, 401, 304, 332, 305, 308, 309, 320, 321,
    334, 401, 674, 335, 336, 238, 339, 334, 340, 221, 245, 245, 221, 228, 227, 227, 282,
    230, 357, 236, 134, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
    137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
    137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,
    137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137, 137,

    137, 137, 137, 137, 137, 137, 140, 256, 142, 159, 142, 159, 190, 191, 190, 191, 199,
    201, 199, 201, 202, 213, 190, 191, 211, 212, 211, 212, 220, 220, 220, 231, 310, 231,
    233, 257, 248, 248, 248, 267, 269, 231, 382, 233, 260, 260, 260, 345, 268, 672, 671,
    249, 280, 272, 272, 272, 328, 306, 382, 306, 256, 256, 667, 666, 283, 328, 261, 306,
    140, 345, 140, 142, 159, 323, 249, 341, 191, 190, 249, 199, 201, 310, 249, 202, 213,
    267, 337, 211, 212, 261, 257, 220, 338, 261, 231, 269, 249, 261, 233, 248,

    249, 268, 268, 343, 249, 280, 280, 260, 273, 273, 273, 261, 279, 279, 279, 261, 272,
    283, 283, 261, 328, 323, 306, 312, 316, 342, 316, 313, 317, 318, 341, 338, 346, 316,
    349, 337, 273, 344, 347, 312, 324, 324, 324, 313, 317, 318, 348, 350, 351, 324, 352,
    343, 353, 354, 346, 355, 273, 273, 273, 312, 279, 279, 279, 313, 317, 318, 356, 358,
    365, 374, 351, 395, 352, 316, 380, 381, 412, 665, 383, 316, 396, 312, 349, 342, 399,
    313, 317, 318, 400, 324, 365, 374, 344, 347, 383, 324, 381, 374, 386, 403,

    386, 390, 350, 355, 348, 391, 353, 386, 403, 417, 396, 354, 416, 404, 380, 358, 412,
    390, 381, 406, 395, 391, 404, 413, 356, 397, 397, 397, 406, 407, 409, 419, 396, 399,
    397, 422, 400, 418, 407, 409, 428, 425, 423, 424, 413, 436, 660, 430, 432, 429, 433,
    431, 443, 455, 443, 448, 456, 459, 417, 464, 460, 443, 449, 403, 465, 466, 413, 418,
    418, 416, 461, 467, 462, 424, 424, 463, 468, 430, 469, 461, 433, 462, 451, 406, 463,
    471, 472, 419, 428, 418, 418, 423, 422, 432, 409, 424, 424, 425, 429, 430,

    431, 436, 433, 449, 451, 465, 456, 459, 433, 460, 448, 470, 470, 470, 464, 473, 451,
    455, 474, 476, 470, 475, 475, 475, 466, 477, 468, 480, 478, 481, 475, 497, 488, 469,
    488, 467, 491, 498, 491, 499, 497, 488, 505, 507, 471, 491, 501, 508, 501, 509, 472,
    506, 506, 506, 510, 501, 508, 512, 513, 518, 506, 499, 514, 514, 514, 473, 516, 519,
    523, 659, 656, 514, 526, 474, 520, 520, 520, 476, 478, 527, 655, 576, 534, 520, 534,
    510, 536, 480, 536, 477, 481, 534, 498, 507, 542, 536, 544, 516, 543, 543,

    543, 556, 559, 542, 509, 544, 505, 510, 543, 546, 556, 546, 563, 513, 566, 548, 570,
    548, 546, 516, 557, 512, 519, 518, 548, 526, 553, 553, 553, 557, 558, 527, 523, 577,
    609, 553, 555, 555, 555, 558, 576, 584, 586, 584, 586, 555, 589, 592, 589, 593, 584,
    586, 591, 591, 591, 613, 592, 559, 593, 654, 652, 606, 591, 543, 594, 594, 594, 641,
    563, 566, 606, 597, 570, 597, 594, 644, 604, 604, 604, 607, 597, 608, 633, 649, 557,
    604, 648, 645, 607, 609, 608, 633, 577, 619, 619, 619, 621, 625, 621, 625,

    628, 658, 628, 658, 642, 621, 625, 637, 635, 639, 613, 589, 632, 632, 632, 640, 637,
    591, 639, 647, 647, 647, 632, 641, 640, 634, 650, 661, 650, 594, 662, 644, 664, 631,
    649, 650, 661, 676, 673, 662, 673, 664, 669, 669, 669, 608, 676, 681, 681, 681, 630,
    629, 627, 624, 623, 622, 617, 616, 619, 614, 612, 610, 605, 602, 600, 628, 658, 599,
    595, 590, 588, 583, 581, 639, 580, 579, 578, 632, 575, 573, 571, 569, 567, 564, 647,
    562, 560, 554, 552, 550, 549, 545, 541, 540, 539, 538, 664, 537, 533, 532,

    530, 528, 524, 673, 522, 521, 517, 669, 515, 511, 504, 503, 681, 703, 703, 704, 704,
    704, 704, 704, 704, 705, 705, 705, 705, 705, 705, 706, 706, 707, 707, 502, 707, 707,
    707, 708, 500, 708, 708, 709, 709, 709, 710, 496, 710, 710, 711, 711, 711, 712, 712,
    712, 712, 712, 712, 713, 713, 495, 713, 713, 713, 714, 714, 714, 714, 714, 714, 715,
    715, 715, 715, 715, 715, 716, 716, 716, 716, 716, 716, 717, 717, 717, 717, 717, 717,
    718, 718, 718, 718, 718, 718, 719, 719, 719, 719, 719, 719, 720, 720, 720,

    720, 720, 720, 721, 721, 721, 721, 721, 721, 722, 722, 722, 722, 722, 722, 723, 723,
    723, 723, 723, 723, 724, 724, 724, 724, 724, 724, 725, 725, 725, 725, 725, 725, 726,
    726, 726, 726, 726, 726, 727, 727, 727, 727, 727, 727, 728, 728, 728, 728, 728, 728,
    729, 729, 729, 729, 729, 729, 730, 730, 730, 730, 730, 730, 731, 731, 731, 731, 731,
    731, 732, 732, 732, 732, 732, 732, 733, 733, 733, 733, 733, 733, 734, 734, 734, 734,
    734, 734, 735, 735, 735, 735, 735, 735, 736, 736, 736, 736, 736, 736, 737,

    737, 737, 737, 737, 737, 738, 738, 738, 738, 738, 738, 739, 739, 739, 739, 739, 739,
    740, 740, 740, 740, 740, 740, 741, 741, 741, 741, 741, 741, 742, 742, 742, 742, 742,
    742, 743, 743, 743, 743, 743, 743, 744, 744, 744, 744, 744, 744, 745, 745, 745, 745,
    745, 745, 746, 746, 746, 746, 746, 746, 747, 747, 747, 747, 747, 747, 748, 748, 748,
    748, 748, 748, 749, 749, 749, 749, 749, 749, 750, 750, 750, 750, 750, 750, 751, 751,
    751, 751, 751, 751, 494, 493, 490, 489, 487, 486, 485, 483, 482, 479, 457,

    454, 453, 452, 450, 447, 446, 445, 444, 442, 441, 440, 439, 438, 437, 435, 434, 398,
    392, 389, 388, 385, 384, 377, 373, 372, 371, 370, 369, 368, 367, 366, 364, 363, 362,
    361, 319, 315, 314, 303, 302, 301, 300, 298, 297, 296, 295, 294, 293, 291, 290, 289,
    288, 287, 286, 278, 277, 270, 266, 265, 258, 254, 253, 246, 244, 243, 229, 226, 225,
    218, 217, 210, 197, 196, 189, 167, 165, 156, 155, 154, 153, 150, 143, 138, 136, 133,
    129, 127, 124, 120, 118, 115, 111, 107, 105, 101, 99,  96,  69,  67,  65,

    62,  60,  56,  53,  52,  51,  39,  38,  35,  29,  23,  702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
    702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702};

static yyconst flex_int16_t yy_rule_linenum[102] = {
    0,   134, 135, 136, 137, 141, 142, 143, 144, 145, 147, 148, 150, 159, 160, 187, 222,
    246, 252, 273, 280, 291, 296, 310, 315, 322, 346, 353, 355, 368, 381, 406, 412, 417,
    422, 427, 437, 445, 453, 462, 490, 511, 512, 513, 514, 516, 521, 544, 546, 548, 586,
    587, 590, 592, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613,
    614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630,
    631, 632, 633, 634, 635, 636, 642, 648, 660, 662, 664, 680, 681, 691, 694, 695,

    697};

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
/* -*- Mode: c++ -*- */
/*
 * Copyright (c) 2014-2017 National Technology & Engineering Solutions
 * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 * NTESS, the U.S. Government retains certain rights in this software.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of NTESS nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <fcntl.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stack>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "apr_getline_int.h"
#include "apr_scanner.h"
#include "apr_util.h"
#include "aprepro.h"

#define YY_NO_UNISTD_H
/* import the parser's token type into a local typedef */
typedef SEAMS::Parser::token      token;
typedef SEAMS::Parser::token_type token_type;

/* By default yylex returns int, we use token_type. Unfortunately yyterminate
 * by default returns 0, which is not of token_type. */
#define yyterminate() return token::END

#define show(x) *(aprepro->infoStream) << "<" << x << ">" << std::flush;
namespace SEAMS {
  extern bool        echo;
  extern const char *get_temp_filename(void);
  extern char *      pathopen(const char *file);
  extern void        conv_string(const char *string);
  void               yyerror(const char *s);
} // namespace SEAMS

int file_must_exist = 0; /* Global used by include/conditional include */

/* Global variables used by the looping mechanism */
int           loop_lvl = 0;
std::fstream *tmp_file;
const char *  temp_f;

#if defined           __NVCC__
#pragma diag_suppress code_is_unreachable
#endif

#define MAX_IF_NESTING 64

int    if_state[MAX_IF_NESTING]    = {0};     // INITIAL
int    if_case_run[MAX_IF_NESTING] = {false}; /* Has any if or elseif condition executed */
int    if_lvl                      = 0;
int    if_skip_level               = 0;
bool   suppress_nl                 = false;
bool   switch_active               = false; // Are we in a switch
bool   switch_case_run             = false; // has there been a case which matched condition run?
bool   switch_skip_to_endcase      = false;
double switch_condition            = 0.0; // Value specified in "switch(condition)"

// For substitution history
size_t      curr_index = 0;
std::string history_string;
size_t      hist_start = 0;

#define YY_USER_ACTION curr_index += yyleng;

/*** Flex Declarations and Options ***/
/* enable c++ scanner class generation */
/* change the name of the scanner class. results in "SEAMSFlexLexer" */
/* enable scanner to generate debug output. disable this for release
 * versions. */
/* enables the use of start condition stacks */

#define INITIAL 0
#define PARSING 1
#define GET_FILENAME 2
#define IF_SKIP 3
#define GET_VAR 4
#define VERBATIM 5
#define IF_WHILE_SKIP 6
#define GET_LOOP_VAR 7
#define LOOP 8
#define LOOP_SKIP 9
#define END_CASE_SKIP 10

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
#include <unistd.h>
/* %endif */
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

/* %if-c-only Reentrant structure and macros (non-C++). */
/* %if-reentrant */
/* %if-c-only */
/* %endif */
/* %if-reentrant */
/* %endif */
/* %endif End reentrant structures and macros. */
/* %if-bison-bridge */
/* %endif */
/* %not-for-header */

/* %ok-for-header */

/* %endif */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *, yyconst char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(yyconst char *);
#endif

#ifndef YY_NO_INPUT
/* %if-c-only Standard (non-C++) definition */
/* %not-for-header */

/* %ok-for-header */

/* %endif */
#endif

/* %if-c-only */
/* %endif */

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* %if-c-only Standard (non-C++) definition */
/* %endif */
/* %if-c++-only C++ definition */
#define ECHO LexerOutput(yytext, yyleng)
/* %endif */
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                            \
  /* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ */          \
                                                                                                   \
  /* %if-c++-only C++ definition \ */                                                              \
  if ((result = LexerInput((char *)buf, max_size)) < 0)                                            \
    YY_FATAL_ERROR("input in flex scanner failed");
/* %endif */

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
/* %if-c-only */
/* %endif */
/* %if-c++-only */
#define YY_FATAL_ERROR(msg) LexerError(msg)
/* %endif */
#endif

/* %if-tables-serialization structures and prototypes */
/* %not-for-header */

/* %ok-for-header */

/* %not-for-header */

/* %tables-yydmap generated elements */
/* %endif */
/* end tables serialization structures and prototypes */

/* %ok-for-header */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1
/* %if-c-only Standard (non-C++) definition */
/* %endif */
/* %if-c++-only C++ definition */
#define YY_DECL int yyFlexLexer::yylex()
/* %endif */
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

/* %% [6.0] YY_RULE_SETUP definition goes here */
#define YY_RULE_SETUP YY_USER_ACTION

/* %not-for-header */

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *        yy_cp, *yy_bp;
  int           yy_act;

  /* %% [7.0] user's declarations go here */

  if (!(yy_init)) {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start))
      (yy_start) = 1; /* first start state */

    if (!yyin)
      /* %if-c-only */
      /* %endif */
      /* %if-c++-only */
      yyin = &std::cin;
    /* %endif */

    if (!yyout)
      /* %if-c-only */
      /* %endif */
      /* %if-c++-only */
      yyout = &std::cout;
    /* %endif */

    if (!YY_CURRENT_BUFFER) {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  while (1) /* loops until end-of-file is reached */
  {
    /* %% [8.0] yymore()-related code goes here */
    yy_cp = (yy_c_buf_p);

    /* Support of yytext. */
    *yy_cp = (yy_hold_char);

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    /* %% [9.0] code to set up and find next match goes here */
    yy_current_state = (yy_start);
  yy_match:
    do {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if (yy_accept[yy_current_state]) {
        (yy_last_accepting_state) = yy_current_state;
        (yy_last_accepting_cpos)  = yy_cp;
      }
      while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
        yy_current_state = (int)yy_def[yy_current_state];
        if (yy_current_state >= 703)
          yy_c = yy_meta[(unsigned int)yy_c];
      }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
      ++yy_cp;
    } while (yy_base[yy_current_state] != 2512);

  yy_find_action:
    /* %% [10.0] code to find the action number goes here */
    yy_act = yy_accept[yy_current_state];
    if (yy_act == 0) { /* have to back up */
      yy_cp            = (yy_last_accepting_cpos);
      yy_current_state = (yy_last_accepting_state);
      yy_act           = yy_accept[yy_current_state];
    }

    YY_DO_BEFORE_ACTION;

    /* %% [11.0] code for yylineno update goes here */

  do_action: /* This label is used only to access EOF actions. */

    /* %% [12.0] debug code goes here */
    if (yy_flex_debug) {
      if (yy_act == 0)
        std::cerr << "--scanner backing up\n";
      else if (yy_act < 102)
        std::cerr << "--accepting rule at line " << yy_rule_linenum[yy_act] << "(\"" << yytext
                  << "\")\n";
      else if (yy_act == 102)
        std::cerr << "--accepting default rule (\"" << yytext << "\")\n";
      else if (yy_act == 103)
        std::cerr << "--(end of buffer or a NUL)\n";
      else
        std::cerr << "--EOF (start condition " << YY_START << ")\n";
    }

    switch (yy_act) { /* beginning of action switch */
                      /* %% [13.0] actions go here */
    case 0:           /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp           = (yy_hold_char);
      yy_cp            = (yy_last_accepting_cpos);
      yy_current_state = (yy_last_accepting_state);
      goto yy_find_action;

    case 1:
      YY_RULE_SETUP { BEGIN(INITIAL); }
      YY_BREAK
    case 2:
    case 3:
      YY_RULE_SETUP
      {
        if (echo)
          ECHO;
      }
      YY_BREAK
    case 4:
      /* rule 4 can match eol */
      YY_RULE_SETUP
      {
        if (echo)
          ECHO;
        aprepro.ap_file_list.top().lineno++;
      }
      YY_BREAK

    case 5:
      YY_RULE_SETUP { BEGIN(VERBATIM); }
      YY_BREAK
    case 6:
    case 7:
      YY_RULE_SETUP { echo = true; }
      YY_BREAK
    case 8:
    case 9:
      YY_RULE_SETUP { echo = false; }
      YY_BREAK
    case 10:
      YY_RULE_SETUP { aprepro.stateImmutable = true; }
      YY_BREAK
    case 11:
      YY_RULE_SETUP { aprepro.stateImmutable = aprepro.ap_options.immutable; }
      YY_BREAK
    case 12:
      YY_RULE_SETUP
      {
        BEGIN(GET_LOOP_VAR);
        if (aprepro.ap_options.debugging)
          std::cerr << "DEBUG LOOP - Found loop begin test " << yytext << " in file "
                    << aprepro.ap_file_list.top().name << "\n";
      }
      YY_BREAK

    case 13:
    /* rule 13 can match eol */
    case 14:
      /* rule 14 can match eol */
      YY_RULE_SETUP
      {
        /* Loop control defined by integer */
        char *pt = strchr(yytext, ')');
        *pt      = '\0';
        sscanf(yytext, "%lf", &yylval->val);

        if (yylval->val <= 0) {
          BEGIN(LOOP_SKIP);
        }
        else { /* Value defined and != 0. */
          temp_f = get_temp_filename();
          SEAMS::file_rec new_file(temp_f, 0, true, (int)yylval->val);
          aprepro.ap_file_list.push(new_file);

          if (aprepro.ap_options.debugging)
            std::cerr << "DEBUG LOOP VAR = " << aprepro.ap_file_list.top().loop_count << " in file "
                      << aprepro.ap_file_list.top().name << " at line "
                      << aprepro.ap_file_list.top().lineno << "\n";

          tmp_file = new std::fstream(temp_f, std::ios::out);
          loop_lvl++;
          BEGIN(LOOP);
        }
        aprepro.ap_file_list.top().lineno++;
        aprepro.isCollectingLoop = true;
      }
      YY_BREAK
    case 15:
      /* rule 15 can match eol */
      YY_RULE_SETUP
      {
        /* Loop control defined by variable */
        symrec *s;
        char *  pt = strchr(yytext, ')');
        *pt        = '\0';
        if (!check_valid_var(yytext)) {
          aprepro.warning("Invalid variable name syntax '" + std::string(yytext) + "'");
          BEGIN(LOOP_SKIP);
        }
        else {
          s = aprepro.getsym(yytext);

          if (s == nullptr ||
              (s->type != token::SVAR && s->type != token::IMMSVAR && s->value.var == 0.)) {
            BEGIN(LOOP_SKIP);
          }
          else { /* Value defined and != 0. */
            temp_f = get_temp_filename();
            SEAMS::file_rec new_file(temp_f, 0, true, (int)s->value.var);
            aprepro.ap_file_list.push(new_file);

            if (aprepro.ap_options.debugging)
              std::cerr << "DEBUG LOOP VAR = " << aprepro.ap_file_list.top().loop_count
                        << " in file " << aprepro.ap_file_list.top().name << " at line "
                        << aprepro.ap_file_list.top().lineno << "\n";

            tmp_file = new std::fstream(temp_f, std::ios::out);
            loop_lvl++;
            BEGIN(LOOP);
          }
        }
        aprepro.ap_file_list.top().lineno++;
        aprepro.isCollectingLoop = true;
      }
      YY_BREAK

    case 16:
      /* rule 16 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if (loop_lvl > 0)
          --loop_lvl;

        if (loop_lvl == 0) {
          BEGIN(INITIAL);
          tmp_file->close();
          delete tmp_file;

          if (!aprepro.doLoopSubstitution)
            yy_push_state(VERBATIM);

          aprepro.isCollectingLoop = false;

          yyin = aprepro.open_file(aprepro.ap_file_list.top().name, "r");
          yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(yyin, YY_BUF_SIZE));
          curr_index = 0;
        }
        else {
          (*tmp_file) << yytext;
        }
      }
      YY_BREAK
    case 17:
      /* rule 17 can match eol */
      YY_RULE_SETUP
      {
        loop_lvl++; /* Nested Loop */
        (*tmp_file) << yytext;
        aprepro.ap_file_list.top().lineno++;
      }
      YY_BREAK
    case 18:
      /* rule 18 can match eol */
      YY_RULE_SETUP
      {
        if (aprepro.ap_options.interactive || aprepro.string_interactive()) {
          aprepro.warning("Aborting loop(s).", false);

          // Leave the looping state and remove the loop file
          BEGIN(INITIAL);
          tmp_file->close();
          delete tmp_file;

          if (aprepro.ap_file_list.top().tmp_file) {
            remove(aprepro.ap_file_list.top().name.c_str());
            aprepro.ap_file_list.pop();
          }

          loop_lvl                 = 0;
          aprepro.isCollectingLoop = false;
        }
      }
      YY_BREAK
    case 19:
      /* rule 19 can match eol */
      YY_RULE_SETUP
      {
        (*tmp_file) << yytext;
        aprepro.ap_file_list.top().lineno++;
      }
      YY_BREAK

    case 20:
      /* rule 20 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if (loop_lvl > 0)
          --loop_lvl;

        if (loop_lvl == 0) {
          BEGIN(INITIAL);
          aprepro.isCollectingLoop = false;
        }
      }
      YY_BREAK
    case 21:
      /* rule 21 can match eol */
      YY_RULE_SETUP
      {
        loop_lvl++; /* Nested Loop */
        aprepro.ap_file_list.top().lineno++;
      }
      YY_BREAK
    case 22:
      /* rule 22 can match eol */
      YY_RULE_SETUP
      {
        if (aprepro.ap_options.interactive || aprepro.string_interactive()) {
          aprepro.warning("Aborting loops(s).", false);

          // Leave the looping state
          BEGIN(INITIAL);

          loop_lvl                 = 0;
          aprepro.isCollectingLoop = false;
        }
      }
      YY_BREAK
    case 23:
      /* rule 23 can match eol */
      YY_RULE_SETUP { aprepro.ap_file_list.top().lineno++; }
      YY_BREAK

    case 24:
      /* rule 24 can match eol */
      YY_RULE_SETUP
      {
        yyless(0);
        curr_index = 0;
        BEGIN(INITIAL);
        switch_skip_to_endcase = false;
      }
      YY_BREAK
    case 25:
      /* rule 25 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if (!switch_active) {
          yyerror("default statement found outside switch statement.");
        }

        if (!switch_case_run) {
          switch_case_run = true;
          BEGIN(INITIAL);
          switch_skip_to_endcase = false;
          if (aprepro.ap_options.debugging)
            fprintf(stderr, "DEBUG SWITCH: 'default' code executing at line %d\n",
                    aprepro.ap_file_list.top().lineno);
        }
        else {
          if (aprepro.ap_options.debugging)
            fprintf(stderr,
                    "DEBUG SWITCH: 'default' not executing since a previous case already ran at "
                    "line %d\n",
                    aprepro.ap_file_list.top().lineno);

          /* Need to skip all code until end of case */
          BEGIN(END_CASE_SKIP);
        }
      }
      YY_BREAK
    case 26:
      /* rule 26 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        BEGIN(INITIAL);
        switch_active          = false;
        switch_skip_to_endcase = false;
      }
      YY_BREAK
    case 27:
      /* rule 27 can match eol */
      YY_RULE_SETUP { aprepro.ap_file_list.top().lineno++; }
      YY_BREAK
    case 28:
      /* rule 28 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if (!switch_active) {
          yyerror("endswitch statement found without matching switch.");
        }
        switch_active = false;
      }
      YY_BREAK

    /* This restores the old behavior of ifdef and ifndef
     * where they would eat up any leading whitespace on
     * a line.
     */
    case 29:
      YY_RULE_SETUP
      {
        // Used to avoid undefined variable warnings in old ifdef/ifndef construct
        aprepro.inIfdefGetvar = true;
        unput('(');
        unput('f');
        unput('e');
        unput('d');
        unput('f');
        unput('i');
        unput('_');
        unput('{');
      }
      YY_BREAK
    case 30:
      YY_RULE_SETUP
      {
        // Used to avoid undefined variable warnings in old ifdef/ifndef construct
        aprepro.inIfdefGetvar = true;
        unput('(');
        unput('f');
        unput('e');
        unput('d');
        unput('n');
        unput('f');
        unput('i');
        unput('_');
        unput('{');
      }
      YY_BREAK

    /* If an if was found while skipping, then eat
     * that entire if block until endif
     * found since there is no way that
     * any of the code in that if block could be executed.
     * Make sure to handle multiple levels of skipped ifs...
     *
     * NOTE: if_lvl was not incremented, so don't need to decrement when
     *       endif found.
     */
    case 31:
      /* rule 31 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if (--if_skip_level == 0)
          BEGIN(IF_SKIP);
      }
      YY_BREAK
    case 32:
      /* rule 32 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if_skip_level++;
      }
      YY_BREAK
    case 33:
      /* rule 33 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if_skip_level++;
      }
      YY_BREAK
    case 34:
      /* rule 34 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if_skip_level++;
      }
      YY_BREAK
    case 35:
      /* rule 35 can match eol */
      YY_RULE_SETUP { aprepro.ap_file_list.top().lineno++; }
      YY_BREAK

    /* IF an if, ifdef, or ifndef found while skipping, then
     * skip the entire block up and including the endif.
     * The (IF_WHILE_SKIP) start condition handles this skipping.
     */
    case 36:
      YY_RULE_SETUP
      {
        if (aprepro.ap_options.debugging)
          fprintf(stderr, "DEBUG IF: 'ifdef'  found while skipping at line %d\n",
                  aprepro.ap_file_list.top().lineno);
        if_skip_level = 1;
        BEGIN(IF_WHILE_SKIP);
      }
      YY_BREAK
    case 37:
      YY_RULE_SETUP
      {
        if (aprepro.ap_options.debugging)
          fprintf(stderr, "DEBUG IF: 'ifdef'  found while skipping at line %d\n",
                  aprepro.ap_file_list.top().lineno);
        if_skip_level = 1;
        BEGIN(IF_WHILE_SKIP);
      }
      YY_BREAK
    case 38:
      YY_RULE_SETUP
      {
        if (aprepro.ap_options.debugging)
          fprintf(stderr, "DEBUG IF: 'ifndef'  found while skipping at line %d\n",
                  aprepro.ap_file_list.top().lineno);
        if_skip_level = 1;
        BEGIN(IF_WHILE_SKIP);
      }
      YY_BREAK

    case 39:
      /* rule 39 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;
        if (aprepro.ap_options.debugging)
          fprintf(stderr, "DEBUG IF: 'else'   at level = %d at line %d\n", if_lvl,
                  aprepro.ap_file_list.top().lineno);
        if (YY_START == VERBATIM) {
          if (echo)
            ECHO;
        }
        else if (if_state[if_lvl] == IF_SKIP) {
          if (!if_case_run[if_lvl]) {
            BEGIN(INITIAL);
            if_state[if_lvl]    = INITIAL;
            if_case_run[if_lvl] = true;
          }
          else {
            BEGIN(IF_SKIP);
            if_state[if_lvl] = IF_SKIP;
          }
        }
        else if (if_state[if_lvl] == INITIAL) {
          BEGIN(IF_SKIP);
          if_state[if_lvl] = IF_SKIP;
        }

        /* If neither is true, this is a nested
           if that should be skipped */
      }
      YY_BREAK

    case 40:
      /* rule 40 can match eol */
      YY_RULE_SETUP
      {
        /* If any previous 'block' of this if has executed, then
         * just skip this block; otherwise see if condition is
         * true and execute this block
         */
        if (aprepro.ap_options.debugging)
          fprintf(stderr, "DEBUG IF: 'elseif'   at level = %d at line %d\n", if_lvl,
                  aprepro.ap_file_list.top().lineno);

        if (if_case_run[if_lvl]) { /* A previous else/elseif has run */
          aprepro.ap_file_list.top().lineno++;
          /* Already in IF_SKIP, so don't need to change state */
        }
        else {
          /* Need to check the elseif condition; push back and parse */
          yyless(0);
          curr_index = 0;
          BEGIN(INITIAL);
          if_state[if_lvl] = INITIAL;
        }
      }
      YY_BREAK
    case 41:
    case 42:
    case 43:
    case 44:
      YY_RULE_SETUP { ; }
      YY_BREAK
    case 45:
      /* rule 45 can match eol */
      YY_RULE_SETUP { aprepro.ap_file_list.top().lineno++; }
      YY_BREAK

    case 46:
      /* rule 46 can match eol */
      YY_RULE_SETUP
      {
        aprepro.ap_file_list.top().lineno++;

        if (YY_START == VERBATIM) {
          if (echo)
            ECHO;
        }
        else {
          if (if_state[if_lvl] == IF_SKIP || if_state[if_lvl] == INITIAL)
            BEGIN(INITIAL);
          /* If neither is true, this is a nested
             if that should be skipped */
          if (aprepro.ap_options.debugging)
            printf("DEBUG IF: 'endif'  at level = %d at line %d\n", if_lvl,
                   aprepro.ap_file_list.top().lineno);
          if (--if_lvl < 0) {
            if_lvl = 0;
            yyerror("Improperly Nested ifdef/ifndef statements");
          }
          /* Ignore endif if not skipping */
        }
      }
      YY_BREAK
    case 47:
      YY_RULE_SETUP
      {
        BEGIN(GET_FILENAME);
        file_must_exist = true;
      }
      YY_BREAK
    case 48:
      YY_RULE_SETUP
      {
        BEGIN(GET_FILENAME);
        file_must_exist = !true;
      }
      YY_BREAK
    case 49:
      /* rule 49 can match eol */
      YY_RULE_SETUP
      {
        BEGIN(INITIAL);
        {
          symrec *s;
          int     quoted = false;
          char *  pt     = strchr(yytext, ')');
          *pt            = '\0';
          /* Check to see if surrounded by double quote */
          if ((pt = strchr(yytext, '"')) != nullptr) {
            yytext++;
            quoted = true;
          }
          if ((pt = strrchr(yytext, '"')) != nullptr) {
            *pt    = '\0';
            quoted = true;
          }

          if (quoted == false) {
            /* See if this is an aprepro variable referring to a name */
            s = aprepro.getsym(yytext);
            if (s == nullptr || (s->type != token::SVAR && s->type != token::IMMSVAR)) {
              pt = yytext;
            }
            else {
              pt = (char *)s->value.svar.c_str();
            }
          }
          else {
            pt = yytext;
          }

          add_include_file(pt, file_must_exist);

          if (!aprepro.doIncludeSubstitution)
            yy_push_state(VERBATIM);

          aprepro.ap_file_list.top().lineno++;
        }
      }
      YY_BREAK
    case 50:
    case 51:
      YY_RULE_SETUP
      {
        sscanf(yytext, "%lf", &yylval->val);
        return (token::NUM);
      }
      YY_BREAK
    case 52:
      YY_RULE_SETUP; // Empty rule
      YY_BREAK
    case 53:
      YY_RULE_SETUP
      {
        symrec *s;
        s = aprepro.getsym(yytext);
        if (s == nullptr)
          s = aprepro.putsym(yytext, SEAMS::Aprepro::SYMBOL_TYPE::UNDEFINED_VARIABLE, 0);
        yylval->tptr = s;
        return ((token::yytokentype)s->type);
      }
      YY_BREAK
    case 54:
      YY_RULE_SETUP
      return (token::EQUAL);
      YY_BREAK
    case 55:
      YY_RULE_SETUP
      return (token::EQ_PLUS);
      YY_BREAK
    case 56:
      YY_RULE_SETUP
      return (token::EQ_MINUS);
      YY_BREAK
    case 57:
      YY_RULE_SETUP
      return (token::EQ_TIME);
      YY_BREAK
    case 58:
      YY_RULE_SETUP
      return (token::EQ_DIV);
      YY_BREAK
    case 59:
      YY_RULE_SETUP
      return (token::EQ_POW);
      YY_BREAK
    case 60:
      YY_RULE_SETUP
      return (token::EQ_POW);
      YY_BREAK
    case 61:
      YY_RULE_SETUP
      return (token::INC);
      YY_BREAK
    case 62:
      YY_RULE_SETUP
      return (token::DEC);
      YY_BREAK
    case 63:
      YY_RULE_SETUP
      return (token::PLU);
      YY_BREAK
    case 64:
      YY_RULE_SETUP
      return (token::SUB);
      YY_BREAK
    case 65:
      YY_RULE_SETUP
      return (token::TIM);
      YY_BREAK
    case 66:
      YY_RULE_SETUP
      return (token::TIM); /* ~ is same as multiply */
      YY_BREAK
    case 67:
      YY_RULE_SETUP
      return (token::CONCAT); /* String concatenation */
      YY_BREAK
    case 68:
      YY_RULE_SETUP
      return (token::DIV);
      YY_BREAK
    case 69:
      YY_RULE_SETUP
      return (token::MOD);
      YY_BREAK
    case 70:
      YY_RULE_SETUP
      return (token::POW);
      YY_BREAK
    case 71:
      YY_RULE_SETUP
      return (token::POW);
      YY_BREAK
    case 72:
      /* rule 72 can match eol */
      YY_RULE_SETUP
      aprepro.ap_file_list.top().lineno++;
      YY_BREAK
    case 73:
      YY_RULE_SETUP
      return (token::LPAR);
      YY_BREAK
    case 74:
      YY_RULE_SETUP
      return (token::RPAR);
      YY_BREAK
    case 75:
      YY_RULE_SETUP
      return (token::COMMA);
      YY_BREAK
    case 76:
      YY_RULE_SETUP
      return (token::SEMI);
      YY_BREAK
    case 77:
      YY_RULE_SETUP
      return (token::COLON);
      YY_BREAK
    case 78:
      YY_RULE_SETUP
      return (token::QUEST);
      YY_BREAK
    case 79:
      YY_RULE_SETUP
      return (token::LT);
      YY_BREAK
    case 80:
      YY_RULE_SETUP
      return (token::GT);
      YY_BREAK
    case 81:
      YY_RULE_SETUP
      return (token::LE);
      YY_BREAK
    case 82:
      YY_RULE_SETUP
      return (token::GE);
      YY_BREAK
    case 83:
      YY_RULE_SETUP
      return (token::EQ);
      YY_BREAK
    case 84:
      YY_RULE_SETUP
      return (token::NE);
      YY_BREAK
    case 85:
      YY_RULE_SETUP
      return (token::LAND);
      YY_BREAK
    case 86:
      YY_RULE_SETUP
      return (token::LOR);
      YY_BREAK
    case 87:
      YY_RULE_SETUP
      return (token::NOT);
      YY_BREAK
    case 88:
      YY_RULE_SETUP
      return (token::LBRACK);
      YY_BREAK
    case 89:
      YY_RULE_SETUP
      return (token::RBRACK);
      YY_BREAK
    case 90:
      /* rule 90 can match eol */
      YY_RULE_SETUP
      {
        char *pt = strrchr(yytext, '"');
        *pt      = '\0';
        new_string(yytext + 1, &yylval->string);
        return token::QSTRING;
      }
      YY_BREAK
    case 91:
      /* rule 91 can match eol */
      YY_RULE_SETUP
      {
        char *pt = strrchr(yytext, '\'');
        *pt      = '\0';
        new_string(yytext + 1, &yylval->string);
        return token::QSTRING;
      }
      YY_BREAK
    case 92:
      YY_RULE_SETUP
      {
        // Add to the history string
        save_history_string();

        if (switch_skip_to_endcase)
          BEGIN(END_CASE_SKIP);
        else
          BEGIN(if_state[if_lvl]);
        return (token::RBRACE);
      }
      YY_BREAK
    case 93:
      YY_RULE_SETUP
      {
        if (echo)
          LexerOutput("{", 1);
      }
      YY_BREAK
    case 94:
      YY_RULE_SETUP
      {
        if (echo)
          LexerOutput("}", 1);
      }
      YY_BREAK
    case 95:
      YY_RULE_SETUP
      {
        // Check if we need to save the substitution history first.
        if (aprepro.ap_options.keep_history && (aprepro.ap_file_list.top().name != "_string_")) {
          if (curr_index > (size_t)yyleng)
            hist_start = curr_index - yyleng;
          else
            hist_start = 0;
        }

        BEGIN(PARSING);

        return (token::LBRACE);
      }
      YY_BREAK
    case 96:
    case 97:
      YY_RULE_SETUP
      {
        if (aprepro.ap_options.end_on_exit) {
          if (echo)
            ECHO;
          return ((token::yytokentype)-1);
        }
        else if (echo)
          ECHO;
      }
      YY_BREAK
    case 98:
      YY_RULE_SETUP
      {
        if (echo)
          ECHO;
      }
      YY_BREAK
    case 99:
    case 100:
      YY_RULE_SETUP
      {
        if (echo && if_state[if_lvl] != IF_SKIP)
          ECHO;
      }
      YY_BREAK
    case 101:
      /* rule 101 can match eol */
      YY_RULE_SETUP
      {
        if (echo && !suppress_nl)
          ECHO;
        suppress_nl = false;
        aprepro.ap_file_list.top().lineno++;
      }
      YY_BREAK
    case 102:
      YY_RULE_SETUP
      ECHO;
      YY_BREAK
    case YY_STATE_EOF(INITIAL):
    case YY_STATE_EOF(PARSING):
    case YY_STATE_EOF(GET_FILENAME):
    case YY_STATE_EOF(IF_SKIP):
    case YY_STATE_EOF(GET_VAR):
    case YY_STATE_EOF(VERBATIM):
    case YY_STATE_EOF(IF_WHILE_SKIP):
    case YY_STATE_EOF(GET_LOOP_VAR):
    case YY_STATE_EOF(LOOP):
    case YY_STATE_EOF(LOOP_SKIP):
    case YY_STATE_EOF(END_CASE_SKIP): yyterminate();

    case YY_END_OF_BUFFER: {
      /* Amount of text matched not including the EOB char. */
      int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

      /* Undo the effects of YY_DO_BEFORE_ACTION. */
      *yy_cp = (yy_hold_char);
      YY_RESTORE_YY_MORE_OFFSET

      if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW) {
        /* We're scanning a new file or input source.  It's
         * possible that this happened because the user
         * just pointed yyin at a new source and called
         * yylex().  If so, then we have to assure
         * consistency between YY_CURRENT_BUFFER and our
         * globals.  Here is the right place to do so, because
         * this is the first action (other than possibly a
         * back-up) that will match for the new input source.
         */
        (yy_n_chars)                               = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
        YY_CURRENT_BUFFER_LVALUE->yy_input_file    = yyin;
        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

      /* Note that here we test for yy_c_buf_p "<=" to the position
       * of the first EOB in the buffer, since yy_c_buf_p will
       * already have been incremented past the NUL character
       * (since all states make transitions on EOB to the
       * end-of-buffer state).  Contrast this with the test
       * in input().
       */
      if ((yy_c_buf_p) <=
          &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)]) { /* This was really a NUL. */
        yy_state_type yy_next_state;

        (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state();

        /* Okay, we're now positioned to make the NUL
         * transition.  We couldn't have
         * yy_get_previous_state() go ahead and do it
         * for us because it doesn't know how to deal
         * with the possibility of jamming (and we don't
         * want to build jamming into it because then it
         * will run more slowly).
         */

        yy_next_state = yy_try_NUL_trans(yy_current_state);

        yy_bp = (yytext_ptr) + YY_MORE_ADJ;

        if (yy_next_state) {
          /* Consume the NUL. */
          yy_cp            = ++(yy_c_buf_p);
          yy_current_state = yy_next_state;
          goto yy_match;
        }

        else {
          /* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
          yy_cp = (yy_c_buf_p);
          goto yy_find_action;
        }
      }

      else
        switch (yy_get_next_buffer()) {
        case EOB_ACT_END_OF_FILE: {
          (yy_did_buffer_switch_on_eof) = 0;

          if (yywrap()) {
            /* Note: because we've taken care in
             * yy_get_next_buffer() to have set up
             * yytext, we can now set up
             * yy_c_buf_p so that if some total
             * hoser (like flex itself) wants to
             * call the scanner after we return the
             * YY_NULL, it'll still work - another
             * YY_NULL will get returned.
             */
            (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

            yy_act = YY_STATE_EOF(YY_START);
            goto do_action;
          }

          else {
            if (!(yy_did_buffer_switch_on_eof))
              YY_NEW_FILE;
          }
          break;
        }

        case EOB_ACT_CONTINUE_SCAN:
          (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

          yy_current_state = yy_get_previous_state();

          yy_cp = (yy_c_buf_p);
          yy_bp = (yytext_ptr) + YY_MORE_ADJ;
          goto yy_match;

        case EOB_ACT_LAST_MATCH:
          (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

          yy_current_state = yy_get_previous_state();

          yy_cp = (yy_c_buf_p);
          yy_bp = (yytext_ptr) + YY_MORE_ADJ;
          goto yy_find_action;
        }
      break;
    }

    default: YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
    } /* end of action switch */
  }   /* end of scanning one token */
} /* end of yylex */
/* %ok-for-header */

/* %if-c++-only */
/* %not-for-header */

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::yyFlexLexer(std::istream *arg_yyin, std::ostream *arg_yyout)
{
  yyin          = arg_yyin;
  yyout         = arg_yyout;
  yy_c_buf_p    = 0;
  yy_init       = 0;
  yy_start      = 0;
  yy_flex_debug = 0;
  yylineno      = 1; // this will only get updated if %option yylineno

  yy_did_buffer_switch_on_eof = 0;

  yy_looking_for_trail_begin = 0;
  yy_more_flag               = 0;
  yy_more_len                = 0;
  yy_more_offset = yy_prev_more_offset = 0;

  yy_start_stack_ptr = yy_start_stack_depth = 0;
  yy_start_stack                            = NULL;

  yy_buffer_stack     = 0;
  yy_buffer_stack_top = 0;
  yy_buffer_stack_max = 0;

  yy_state_buf = 0;
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::~yyFlexLexer()
{
  delete[] yy_state_buf;
  SEAMSfree(yy_start_stack);
  yy_delete_buffer(YY_CURRENT_BUFFER);
  SEAMSfree(yy_buffer_stack);
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams(std::istream *new_in, std::ostream *new_out)
{
  if (new_in) {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    yy_switch_to_buffer(yy_create_buffer(new_in, YY_BUF_SIZE));
  }

  if (new_out)
    yyout = new_out;
}

#ifdef YY_INTERACTIVE
int yyFlexLexer::LexerInput(char *buf, int /* max_size */)
#else
int yyFlexLexer::LexerInput(char *buf, int max_size)
#endif
{
  if (yyin->eof() || yyin->fail())
    return 0;

#ifdef YY_INTERACTIVE
  yyin->get(buf[0]);

  if (yyin->eof())
    return 0;

  if (yyin->bad())
    return -1;

  return 1;

#else
  (void)yyin->read(buf, max_size);

  if (yyin->bad())
    return -1;
  else
    return yyin->gcount();
#endif
}

void yyFlexLexer::LexerOutput(const char *buf, int size) { (void)yyout->write(buf, size); }
/* %ok-for-header */

/* %endif */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
int yyFlexLexer::yy_get_next_buffer()
/* %endif */
{
  char *dest   = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = (yytext_ptr);
  int   number_to_move, i;
  int   ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer ==
      0) { /* Don't try to fill the buffer, so this is an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1) {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)) - 1;

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else {
    yy_size_t num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0) { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer) {
        yy_size_t new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
            /* Include room in for 2 EOB chars. */
            SEAMSrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2);
      }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if (!b->yy_ch_buf)
        YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE)
      num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0) {
    if (number_to_move == YY_MORE_ADJ) {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else {
      ret_val                                    = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if ((yy_size_t)((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
    /* Extend the array by 50%, plus the number we really need. */
    yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
        (char *)SEAMSrealloc((void *)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)]     = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

/* %if-c-only */
/* %not-for-header */

/* %endif */
/* %if-c++-only */
yy_state_type yyFlexLexer::yy_get_previous_state()
/* %endif */
{
  yy_state_type yy_current_state;
  char *        yy_cp;

  /* %% [15.0] code to get the start state into yy_current_state goes here */
  yy_current_state = (yy_start);

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp) {
    /* %% [16.0] code to find the next state goes here */
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state]) {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos)  = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 703)
        yy_c = yy_meta[(unsigned int)yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
yy_state_type yyFlexLexer::yy_try_NUL_trans(yy_state_type yy_current_state)
/* %endif */
{
  int yy_is_jam;
  /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
  char *yy_cp = (yy_c_buf_p);

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state]) {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos)  = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 703)
      yy_c = yy_meta[(unsigned int)yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
  yy_is_jam        = (yy_current_state == 702);

  return yy_is_jam ? 0 : yy_current_state;
}

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yyunput(int c, char *yy_bp)
/* %endif */
{
  char *yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2) { /* need to shift things up to make room */
                                                         /* +2 for EOB chars. */
    yy_size_t number_to_move = (yy_n_chars) + 2;
    char *dest   = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    char *source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  /* %% [18.0] update yylineno here */

  (yytext_ptr)   = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p)   = yy_cp;
}
/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */
/* %if-c++-only */
int yyFlexLexer::yyinput()
/* %endif */
{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else { /* need more input */
      yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer()) {
      case EOB_ACT_LAST_MATCH:
        /* This happens because yy_g_n_b()
         * sees that we've accumulated a
         * token and flags that we need to
         * try matching the token before
         * proceeding.  But for input(),
         * there's no matching to consider.
         * So convert the EOB_ACT_LAST_MATCH
         * to EOB_ACT_END_OF_FILE.
         */

        /* Reset buffer status. */
        yyrestart(yyin);

        /*FALLTHROUGH*/

      case EOB_ACT_END_OF_FILE: {
        if (yywrap())
          return EOF;

        if (!(yy_did_buffer_switch_on_eof))
          YY_NEW_FILE;
#ifdef __cplusplus
        return yyinput();
#else
        return input();
#endif
      }

      case EOB_ACT_CONTINUE_SCAN: (yy_c_buf_p) = (yytext_ptr) + offset; break;
      }
    }
  }

  c              = *(unsigned char *)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p)  = '\0';                           /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  /* %% [19.0] update BOL and yylineno */

  return c;
}
/* %if-c-only */
/* %endif */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yyrestart(std::istream *input_file)
/* %endif */
{

  if (!YY_CURRENT_BUFFER) {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
/* %endif */
{

  /* TODO. We should be able to replace this entire function body
   * with
   *		yypop_buffer_state();
   *		yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p)                        = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_load_buffer_state()
/* %endif */
{
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin                        = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char)              = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
YY_BUFFER_STATE yyFlexLexer::yy_create_buffer(std::istream *file, int size)
/* %endif */
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)SEAMSalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *)SEAMSalloc(b->yy_buf_size + 2);
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_delete_buffer(YY_BUFFER_STATE b)
/* %endif */
{

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    SEAMSfree((void *)b->yy_ch_buf);

  SEAMSfree((void *)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_init_buffer(YY_BUFFER_STATE b, std::istream *file)
/* %endif */

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file  = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER) {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  /* %if-c-only */
  /* %endif */
  /* %if-c++-only */
  b->yy_is_interactive = 0;
  /* %endif */
  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_flush_buffer(YY_BUFFER_STATE b)
/* %endif */
{
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol        = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state();
}

/* %if-c-or-c++ */
/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yypush_buffer_state(YY_BUFFER_STATE new_buffer)
/* %endif */
{
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p)                        = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}
/* %endif */

/* %if-c-or-c++ */
/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yypop_buffer_state(void)
/* %endif */
{
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER) {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}
/* %endif */

/* %if-c-or-c++ */
/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yyensure_buffer_stack(void)
/* %endif */
{
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack)) {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1;
    (yy_buffer_stack) =
        (struct yy_buffer_state **)SEAMSalloc(num_to_alloc * sizeof(struct yy_buffer_state *));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state *));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {

    /* Increase the buffer to prepare for a possible push. */
    int grow_size = 8 /* arbitrary grow size */;

    num_to_alloc      = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state **)SEAMSrealloc(
        (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state *));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset((yy_buffer_stack) + (yy_buffer_stack_max), 0,
           grow_size * sizeof(struct yy_buffer_state *));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}
/* %endif */

/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_push_state(int new_state)
/* %endif */
{
  if ((yy_start_stack_ptr) >= (yy_start_stack_depth)) {
    yy_size_t new_size;

    (yy_start_stack_depth) += YY_START_STACK_INCR;
    new_size = (yy_start_stack_depth) * sizeof(int);

    if (!(yy_start_stack))
      (yy_start_stack) = (int *)SEAMSalloc(new_size);

    else
      (yy_start_stack) = (int *)SEAMSrealloc((void *)(yy_start_stack), new_size);

    if (!(yy_start_stack))
      YY_FATAL_ERROR("out of memory expanding start-condition stack");
  }

  (yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;

  BEGIN(new_state);
}

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_pop_state()
/* %endif */
{
  if (--(yy_start_stack_ptr) < 0)
    YY_FATAL_ERROR("start-condition stack underflow");

  BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
}

/* %if-c-only */
/* %endif */
/* %if-c++-only */
int yyFlexLexer::yy_top_state()
/* %endif */ { return (yy_start_stack)[(yy_start_stack_ptr)-1]; }

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::LexerError(yyconst char msg[])
{
  std::cerr << msg << std::endl;
  exit(YY_EXIT_FAILURE);
}
  /* %endif */

  /* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                                                  \
  do {                                                                                             \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    yytext[yyleng] = (yy_hold_char);                                                               \
    (yy_c_buf_p)   = yytext + yyless_macro_arg;                                                    \
    (yy_hold_char) = *(yy_c_buf_p);                                                                \
    *(yy_c_buf_p)  = '\0';                                                                         \
    yyleng         = yyless_macro_arg;                                                             \
  } while (0)

  /* Accessor  methods (get/set functions) to struct members. */

  /* %if-c-only */
  /* %if-reentrant */
  /* %endif */
  /* %if-reentrant */
  /* %endif */
  /* %endif */

  /* %if-reentrant */
  /* %if-bison-bridge */
  /* %endif */
  /* %endif if-c-only */

  /* %if-c-only */
  /* %endif */

  /* %if-c-only SNIP! this currently causes conflicts with the c++ scanner */
  /* %if-reentrant */
  /* %endif */
  /* %endif */

  /*
   * Internal utility routines.
   */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *s1, yyconst char *s2, int n)
{
  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(yyconst char *s)
{
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void *SEAMSalloc(yy_size_t size) { return (void *)malloc(size); }

void *SEAMSrealloc(void *ptr, yy_size_t size)
{
  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return (void *)realloc((char *)ptr, size);
}

void SEAMSfree(void *ptr) { free((char *)ptr); /* see SEAMSrealloc() for (char *) cast */ }

/* %if-tables-serialization definitions */
/* %define-yytables   The name for this specific scanner's tables. */
#define YYTABLES_NAME "yytables"
/* %endif */

/* %ok-for-header */

/* When the scanner receives an end-of-file indication from YY_INPUT, it then
 * checks the yywrap() function. If yywrap() returns false (zero), then it is
 * assumed that the function has gone ahead and set up `yyin' to point to
 * another input file, and scanning continues. If it returns true (non-zero),
 * then the scanner terminates, returning 0 to its caller. */

namespace SEAMS {

  Scanner::Scanner(Aprepro &aprepro_yyarg, std::istream *in, std::ostream *out)
      : SEAMSFlexLexer(in, out), aprepro(aprepro_yyarg)
  {
    aprepro.outputStream.push(out);
  }

  Scanner::~Scanner() {}

  void Scanner::add_include_file(const std::string &filename, bool must_exist)
  {
    std::fstream *yytmp = nullptr;
    if (must_exist)
      yytmp = aprepro.open_file(filename.c_str(), "r");
    else
      yytmp = aprepro.check_open_file(filename.c_str(), "r");

    if (yytmp) {
      if (yyin && !yy_init) {
        yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(yyin, YY_BUF_SIZE));
      }

      yyin = yytmp;
      aprepro.info("Included File: '" + filename + "'", true);

      SEAMS::file_rec new_file(filename.c_str(), 0, false, 0);
      aprepro.ap_file_list.push(new_file);

      yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(yytmp, YY_BUF_SIZE));
      curr_index = 0;
    }
  }

  void Scanner::LexerOutput(const char *buf, int size)
  {
    // Do this before writing so that we have the correct index in the
    // output stream.
    if (aprepro.ap_options.keep_history) {
      aprepro.add_history(history_string, buf);
      history_string.clear();
      hist_start = 0;
    }

    aprepro.outputStream.top()->write(buf, size);
    if (aprepro.ap_options.interactive && aprepro.outputStream.size() == 1) {
      // In interactive mode, output to stdout in addition to the
      // output stream, unless user has redirected output...
      std::cout << buf;
    }
  }

  int Scanner::LexerInput(char *buf, int max_size)
  {
    if (yyin->eof() || yyin->fail()) {
      return 0;
    }

    if (aprepro.ap_options.interactive && yyin == &std::cin && isatty(0) != 0 && isatty(1) != 0) {
      char *line = getline_int(nullptr);

      if (strlen(line) == 0) {
        return 0;
      }

      gl_histadd(line);

      if (strlen(line) > (size_t)max_size - 2) {
        yyerror("input line is too long");
        return 0;
      }

      strcpy(buf, line);
      strcat(buf, "\n");

      return strlen(buf);
    }
    else {
      (void)yyin->read(buf, max_size);

      if (yyin->bad()) {
        return -1;
      }
      else {
        return yyin->gcount();
      }
    }
  }

  int Scanner::yywrap()
  {
    // Clear the history string.
    history_string.clear();
    hist_start = 0;
    curr_index = 0;

    // If we are using the string interactive method, we want to return to
    // our original state if parsing was cutoff prematurely.
    if (aprepro.string_interactive() && YY_START == PARSING) {
      if (switch_skip_to_endcase) {
        BEGIN(END_CASE_SKIP);
      }
      else {
        BEGIN(if_state[if_lvl]);
      }
    }

    if (aprepro.ap_file_list.size() <= 1) { /* End of main file, not in nested include */
      return (1);
    }
    else if (aprepro.string_interactive() && loop_lvl) {
      return (1);
    }
    else if (aprepro.isCollectingLoop) {
      yyerror("End-of-file detected inside loop. Check loop syntax. {endloop} must be on line by "
              "itself.");
      return (1);
    }
    else {
      /* We are in an included or looping file */
      if (aprepro.ap_file_list.top().tmp_file) {
        if (aprepro.ap_options.debugging) {
          std::cerr << "DEBUG LOOP: Loop count = " << aprepro.ap_file_list.top().loop_count << "\n";
        }
        if (--aprepro.ap_file_list.top().loop_count <= 0) {
          // On Windows, you can't remove the temp file until all the references to the
          // file object have been released, so we will delete it here.
          delete yyin;
          yyin = nullptr;

          if (aprepro.ap_file_list.top().name != "_string_") {
            if (!aprepro.ap_options.debugging) {
              remove(aprepro.ap_file_list.top().name.c_str()); /* Delete file if temporary */
            }
            if (!aprepro.doLoopSubstitution) {
              yy_pop_state();
            }
          }

          aprepro.ap_file_list.pop();
          yyFlexLexer::yypop_buffer_state();
        }
        else {
          // Do not pop ap_file_list; we are rereading that file...
          delete yyin;
          yyin = nullptr;
          yyFlexLexer::yypop_buffer_state();
          yyin = aprepro.open_file(aprepro.ap_file_list.top().name, "r");
          yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(yyin, YY_BUF_SIZE));
          aprepro.ap_file_list.top().lineno = 0;
        }
      }
      else {
        delete yyin;
        yyin = nullptr;
        aprepro.ap_file_list.pop();
        yyFlexLexer::yypop_buffer_state();

        if (aprepro.ap_file_list.top().name == "standard input") {
          yyin = &std::cin;
        }

        /* Turn echoing back on at end of included files. */
        echo = true;

        // If we are not doing aprepro substitutions for the included file, but
        // just collecting lines, pop the state from VERBATIM back to what it
        // was previously.
        if (!aprepro.doIncludeSubstitution) {
          yy_pop_state();
        }

        /* Set immutable mode back to global immutable
         * state at end of included file*/
        aprepro.stateImmutable = aprepro.ap_options.immutable;
      }

      // Reset the current character index.
      curr_index = 0;
      if (yyin != nullptr) {
        curr_index = yyin->tellg();
      }

      return (0);
    }
  }

  /* Print error message to standard error and return.  Note: internally
   *   'lineno' starts at zero.  To avoid confusion, we add 1 to value
   *   when it is output.
   */

  void Scanner::yyerror(const char *s) { aprepro.error(s); }

  char *Scanner::execute(char string[])
  {
    /* Push the contents of 'string' onto the stack to be reread.
     * 'string' will be surrounded by {} so it must be a valid expression.
     */

    /*
     * NOTE: The closing } has not yet been scanned in the call to execute();
     *       therefore, we read it ourselves using input(), then we push:
     *       '}{' + our string + '}'
     */
    int i;
    while ((i = yyFlexLexer::yyinput()) != '}' && i != EOF)
      curr_index++; /* eat up values */

    // Increment curr_index to account for the '}' and save history
    curr_index++;
    save_history_string();

    /* Allocate space for string + '}' + '{' + end_of_string */
    std::string new_string;
    new_string += "}{";
    new_string += string;
    new_string += "}";

    aprepro.ap_file_list.push(SEAMS::file_rec("_string_", 0, true, -1));

    auto ins = new std::istringstream(new_string); // Declare an input string stream.
    yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(ins, new_string.size()));
    return (nullptr);
  }

  /* Push the contents of 'string' onto the stack to be reread.
   * 'string' will not be surrounded by {}.
   */

  char *Scanner::rescan(char *string)
  {
    int i;
    /*
     * NOTE: The closing } has not yet been scanned in the call to rescan();
     *       therefore, we read it ourselves using input(), then we push our
     *       string and then put the closing } back on the stack last
     *       (to be read first),
     */
    while ((i = yyFlexLexer::yyinput()) != '}' && i != EOF)
      curr_index++; /* eat up values */

    // Increment curr_index to account for the '}' and save history
    curr_index++;
    save_history_string();

    {
      aprepro.ap_file_list.push(SEAMS::file_rec("_string_", 0, true, -1));
      std::string new_string("}");
      new_string += string;

      auto ins = new std::istringstream(new_string); // Declare an input string stream.
      yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(ins, new_string.size()));
    }
    return (nullptr);
  }

  char *Scanner::if_handler(double x)
  {
    if_lvl++;
    if (if_lvl >= MAX_IF_NESTING) {
      yyerror("Too many nested if statements");
    }
    else {
      if (x == 0) {
        if_state[if_lvl]    = IF_SKIP;
        if_case_run[if_lvl] = false;
      }
      else {
        suppress_nl         = true;
        if_state[if_lvl]    = INITIAL;
        if_case_run[if_lvl] = true;
      }
      if (aprepro.ap_options.debugging) {
        std::cerr << "DEBUG IF: If level " << if_lvl << " " << if_state[if_lvl] << "\n";
      }
    }
    return (nullptr);
  }

  char *Scanner::elseif_handler(double x)
  {
    if (x == 0 || if_case_run[if_lvl]) {
      if_state[if_lvl] = IF_SKIP;
    }
    else {
      suppress_nl         = 1;
      if_state[if_lvl]    = INITIAL;
      if_case_run[if_lvl] = true;
    }
    if (aprepro.ap_options.debugging) {
      std::cerr << "DEBUG IF: elseif at level " << if_lvl << " " << if_state[if_lvl] << "\n";
    }
    return (nullptr);
  }

  char *Scanner::switch_handler(double x)
  {
    // save that we are in a switch statement
    // save the value of 'x' for use in deciding which case to execute
    if (switch_active) {
      yyerror("switch statement found while switch already active. Nested switch not supported.");
    }

    switch_active          = true;
    switch_case_run        = false;
    switch_condition       = x;
    switch_skip_to_endcase = true; /* Skip everything until first case */
    suppress_nl            = true;

    if (aprepro.ap_options.debugging) {
      std::cerr << "DEBUG SWITCH: 'switch' with condition = " << switch_condition << " at line "
                << aprepro.ap_file_list.top().lineno << "\n";
    }
    return (nullptr);
  }

  char *Scanner::case_handler(double x)
  {
    // make sure we are in a switch statement
    // if 'x' matches the value saved in the switch statement
    // and no other case has been executed, then
    // execute the code in the case and set a flag indicating
    // the switch has run;
    // if 'x' does not match the value saved, then skip to endcase
    suppress_nl = true;

    if (!switch_active) {
      yyerror("case statement found outside switch statement.");
    }

    if (!switch_case_run && x == switch_condition) {
      switch_case_run = true;
      if (aprepro.ap_options.debugging) {
        fprintf(stderr,
                "DEBUG SWITCH: 'case' condition = %g matches switch condition = %g at line %d\n", x,
                switch_condition, aprepro.ap_file_list.top().lineno);
      }
    }
    else {
      if (aprepro.ap_options.debugging) {
        fprintf(stderr,
                "DEBUG SWITCH: 'case' condition = %g does not match switch condition = %g "
                "(or case already matched) at line %d\n",
                x, switch_condition, aprepro.ap_file_list.top().lineno);
      }

      // Need to skip all code until end of case
      switch_skip_to_endcase = true;
    }
    return (nullptr);
  }

  void Scanner::save_history_string()
  {
    if (!aprepro.ap_options.keep_history) {
      return;
    }

    // Don't do it if the file is the one used by execute and rescan.
    if (aprepro.ap_file_list.top().name == "_string_") {
      return;
    }

    size_t hist_end = curr_index;
    size_t len      = hist_end - hist_start;

    if (len <= 0)
      return;

    // Go back in the stream to where we started keeping history.
    yyin->seekg(hist_start);

    // Read everything up to this point again and save it.
    auto tmp = new char[len + 1];
    yyin->read(tmp, len);
    tmp[len] = '\0';

    history_string = tmp;
    delete[] tmp;
    hist_start = 0;
  }
} // namespace SEAMS

  /* This implementation of ExampleFlexLexer::yylex() is required to fill the
   * vtable of the class ExampleFlexLexer. We define the scanner's main yylex
   * function via YY_DECL to reside in the Scanner class instead. */

#ifdef yylex
#undef yylex
#endif
int SEAMSFlexLexer::yylex()
{
  std::cerr << "in ExampleFlexLexer::yylex() !" << '\n';
  return 0;
}

/* When the scanner receives an end-of-file indication from YY_INPUT, it then
 * checks the yywrap() function. If yywrap() returns false (zero), then it is
 * assumed that the function has gone ahead and set up `yyin' to point to
 * another input file, and scanning continues. If it returns true (non-zero),
 * then the scanner terminates, returning 0 to its caller. */

int SEAMSFlexLexer::yywrap() { return 1; }
