
#line 3 "apr_scanner.cc"

#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

/* %not-for-header */

/* %if-c-only */
/* %if-not-reentrant */
/* %endif */
/* %endif */
/* %ok-for-header */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION    2
#define YY_FLEX_MINOR_VERSION    5
#define YY_FLEX_SUBMINOR_VERSION 39
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* %if-c++-only */
/* The c++ scanner is a mess. The FlexLexer.h header file relies on the
 * following macro. This is required in order to pass the c++-multiple-scanners
 * test in the regression suite. We get reports that it breaks inheritance.
 * We will address this in a future release of flex, or omit the C++ scanner
 * altogether.
 */
#define yyFlexLexer SEAMSFlexLexer
/* %endif */

/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
/* %if-c-only */
/* %endif */

/* %if-tables-serialization */
/* %endif */
/* end standard C headers. */

/* %if-c-or-c++ */
/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t   flex_int8_t;
typedef uint8_t  flex_uint8_t;
typedef int16_t  flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t  flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char        flex_int8_t;
typedef short int          flex_int16_t;
typedef int                flex_int32_t;
typedef unsigned char      flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int       flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* %endif */

/* %if-c++-only */
/* begin standard C++ headers. */
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <errno.h>
#include <iostream>
/* end standard C++ headers. */
/* %endif */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else /* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined(__STDC__)

#define YY_USE_CONST

#endif /* defined (__STDC__) */
#endif /* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* %not-for-header */

/* Returned upon end-of-file. */
#define YY_NULL 0
/* %ok-for-header */

/* %not-for-header */

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int)(unsigned char)c)
/* %ok-for-header */

/* %if-reentrant */
/* %endif */

/* %if-not-reentrant */

/* %endif */

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE  YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

/* %if-not-reentrant */
extern yy_size_t yyleng;
/* %endif */

/* %if-c-only */
/* %if-not-reentrant */
/* %endif */
/* %endif */

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE   1
#define EOB_ACT_LAST_MATCH    2

#define YY_LESS_LINENO(n)
#define YY_LINENO_REWIND_TO(ptr)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                                  \
  do {                                                                                             \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    *yy_cp                                = (yy_hold_char);                                        \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;        \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                                                 \
  } while (0)

#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
  /* %if-c-only */
  /* %endif */

  /* %if-c++-only */
  std::istream *yy_input_file;
  /* %endif */

  char *yy_ch_buf;  /* input buffer */
  char *yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  yy_size_t yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  yy_size_t yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW    0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* %if-c-only Standard (non-C++) definition */
/* %not-for-header */

/* %if-not-reentrant */
/* %endif */
/* %ok-for-header */

/* %endif */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* %if-c-only Standard (non-C++) definition */
/* %if-not-reentrant */
/* %not-for-header */

/* %ok-for-header */

/* %endif */
/* %endif */

void *SEAMSalloc(yy_size_t);
void *SEAMSrealloc(void *, yy_size_t);
void  SEAMSfree(void *);

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive)                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER) {                                                                      \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                                  \
  }

#define yy_set_bol(at_bol)                                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER) {                                                                      \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                                  \
  }

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
/* Begin user sect3 */

#define FLEX_DEBUG

typedef unsigned char YY_CHAR;

#define yytext_ptr yytext
#define YY_INTERACTIVE

#include <FlexLexer.h>

/* %% [1.5] DFA */

/* %if-c-only Standard (non-C++) definition */
/* %endif */

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                                        \
  (yytext_ptr) = yy_bp;                                                                            \
  /* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */                         \
  yyleng         = (size_t)(yy_cp - yy_bp);                                                        \
  (yy_hold_char) = *yy_cp;                                                                         \
  *yy_cp         = '\0';                                                                           \
  /* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */                        \
  (yy_c_buf_p) = yy_cp;

/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
#define YY_NUM_RULES     107
#define YY_END_OF_BUFFER 108
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
{
  flex_int32_t yy_verify;
  flex_int32_t yy_nxt;
};
static yyconst flex_int16_t yy_accept[782] = {
    0,   0,   0,   55,  55,  0,   0,   44,  44,  0,   0,   3,   3,   0,   0,   0,   0,
    0,   0,   0,   0,   0,   0,   108, 105, 105, 106, 105, 103, 105, 104, 104, 104, 105,
    100, 55,  75,  90,  105, 105, 103, 72,  105, 105, 76,  77,  68,  66,  78,  67,  54,
    71,  53,  80,  79,  82,  57,  83,  81,  56,  56,  56,  91,  92,  73,  100, 105, 95,
    69,  105, 105, 105, 103, 105, 104, 104, 104, 105, 100, 47,  47,  48,  44,  47,  47,
    47,  44,  44,  44,  44,  47,  47,  105, 105, 4,   4,   5,   3,   4,   4,   4,

    3,   3,   3,   3,   4,   4,   105, 105, 38,  105, 103, 105, 104, 104, 104, 105, 100,
    105, 105, 105, 103, 105, 104, 104, 104, 105, 100, 105, 105, 20,  105, 103, 105, 104,
    104, 104, 105, 100, 105, 105, 24,  105, 103, 105, 104, 104, 104, 105, 100, 105, 105,
    28,  105, 103, 105, 104, 104, 104, 105, 100, 0,   0,   0,   0,   0,   0,   104, 104,
    104, 97,  98,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   99,  55,
    0,   87,  0,   93,  0,   0,   0,   88,  0,   94,  74,  60,  64,  58,  65,

    59,  54,  0,   70,  61,  54,  53,  0,   84,  86,  85,  56,  56,  56,  62,  0,   89,
    96,  0,   0,   0,   0,   0,   0,   104, 104, 104, 97,  98,  0,   99,  0,   0,   44,
    44,  0,   0,   0,   0,   44,  44,  44,  45,  46,  0,   0,   0,   3,   3,   3,   3,
    3,   0,   0,   0,   38,  0,   0,   0,   0,   0,   0,   104, 104, 104, 97,  98,  0,
    0,   0,   99,  0,   0,   0,   0,   0,   0,   104, 104, 104, 97,  98,  0,   99,  0,
    20,  0,   0,   0,   0,   104, 104, 104, 97,  98,  0,   0,   0,   99,  0,

    24,  0,   0,   0,   0,   104, 104, 104, 97,  98,  0,   0,   0,   99,  0,   28,  0,
    0,   0,   0,   0,   0,   104, 104, 104, 97,  98,  0,   0,   0,   0,   0,   99,  0,
    0,   0,   104, 104, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   63,  0,   54,  0,   53,  56,  56,  0,   0,   52,  104, 104, 0,   0,
    0,   44,  44,  0,   0,   0,   3,   3,   0,   0,   0,   104, 104, 0,   0,   0,   0,
    104, 104, 0,   0,   104, 104, 0,   0,   0,   0,   104, 104, 0,   0,   0,

    0,   104, 104, 0,   0,   0,   0,   0,   0,   0,   101, 102, 0,   0,   0,   6,   0,
    0,   0,   0,   0,   0,   32,  0,   0,   0,   0,   0,   0,   0,   0,   0,   56,  56,
    0,   101, 102, 0,   0,   0,   44,  44,  0,   0,   0,   40,  0,   0,   3,   3,   0,
    0,   0,   101, 102, 0,   0,   0,   0,   0,   0,   0,   16,  0,   101, 102, 0,   0,
    101, 102, 0,   0,   0,   0,   101, 102, 0,   0,   0,   0,   101, 102, 0,   0,   0,
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,

    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   36,
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   0,   0,   0,   0,   0,   9,   0,   0,   0,   0,   0,   0,   0,   0,
    15,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    25,  0,   0,   0,   0,   0,   0,   0,   42,  0,   0,   30,  0,   0,   0,

    0,   0,   0,   0,   0,   0,   0,   0,   0,   39,  0,   0,   0,   0,   38,  0,   0,
    0,   0,   0,   0,   0,   0,   0,   20,  0,   0,   0,   18,  0,   0,   24,  0,   0,
    0,   22,  0,   28,  0,   0,   0,   0,   0,   0,   0,   0,   33,  0,   49,  0,   31,
    0,   0,   11,  0,   0,   0,   0,   52,  0,   0,   0,   43,  0,   41,  0,   0,   0,
    34,  0,   35,  0,   0,   0,   0,   0,   0,   0,   20,  0,   0,   0,   24,  0,   0,
    28,  0,   0,   0,   0,   0,   0,   0,   0,   50,  0,   0,   0,   0,   0,

    52,  0,   0,   0,   37,  0,   16,  0,   0,   0,   0,   17,  0,   0,   21,  0,   0,
    0,   0,   0,   51,  0,   10,  0,   0,   0,   26,  0,   0,   0,   0,   0,   16,  0,
    0,   0,   0,   26,  0,   0,   12,  0,   0,   0,   0,   0,   0,   0,   0,   19,  0,
    23,  0,   0,   0,   0,   0,   0,   29,  0,   0,   0,   27,  0,   0,   0,   0,   0,
    0,   8,   0,   0,   7,   0,   2,   0,   0,   13,  1,   14,  0};

static yyconst flex_int32_t yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  2,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13,
    14, 15, 16, 17, 18, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 22, 23, 24, 25,
    26, 1,  27, 28, 29, 30, 31, 32, 33, 34, 35, 33, 33, 36, 37, 38, 39, 40, 41, 42, 43,
    44, 45, 46, 33, 47, 33, 33, 48, 49, 50, 51, 33, 1,  52, 53, 54, 55,

    56, 57, 33, 58, 59, 33, 33, 60, 33, 61, 62, 63, 64, 65, 66, 67, 68, 33, 69, 70, 33,
    33, 71, 72, 73, 74, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};

static yyconst flex_int32_t yy_meta[75] = {0, 1, 2, 3, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                                           1, 5, 6, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                                           5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 5, 5, 5, 5, 5,
                                           5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 2, 1, 1, 1};

static yyconst flex_int16_t yy_base[830] = {
    0,    0,    0,    74,   0,    148,  0,    222,  0,    295,  302,  373,  0,    447,  0,
    521,  0,    595,  0,    669,  0,    743,  0,    3055, 3056, 296,  3056, 816,  823,  3035,
    0,    254,  260,  240,  893,  817,  3056, 3029, 309,  830,  837,  3056, 3042, 3040, 3056,
    3056, 293,  301,  3056, 302,  298,  303,  312,  3056, 3056, 3026, 3025, 3024, 3056, 0,
    261,  278,  3056, 3056, 3023, 289,  2974, 2972, 3056, 3031, 844,  856,  863,  320,  964,
    287,  290,  813,  842,  3056, 848,  3056, 864,  870,  1037, 3024, 820,  332,  832,  888,
    267,  1038, 879,  3023, 3056, 1044, 3056, 1045, 1051, 1058, 3022,

    841,  338,  889,  895,  276,  1030, 3037, 1048, 3056, 1076, 1085, 345,  1156, 781,  817,
    887,  1229, 3026, 1232, 1233, 1240, 331,  1311, 833,  862,  1041, 1050, 3035, 1384, 3056,
    1387, 1394, 352,  1465, 867,  876,  1040, 1071, 3034, 1538, 3056, 1541, 1548, 353,  1619,
    876,  887,  1061, 1235, 3033, 1692, 3056, 1695, 1702, 923,  1773, 891,  1022, 1065, 1846,
    1849, 1064, 1850, 1853, 3016, 1401, 0,    302,  306,  3056, 3056, 1555, 2961, 2993, 908,
    1088, 1217, 1043, 2993, 3000, 2974, 1092, 1218, 3056, 1854, 798,  3056, 948,  3056, 1860,
    1861, 3010, 3056, 3017, 3056, 3003, 3056, 3056, 3056, 3056,

    3056, 1237, 1124, 1871, 3056, 1238, 1245, 1266, 3056, 3056, 3056, 0,    1037, 1040, 3056,
    1373, 3056, 3056, 3013, 1872, 1879, 1087, 1880, 350,  0,    1208, 1237, 3012, 3011, 1379,
    3010, 1887, 1709, 1892, 1083, 1893, 1903, 3003, 1912, 941,  1389, 1395, 3056, 3056, 1924,
    1382, 1088, 1902, 1237, 1129, 1400, 1542, 2981, 2989, 3016, 3056, 1931, 1934, 1937, 1984,
    1258, 1950, 0,    1238, 1255, 3015, 3014, 1713, 1544, 1248, 3013, 3002, 1540, 1944, 1394,
    1992, 892,  0,    1379, 1387, 3001, 3000, 1555, 2999, 3008, 3056, 1958, 1697, 2014, 1279,
    0,    1388, 1392, 3007, 3006, 1409, 1698, 1555, 3005, 3004,

    3056, 1973, 2001, 2023, 1425, 0,    1394, 1519, 3003, 3002, 1709, 1998, 1905, 3001, 3000,
    3056, 2010, 2036, 2043, 2067, 1442, 1704, 0,    1526, 1529, 2999, 2998, 2046, 2016, 844,
    901,  2057, 2997, 2076, 1535, 1252, 1364, 1382, 1529, 1538, 2996, 2956, 1403, 2963, 1526,
    1532, 2085, 2959, 1543, 1540, 2964, 2952, 2936, 1545, 3056, 2972, 2971, 2970, 2969, 1539,
    1540, 1665, 2060, 2975, 1674, 1675, 1906, 1709, 1688, 2061, 2062, 1687, 1684, 2118, 2075,
    2095, 2945, 2944, 1963, 1685, 1688, 2065, 1868, 2122, 349,  1694, 1702, 2100, 2114, 1842,
    1912, 2106, 2118, 2133, 2146, 1940, 2097, 2147, 2144, 2148,

    2150, 2113, 2114, 856,  2151, 2152, 1397, 1856, 2167, 2039, 0,    0,    2124, 2930, 2981,
    3056, 2952, 1697, 2943, 1967, 1695, 2189, 3056, 1979, 2082, 2936, 1707, 2132, 2951, 2951,
    2926, 2139, 0,    0,    2140, 0,    0,    2187, 2179, 2209, 1908, 2155, 2159, 2168, 2224,
    3056, 2173, 2176, 2211, 2212, 2946, 2948, 2237, 0,    0,    2216, 2217, 2242, 2972, 2224,
    2220, 1286, 3056, 2162, 0,    0,    2217, 2224, 0,    0,    2239, 2231, 2250, 2248, 0,
    0,    2253, 2258, 2257, 2260, 0,    0,    1100, 2263, 2261, 2265, 1863, 2266, 2226, 2908,
    2933, 1867, 2253, 2232, 2242, 2245, 2247, 2928, 2239, 2325,

    2937, 2943, 2901, 2899, 2894, 1857, 2258, 2266, 2271, 2276, 2282, 2926, 2938, 2255, 2309,
    2736, 3056, 2321, 2328, 1289, 1905, 2322, 2295, 2267, 2331, 2333, 2343, 2339, 2276, 2345,
    2347, 2378, 2348, 2340, 2353, 2722, 2349, 837,  2330, 2676, 2319, 2674, 3056, 2335, 2690,
    2619, 2356, 2337, 2664, 2341, 2389, 3056, 2650, 2644, 2626, 2626, 1563, 2011, 2338, 2342,
    2396, 2371, 2642, 2639, 2679, 2354, 2417, 2373, 1605, 2362, 2401, 2678, 2358, 2404, 2420,
    2677, 2408, 2676, 2367, 2409, 2443, 2675, 2674, 2412, 2673, 3056, 858,  2413, 2635, 2395,
    1108, 2437, 2670, 3056, 2669, 2450, 3056, 2455, 2643, 2395,

    2597, 2634, 2601, 2600, 2085, 2461, 2457, 2662, 2471, 3056, 2474, 2625, 2628, 2659, 3056,
    2658, 2477, 2657, 2488, 2474, 2481, 2485, 2466, 2655, 3056, 2654, 2453, 2653, 3056, 2479,
    2652, 3056, 2651, 2492, 2650, 3056, 2649, 3056, 2648, 2430, 2435, 2638, 2465, 2617, 2635,
    2497, 3056, 2644, 3056, 2502, 3056, 2610, 2508, 3056, 2608, 2509, 2589, 2520, 2504, 2512,
    2527, 2639, 3056, 2533, 3056, 2629, 2603, 2636, 3056, 2634, 3056, 2540, 2631, 2523, 2535,
    2536, 2524, 2629, 3056, 2628, 2544, 2627, 3056, 2626, 2625, 3056, 2554, 2505, 2587, 2549,
    2607, 2538, 2576, 2558, 3056, 2591, 2562, 2596, 2538, 2565,

    2562, 2552, 2573, 2577, 3056, 2568, 3056, 2571, 2574, 2570, 2576, 3056, 2573, 2569, 3056,
    2586, 2547, 2543, 2487, 2590, 3056, 2430, 3056, 2446, 2414, 2439, 3056, 2593, 2398, 2395,
    2595, 2601, 3056, 2602, 2415, 2100, 2069, 3056, 2614, 2024, 3056, 1958, 1951, 2617, 1979,
    1957, 1835, 2609, 1768, 3056, 1767, 3056, 2621, 1753, 1712, 2072, 1590, 1578, 3056, 1497,
    1424, 1449, 3056, 1346, 1278, 1294, 1197, 1148, 1124, 3056, 1112, 852,  3056, 830,  3056,
    297,  278,  3056, 3056, 3056, 3056, 2690, 2696, 2702, 2704, 2710, 2715, 2717, 2722, 2724,
    2730, 2736, 2742, 2748, 2754, 2760, 2766, 2772, 2778, 2784,

    2790, 2796, 2802, 2808, 2814, 2820, 2826, 2832, 2838, 2844, 2850, 2856, 2862, 2868, 2874,
    2880, 2886, 2892, 2898, 2904, 2910, 2916, 2922, 2928, 2934, 2940, 2946, 2952, 2958};

static yyconst flex_int16_t yy_def[830] = {
    0,   781, 1,   781, 3,   781, 5,   781, 7,   1,   1,   781, 11,  781, 13,  781, 15,
    781, 17,  781, 19,  781, 21,  781, 781, 781, 781, 781, 781, 781, 782, 782, 782, 781,
    781, 781, 781, 781, 783, 781, 781, 781, 781, 784, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 785, 785, 785, 781, 781, 781, 781, 781, 781,
    781, 786, 786, 786, 786, 786, 781, 74,  74,  786, 786, 781, 781, 781, 787, 781, 781,
    781, 787, 788, 788, 788, 781, 781, 781, 781, 781, 781, 781, 789, 781, 781, 781,

    789, 790, 790, 790, 781, 781, 791, 791, 781, 791, 791, 791, 781, 113, 113, 791, 791,
    792, 792, 792, 792, 792, 781, 123, 123, 792, 792, 793, 793, 781, 793, 793, 793, 781,
    134, 134, 793, 793, 794, 794, 781, 794, 794, 794, 781, 145, 145, 794, 794, 795, 795,
    781, 795, 795, 795, 781, 156, 156, 795, 795, 781, 34,  781, 781, 781, 781, 782, 782,
    782, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 783, 781, 781, 781, 781, 781, 784, 781, 781, 781, 781, 781, 781,

    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 785, 785, 785, 781, 781, 781,
    781, 786, 786, 786, 786, 786, 786, 74,  74,  74,  786, 786, 786, 786, 781, 781, 787,
    787, 781, 781, 781, 781, 788, 788, 788, 781, 781, 781, 781, 781, 789, 789, 790, 790,
    790, 781, 781, 791, 781, 791, 791, 791, 791, 791, 791, 113, 113, 113, 791, 791, 791,
    791, 791, 791, 792, 792, 792, 792, 792, 792, 123, 123, 123, 792, 792, 792, 792, 793,
    781, 793, 793, 793, 793, 134, 134, 134, 793, 793, 793, 793, 793, 793, 794,

    781, 794, 794, 794, 794, 145, 145, 145, 794, 794, 794, 794, 794, 794, 795, 781, 795,
    795, 795, 795, 795, 795, 156, 156, 156, 795, 795, 795, 795, 795, 795, 795, 795, 781,
    781, 781, 782, 782, 781, 781, 796, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 785, 785, 781, 786, 786, 74,  74,  786, 786,
    781, 788, 788, 781, 781, 781, 790, 790, 781, 781, 791, 113, 113, 791, 791, 791, 797,
    123, 123, 792, 792, 134, 134, 793, 793, 793, 793, 145, 145, 794, 794, 794,

    794, 156, 156, 795, 795, 795, 795, 795, 795, 781, 782, 782, 781, 781, 796, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 785, 785,
    781, 74,  74,  786, 786, 781, 788, 788, 781, 781, 781, 781, 781, 781, 790, 790, 781,
    781, 791, 113, 113, 791, 791, 791, 798, 791, 791, 797, 781, 797, 123, 123, 792, 792,
    134, 134, 793, 793, 793, 793, 145, 145, 794, 794, 794, 794, 156, 156, 795, 795, 795,
    795, 795, 795, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,

    781, 781, 781, 781, 781, 786, 786, 781, 781, 781, 781, 781, 781, 791, 791, 798, 781,
    791, 791, 797, 792, 792, 793, 793, 793, 793, 793, 794, 794, 794, 794, 794, 795, 795,
    795, 799, 795, 795, 781, 781, 781, 781, 781, 781, 800, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 801, 786, 781, 781, 781, 781, 781, 781, 802, 791, 791, 791,
    803, 792, 793, 804, 793, 793, 793, 805, 794, 806, 794, 794, 794, 807, 808, 795, 799,
    781, 795, 795, 781, 781, 781, 781, 800, 781, 809, 781, 781, 781, 781, 781,

    781, 781, 781, 781, 801, 801, 810, 811, 781, 781, 781, 781, 781, 802, 781, 812, 791,
    813, 791, 803, 803, 814, 793, 804, 781, 815, 793, 805, 781, 794, 806, 781, 816, 794,
    807, 781, 808, 781, 817, 795, 795, 781, 781, 781, 781, 781, 781, 809, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 801, 801, 810, 810, 811, 781, 781, 781, 781, 781, 812,
    781, 813, 781, 791, 818, 819, 814, 814, 793, 815, 781, 820, 794, 816, 781, 821, 817,
    781, 795, 795, 781, 781, 781, 781, 781, 781, 781, 781, 781, 822, 781, 810,

    810, 781, 781, 818, 781, 819, 781, 819, 823, 793, 820, 781, 794, 821, 781, 795, 824,
    795, 781, 781, 781, 781, 781, 781, 781, 822, 781, 781, 781, 781, 819, 823, 781, 823,
    825, 826, 824, 781, 795, 781, 781, 781, 781, 781, 827, 781, 781, 823, 825, 781, 826,
    781, 795, 828, 781, 781, 781, 827, 781, 781, 781, 828, 781, 781, 781, 781, 781, 829,
    781, 781, 781, 781, 781, 829, 781, 781, 781, 781, 781, 781, 0,   781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,

    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781};

static yyconst flex_int16_t yy_nxt[3131] = {
    0,   24,  25,  26,  25,  24,  24,  27,  28,  24,  24,  24,  24,  24,  24,  24,  24,
    24,  24,  29,  24,  24,  24,  24,  24,  24,  24,  30,  30,  30,  30,  31,  30,  30,
    30,  30,  30,  30,  30,  30,  30,  32,  30,  30,  30,  30,  30,  30,  24,  33,  24,
    24,  30,  30,  30,  30,  31,  30,  30,  30,  30,  30,  30,  30,  32,  30,  30,  30,
    30,  30,  30,  34,  24,  24,  24,  24,  35,  36,  35,  37,  38,  39,  40,  41,  42,
    43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,

    59,  59,  59,  59,  60,  59,  59,  59,  59,  59,  59,  59,  59,  59,  61,  59,  59,
    59,  59,  59,  59,  62,  33,  63,  64,  59,  59,  59,  59,  60,  59,  59,  59,  59,
    59,  59,  59,  61,  59,  59,  59,  59,  59,  59,  65,  66,  67,  68,  69,  70,  26,
    70,  69,  69,  71,  72,  69,  69,  69,  69,  69,  69,  69,  69,  69,  69,  73,  69,
    69,  69,  69,  69,  69,  69,  74,  74,  74,  74,  75,  74,  74,  74,  74,  74,  74,
    74,  74,  74,  76,  74,  74,  74,  74,  74,  74,  69,  77,  69,  69,  74,

    74,  74,  74,  75,  74,  74,  74,  74,  74,  74,  74,  76,  74,  74,  74,  74,  74,
    74,  78,  69,  69,  69,  79,  80,  81,  82,  79,  79,  83,  84,  79,  79,  79,  79,
    79,  79,  79,  79,  79,  79,  85,  86,  79,  79,  79,  79,  79,  79,  87,  87,  87,
    87,  88,  87,  87,  87,  87,  87,  87,  87,  87,  87,  89,  87,  87,  87,  87,  87,
    87,  79,  90,  79,  79,  87,  87,  87,  87,  88,  87,  87,  87,  87,  87,  87,  87,
    89,  87,  87,  87,  87,  87,  87,  91,  79,  79,  79,  92,  161, 92,  161,

    168, 39,  40,  92,  169, 92,  196, 213, 39,  40,  170, 189, 171, 93,  189, 198, 197,
    202, 200, 216, 93,  204, 214, 168, 199, 201, 205, 169, 203, 206, 213, 207, 220, 226,
    227, 235, 337, 243, 223, 244, 338, 249, 208, 273, 216, 214, 170, 256, 171, 276, 780,
    463, 167, 203, 286, 301, 226, 227, 167, 184, 337, 464, 220, 260, 338, 65,  162, 208,
    223, 779, 289, 304, 65,  94,  95,  96,  97,  94,  94,  98,  99,  94,  94,  94,  94,
    94,  94,  94,  94,  94,  94,  100, 101, 94,  94,  94,  94,  94,  94,  102,

    102, 102, 102, 103, 102, 102, 102, 102, 102, 102, 102, 102, 102, 104, 102, 102, 102,
    102, 102, 102, 94,  105, 94,  94,  102, 102, 102, 102, 103, 102, 102, 102, 102, 102,
    102, 102, 104, 102, 102, 102, 102, 102, 102, 106, 94,  94,  94,  107, 108, 109, 108,
    107, 107, 110, 111, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 112, 107, 107,
    107, 107, 107, 107, 107, 113, 113, 113, 113, 114, 113, 113, 113, 113, 113, 113, 113,
    113, 113, 115, 113, 113, 113, 113, 113, 113, 107, 116, 107, 107, 113, 113,

    113, 113, 114, 113, 113, 113, 113, 113, 113, 113, 115, 113, 113, 113, 113, 113, 113,
    117, 107, 107, 107, 118, 119, 26,  119, 118, 118, 120, 121, 118, 118, 118, 118, 118,
    118, 118, 118, 118, 118, 122, 118, 118, 118, 118, 118, 118, 118, 123, 123, 123, 123,
    124, 123, 123, 123, 123, 123, 123, 123, 123, 123, 125, 123, 123, 123, 123, 123, 123,
    118, 126, 118, 118, 123, 123, 123, 123, 124, 123, 123, 123, 123, 123, 123, 123, 125,
    123, 123, 123, 123, 123, 123, 127, 118, 118, 118, 128, 129, 130, 129, 128,

    128, 131, 132, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 133, 128, 128, 128,
    128, 128, 128, 128, 134, 134, 134, 134, 135, 134, 134, 134, 134, 134, 134, 134, 134,
    134, 136, 134, 134, 134, 134, 134, 134, 128, 137, 128, 128, 134, 134, 134, 134, 135,
    134, 134, 134, 134, 134, 134, 134, 136, 134, 134, 134, 134, 134, 134, 138, 128, 128,
    128, 139, 140, 141, 140, 139, 139, 142, 143, 139, 139, 139, 139, 139, 139, 139, 139,
    139, 139, 144, 139, 139, 139, 139, 139, 139, 139, 145, 145, 145, 145, 146,

    145, 145, 145, 145, 145, 145, 145, 145, 145, 147, 145, 145, 145, 145, 145, 145, 139,
    148, 139, 139, 145, 145, 145, 145, 146, 145, 145, 145, 145, 145, 145, 145, 147, 145,
    145, 145, 145, 145, 145, 149, 139, 139, 139, 150, 151, 152, 151, 150, 150, 153, 154,
    150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 155, 150, 150, 150, 150, 150, 150,
    150, 156, 156, 156, 156, 157, 156, 156, 156, 156, 156, 156, 156, 156, 156, 158, 156,
    156, 156, 156, 156, 156, 150, 159, 150, 150, 156, 156, 156, 156, 157, 156,

    156, 156, 156, 156, 156, 156, 158, 156, 156, 156, 156, 156, 156, 160, 150, 150, 150,
    163, 185, 163, 185, 781, 164, 164, 163, 220, 163, 264, 216, 164, 164, 190, 775, 190,
    165, 235, 191, 191, 190, 316, 190, 165, 781, 191, 191, 221, 316, 221, 192, 232, 264,
    232, 167, 216, 220, 192, 220, 221, 316, 221, 316, 265, 223, 223, 221, 232, 221, 234,
    220, 223, 223, 236, 230, 236, 224, 220, 237, 237, 241, 279, 190, 224, 190, 228, 265,
    229, 166, 186, 238, 256, 781, 235, 249, 166, 172, 407, 172, 230, 249, 173,

    186, 241, 279, 316, 273, 588, 280, 186, 167, 167, 276, 781, 231, 292, 222, 167, 483,
    640, 233, 174, 293, 175, 307, 176, 778, 316, 222, 177, 178, 280, 179, 308, 242, 222,
    233, 251, 292, 324, 180, 252, 239, 320, 343, 293, 235, 307, 175, 181, 182, 186, 189,
    183, 178, 189, 308, 242, 408, 266, 251, 267, 324, 167, 252, 184, 219, 219, 343, 219,
    219, 219, 219, 219, 219, 219, 219, 219, 220, 219, 219, 219, 219, 219, 219, 225, 225,
    219, 219, 219, 219, 219, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225,

    225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 219, 219, 219, 219, 225, 225,
    225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225,
    219, 219, 219, 219, 236, 245, 236, 245, 286, 237, 237, 190, 190, 190, 248, 257, 256,
    257, 190, 273, 190, 238, 253, 191, 191, 190, 216, 190, 273, 301, 191, 191, 325, 316,
    246, 192, 781, 360, 247, 286, 361, 254, 192, 259, 256, 259, 283, 350, 260, 260, 781,
    216, 259, 256, 259, 325, 781, 260, 260, 246, 261, 360, 247, 296, 361, 220,

    184, 297, 316, 261, 350, 283, 298, 239, 184, 781, 294, 281, 295, 282, 186, 186, 344,
    230, 258, 374, 284, 186, 296, 345, 777, 346, 297, 345, 186, 346, 298, 309, 249, 310,
    781, 326, 776, 327, 356, 644, 356, 299, 230, 357, 374, 645, 262, 345, 346, 167, 775,
    345, 354, 781, 533, 262, 255, 255, 256, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 263, 263, 255, 255, 255, 255, 255, 263, 263, 263,
    263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263,

    263, 263, 263, 255, 255, 255, 255, 263, 263, 263, 263, 263, 263, 263, 263, 263, 263,
    263, 263, 263, 263, 263, 263, 263, 263, 263, 255, 255, 255, 255, 268, 256, 268, 274,
    274, 274, 274, 301, 781, 276, 276, 274, 365, 274, 273, 273, 276, 276, 347, 347, 256,
    277, 273, 348, 349, 349, 202, 202, 277, 269, 256, 311, 206, 270, 207, 312, 365, 203,
    203, 773, 313, 366, 380, 347, 347, 208, 260, 349, 349, 384, 358, 286, 358, 410, 269,
    359, 311, 270, 463, 381, 312, 463, 203, 203, 313, 366, 380, 289, 464, 271,

    208, 464, 275, 275, 384, 314, 772, 781, 410, 771, 275, 272, 272, 381, 272, 272, 272,
    272, 272, 272, 272, 272, 272, 273, 272, 272, 272, 272, 272, 272, 278, 278, 272, 272,
    272, 272, 272, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,
    278, 278, 278, 278, 278, 278, 278, 272, 272, 272, 272, 278, 278, 278, 278, 278, 278,
    278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 272, 272, 272, 272,
    287, 286, 287, 287, 286, 287, 220, 235, 289, 289, 287, 286, 287, 235, 316,

    289, 289, 334, 249, 334, 290, 273, 411, 362, 167, 346, 286, 290, 386, 367, 167, 368,
    373, 770, 346, 167, 387, 390, 370, 283, 412, 391, 301, 396, 371, 411, 335, 362, 346,
    375, 336, 392, 386, 367, 368, 418, 373, 346, 304, 316, 387, 390, 370, 412, 283, 391,
    763, 396, 371, 288, 769, 335, 288, 375, 336, 320, 392, 486, 418, 288, 285, 285, 286,
    285, 285, 285, 285, 285, 285, 285, 285, 285, 285, 285, 285, 285, 285, 285, 285, 291,
    291, 285, 285, 285, 285, 285, 291, 291, 291, 291, 291, 291, 291, 291, 291,

    291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 285, 285, 285, 285, 291,
    291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291, 291,
    291, 285, 285, 285, 285, 302, 301, 302, 302, 301, 302, 249, 256, 304, 304, 302, 301,
    302, 273, 397, 304, 304, 172, 286, 172, 305, 402, 421, 167, 403, 413, 594, 305, 273,
    420, 768, 345, 427, 346, 413, 421, 606, 376, 397, 428, 382, 759, 383, 433, 434, 402,
    339, 421, 403, 413, 336, 388, 420, 389, 395, 345, 346, 427, 413, 414, 432,

    376, 428, 767, 382, 383, 433, 434, 594, 303, 181, 340, 303, 385, 336, 388, 389, 395,
    621, 303, 300, 300, 301, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
    300, 300, 300, 300, 306, 306, 300, 300, 300, 300, 300, 306, 306, 306, 306, 306, 306,
    306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 300, 300,
    300, 300, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306,
    306, 306, 306, 306, 300, 300, 300, 300, 317, 316, 317, 319, 316, 319, 286,

    286, 320, 320, 319, 316, 319, 316, 435, 320, 320, 245, 301, 245, 321, 268, 256, 268,
    436, 437, 440, 321, 220, 443, 296, 764, 492, 444, 297, 454, 495, 435, 455, 298, 393,
    329, 394, 398, 465, 439, 246, 436, 437, 499, 247, 440, 466, 443, 379, 296, 444, 492,
    454, 297, 495, 455, 763, 298, 393, 394, 329, 465, 398, 318, 439, 246, 322, 499, 247,
    466, 752, 750, 379, 322, 315, 315, 316, 315, 315, 315, 315, 315, 315, 315, 315, 315,
    315, 315, 315, 315, 315, 315, 315, 323, 323, 315, 315, 315, 315, 315, 323,

    323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
    323, 323, 323, 315, 315, 315, 315, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
    323, 323, 323, 323, 323, 323, 323, 323, 323, 315, 315, 315, 315, 328, 316, 328, 161,
    163, 161, 163, 163, 185, 163, 185, 316, 164, 164, 190, 190, 190, 190, 316, 761, 191,
    191, 220, 256, 165, 190, 363, 190, 363, 329, 191, 191, 192, 221, 221, 221, 221, 220,
    469, 223, 223, 232, 192, 232, 220, 220, 232, 236, 234, 236, 457, 224, 330,

    331, 332, 541, 190, 236, 248, 236, 301, 469, 237, 237, 235, 487, 245, 537, 245, 333,
    273, 220, 162, 166, 238, 457, 166, 186, 245, 541, 245, 167, 557, 186, 186, 257, 256,
    257, 268, 256, 268, 259, 256, 259, 186, 246, 401, 364, 274, 369, 274, 438, 222, 222,
    268, 256, 268, 372, 470, 273, 233, 369, 287, 286, 287, 233, 239, 269, 256, 401, 246,
    270, 760, 369, 438, 186, 239, 302, 301, 302, 569, 470, 372, 269, 759, 369, 475, 379,
    259, 256, 259, 757, 269, 260, 260, 270, 274, 453, 274, 756, 494, 276, 276,

    301, 258, 261, 301, 273, 269, 475, 262, 379, 496, 277, 317, 316, 317, 275, 287, 286,
    287, 316, 453, 289, 289, 494, 220, 302, 301, 302, 311, 288, 304, 304, 312, 290, 399,
    496, 400, 313, 328, 316, 328, 422, 305, 422, 303, 319, 316, 319, 328, 316, 328, 423,
    405, 311, 406, 262, 755, 312, 399, 400, 316, 313, 363, 275, 363, 235, 235, 329, 256,
    319, 316, 319, 738, 220, 320, 320, 405, 406, 334, 249, 334, 318, 167, 167, 607, 288,
    321, 422, 594, 422, 330, 331, 332, 405, 303, 406, 167, 423, 606, 249, 330,

    331, 404, 752, 765, 441, 442, 339, 456, 286, 766, 336, 497, 273, 322, 424, 167, 405,
    409, 449, 445, 286, 445, 425, 458, 256, 458, 273, 441, 442, 446, 456, 339, 364, 459,
    336, 286, 497, 322, 450, 424, 476, 449, 467, 468, 471, 425, 301, 447, 286, 301, 301,
    460, 301, 316, 316, 448, 481, 482, 235, 461, 472, 450, 473, 476, 463, 467, 489, 471,
    468, 316, 505, 500, 447, 495, 464, 167, 460, 479, 448, 481, 482, 485, 461, 472, 474,
    477, 478, 473, 480, 489, 422, 220, 422, 484, 500, 505, 485, 495, 509, 220,

    423, 508, 479, 510, 504, 511, 485, 474, 477, 478, 445, 480, 445, 507, 249, 249, 484,
    506, 256, 256, 446, 488, 256, 509, 508, 445, 256, 445, 510, 273, 511, 167, 167, 286,
    520, 446, 273, 507, 458, 256, 458, 286, 506, 458, 256, 458, 514, 521, 459, 519, 286,
    515, 286, 459, 518, 301, 539, 256, 522, 301, 301, 524, 301, 316, 542, 316, 544, 316,
    316, 286, 220, 514, 521, 546, 519, 515, 547, 548, 301, 518, 523, 539, 522, 550, 525,
    526, 524, 527, 529, 558, 544, 530, 531, 534, 528, 535, 559, 286, 546, 532,

    535, 547, 548, 523, 545, 560, 550, 561, 525, 526, 527, 256, 562, 529, 558, 530, 531,
    528, 534, 535, 536, 559, 532, 256, 535, 543, 551, 565, 551, 560, 256, 538, 561, 286,
    273, 286, 552, 562, 571, 572, 566, 301, 316, 545, 575, 286, 575, 301, 578, 301, 316,
    316, 567, 570, 576, 316, 256, 596, 568, 596, 286, 571, 573, 590, 544, 566, 592, 597,
    598, 301, 600, 574, 560, 608, 273, 256, 579, 567, 570, 581, 301, 581, 577, 568, 584,
    580, 590, 573, 544, 582, 551, 592, 551, 598, 574, 600, 560, 609, 608, 609,

    552, 579, 611, 286, 619, 577, 286, 610, 580, 584, 301, 301, 583, 538, 316, 316, 587,
    750, 617, 256, 617, 575, 286, 575, 643, 653, 616, 611, 618, 619, 626, 576, 316, 747,
    622, 746, 623, 316, 646, 633, 646, 727, 627, 630, 581, 301, 581, 634, 647, 643, 653,
    596, 743, 596, 582, 286, 650, 742, 650, 649, 623, 597, 658, 594, 658, 627, 651, 630,
    286, 661, 634, 641, 609, 606, 609, 664, 594, 664, 617, 256, 617, 301, 610, 594, 639,
    665, 621, 649, 618, 672, 256, 672, 680, 621, 301, 690, 687, 676, 646, 673,

    646, 688, 741, 650, 677, 650, 594, 316, 647, 694, 697, 694, 697, 651, 649, 680, 606,
    681, 740, 695, 690, 658, 594, 658, 661, 707, 286, 677, 700, 649, 700, 684, 606, 659,
    664, 708, 664, 649, 649, 661, 681, 672, 256, 672, 665, 316, 301, 676, 676, 738, 720,
    673, 720, 674, 684, 716, 316, 716, 718, 694, 721, 694, 710, 697, 649, 697, 700, 649,
    700, 695, 707, 715, 286, 707, 661, 301, 733, 661, 712, 705, 708, 698, 713, 708, 730,
    710, 734, 716, 316, 716, 729, 720, 659, 720, 744, 728, 744, 707, 727, 701,

    739, 721, 725, 733, 733, 713, 724, 708, 709, 735, 723, 733, 736, 734, 734, 753, 316,
    753, 744, 722, 744, 734, 753, 316, 753, 719, 717, 686, 715, 683, 712, 679, 735, 705,
    698, 736, 671, 701, 669, 703, 702, 663, 699, 731, 696, 693, 649, 692, 691, 689, 686,
    638, 636, 683, 632, 629, 679, 625, 717, 671, 669, 615, 667, 666, 663, 745, 657, 656,
    655, 654, 652, 649, 594, 642, 748, 586, 638, 636, 632, 629, 625, 615, 613, 612, 604,
    603, 754, 602, 601, 745, 599, 595, 594, 754, 167, 167, 188, 188, 188, 188,

    188, 188, 194, 194, 194, 194, 194, 194, 212, 212, 219, 219, 591, 219, 219, 219, 235,
    589, 235, 235, 240, 240, 240, 249, 586, 249, 249, 250, 250, 250, 255, 255, 255, 255,
    255, 255, 272, 272, 517, 272, 272, 272, 285, 285, 285, 285, 285, 285, 300, 300, 300,
    300, 300, 300, 315, 315, 315, 315, 315, 315, 415, 415, 415, 415, 415, 415, 462, 462,
    462, 462, 462, 462, 516, 516, 516, 516, 516, 516, 585, 585, 585, 585, 585, 585, 593,
    593, 593, 593, 593, 593, 605, 605, 605, 605, 605, 605, 614, 614, 614, 614,

    614, 614, 620, 620, 620, 620, 620, 620, 624, 624, 624, 624, 624, 624, 628, 628, 628,
    628, 628, 628, 631, 631, 631, 631, 631, 631, 635, 635, 635, 635, 635, 635, 637, 637,
    637, 637, 637, 637, 648, 648, 648, 648, 648, 648, 660, 660, 660, 660, 660, 660, 662,
    662, 662, 662, 662, 662, 668, 668, 668, 668, 668, 668, 670, 670, 670, 670, 670, 670,
    675, 675, 675, 675, 675, 675, 678, 678, 678, 678, 678, 678, 682, 682, 682, 682, 682,
    682, 685, 685, 685, 685, 685, 685, 704, 704, 704, 704, 704, 704, 706, 706,

    706, 706, 706, 706, 711, 711, 711, 711, 711, 711, 714, 714, 714, 714, 714, 714, 726,
    726, 726, 726, 726, 726, 732, 732, 732, 732, 732, 732, 737, 737, 737, 737, 737, 737,
    749, 749, 749, 749, 749, 749, 751, 751, 751, 751, 751, 751, 758, 758, 758, 758, 758,
    758, 762, 762, 762, 762, 762, 762, 774, 774, 774, 774, 774, 774, 564, 563, 545, 556,
    555, 554, 553, 549, 540, 504, 517, 513, 512, 503, 502, 501, 498, 493, 491, 416, 490,
    452, 451, 220, 359, 359, 357, 357, 431, 430, 429, 426, 419, 417, 416, 316,

    316, 316, 316, 301, 301, 301, 301, 286, 286, 286, 286, 273, 273, 273, 273, 256, 256,
    256, 256, 378, 377, 237, 220, 220, 220, 220, 355, 195, 191, 353, 352, 351, 342, 341,
    164, 316, 301, 286, 273, 256, 191, 191, 237, 220, 218, 217, 215, 211, 210, 209, 195,
    193, 187, 164, 781, 23,  781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,

    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781};

static yyconst flex_int16_t yy_chk[3131] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,

    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
    3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,

    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   9,   25,  9,   25,

    31,  9,   9,   10,  32,  10,  46,  60,  10,  10,  33,  38,  33,  9,   38,  47,  46,
    50,  49,  65,  10,  51,  61,  31,  47,  49,  51,  32,  50,  52,  60,  52,  73,  75,
    76,  87,  168, 90,  73,  90,  169, 102, 52,  122, 65,  61,  105, 112, 105, 122, 777,
    385, 87,  50,  133, 144, 75,  76,  102, 65,  168, 385, 224, 112, 169, 9,   25,  52,
    224, 776, 133, 144, 10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
    11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,

    11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
    11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,
    11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  13,  13,  13,  13,
    13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
    13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
    13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,

    13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,
    13,  13,  13,  13,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,
    15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,
    15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,
    15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,
    15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  17,  17,  17,  17,  17,

    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
    17,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,

    19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  21,  21,  21,  21,  21,  21,  21,  21,
    21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,
    21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,
    21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,

    21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,
    27,  35,  27,  35,  86,  27,  27,  28,  77,  28,  114, 186, 28,  28,  39,  774, 39,
    27,  88,  39,  39,  40,  538, 40,  28,  101, 40,  40,  70,  330, 70,  39,  80,  114,
    80,  88,  186, 78,  40,  70,  71,  404, 71,  587, 115, 71,  71,  72,  82,  72,  82,
    71,  72,  72,  83,  78,  83,  71,  72,  83,  83,  88,  124, 92,  72,  92,  77,  115,
    77,  27,  35,  83,  116, 86,  89,  103, 28,  34,  330, 34,  78,  104, 34,

    39,  88,  124, 331, 277, 538, 125, 40,  89,  103, 277, 101, 78,  135, 70,  104, 404,
    587, 80,  34,  136, 34,  146, 34,  772, 155, 71,  34,  34,  125, 34,  147, 89,  72,
    82,  103, 135, 157, 34,  104, 83,  155, 175, 136, 240, 146, 34,  34,  34,  92,  188,
    34,  34,  188, 147, 89,  331, 116, 103, 116, 157, 240, 104, 34,  74,  74,  175, 74,
    74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,
    74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,

    74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,
    74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,  74,
    74,  74,  74,  74,  84,  91,  84,  91,  137, 84,  84,  95,  97,  95,  97,  108, 108,
    108, 98,  126, 98,  84,  106, 98,  98,  99,  106, 99,  127, 148, 99,  99,  158, 159,
    91,  98,  162, 213, 91,  138, 214, 106, 99,  110, 110, 110, 127, 178, 110, 110, 235,
    106, 111, 111, 111, 158, 162, 111, 111, 91,  110, 213, 91,  138, 214, 222,

    106, 138, 483, 111, 178, 127, 138, 84,  91,  162, 137, 126, 137, 126, 95,  97,  176,
    222, 108, 247, 127, 98,  138, 176, 771, 176, 138, 182, 99,  182, 138, 148, 250, 148,
    162, 159, 769, 159, 203, 591, 203, 138, 222, 203, 247, 591, 110, 176, 176, 250, 768,
    182, 182, 235, 483, 111, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
    113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
    113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,

    113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
    113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 113, 117, 117, 117, 119,
    120, 119, 120, 149, 249, 120, 120, 121, 226, 121, 119, 120, 121, 121, 177, 183, 270,
    120, 121, 177, 177, 183, 202, 206, 121, 117, 261, 149, 207, 117, 207, 149, 226, 202,
    206, 767, 149, 227, 264, 177, 183, 207, 261, 177, 183, 270, 208, 290, 208, 336, 117,
    208, 149, 117, 462, 265, 149, 520, 202, 206, 149, 227, 264, 290, 462, 117,

    207, 520, 119, 120, 270, 149, 766, 249, 336, 765, 121, 123, 123, 265, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    129, 129, 129, 131, 131, 131, 230, 241, 131, 131, 132, 132, 132, 242, 407,

    132, 132, 166, 251, 166, 131, 275, 337, 216, 241, 216, 296, 132, 279, 230, 242, 230,
    246, 764, 246, 251, 280, 292, 241, 275, 338, 293, 305, 307, 242, 337, 166, 216, 216,
    251, 166, 296, 279, 230, 230, 343, 246, 246, 305, 321, 280, 292, 241, 338, 275, 293,
    762, 307, 242, 129, 761, 166, 131, 251, 166, 321, 296, 407, 343, 132, 134, 134, 134,
    134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,
    134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,

    134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,
    134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134, 134,
    134, 134, 134, 134, 134, 140, 140, 140, 142, 142, 142, 252, 269, 142, 142, 143, 143,
    143, 273, 308, 143, 143, 172, 298, 172, 142, 324, 346, 252, 325, 339, 557, 143, 283,
    345, 760, 335, 349, 335, 340, 354, 557, 252, 308, 350, 269, 758, 269, 360, 361, 324,
    172, 346, 325, 339, 172, 283, 345, 283, 298, 335, 335, 349, 340, 340, 354,

    252, 350, 757, 269, 269, 360, 361, 569, 140, 172, 172, 142, 273, 172, 283, 283, 298,
    569, 143, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145,
    145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145,
    145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145,
    145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145,
    145, 145, 145, 145, 145, 145, 145, 145, 151, 151, 151, 153, 153, 153, 288,

    297, 153, 153, 154, 154, 154, 322, 362, 154, 154, 233, 311, 233, 153, 268, 268, 268,
    365, 366, 369, 154, 368, 372, 288, 755, 418, 373, 288, 380, 421, 362, 381, 288, 297,
    322, 297, 311, 386, 368, 233, 365, 366, 427, 233, 369, 387, 372, 268, 288, 373, 418,
    380, 288, 421, 381, 754, 288, 297, 297, 322, 386, 311, 151, 368, 233, 153, 427, 233,
    387, 751, 749, 268, 154, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156,
    156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156,

    156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156,
    156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156,
    156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 156, 160, 160, 160, 161,
    163, 161, 163, 164, 185, 164, 185, 408, 164, 164, 190, 191, 190, 191, 487, 747, 191,
    191, 506, 383, 164, 204, 220, 204, 220, 160, 204, 204, 191, 221, 223, 221, 223, 220,
    390, 223, 223, 232, 204, 232, 221, 223, 234, 236, 234, 236, 383, 223, 160,

    160, 160, 492, 248, 237, 248, 237, 313, 390, 237, 237, 441, 408, 239, 487, 239, 160,
    521, 367, 161, 163, 237, 383, 164, 185, 245, 492, 245, 441, 506, 190, 191, 257, 257,
    257, 258, 258, 258, 259, 259, 259, 204, 239, 313, 220, 274, 239, 274, 367, 221, 223,
    262, 262, 262, 245, 391, 274, 232, 245, 287, 287, 287, 234, 236, 258, 379, 313, 239,
    258, 746, 239, 367, 248, 237, 302, 302, 302, 521, 391, 245, 262, 745, 245, 396, 262,
    260, 260, 260, 743, 258, 260, 260, 258, 276, 379, 276, 742, 420, 276, 276,

    312, 257, 260, 303, 276, 262, 396, 259, 262, 424, 276, 317, 317, 317, 274, 289, 289,
    289, 329, 379, 289, 289, 420, 558, 304, 304, 304, 303, 287, 304, 304, 303, 289, 312,
    424, 312, 303, 318, 318, 318, 410, 304, 410, 302, 319, 319, 319, 328, 328, 328, 410,
    329, 303, 329, 260, 740, 303, 312, 312, 332, 303, 363, 276, 363, 370, 371, 318, 382,
    320, 320, 320, 737, 363, 320, 320, 329, 329, 334, 375, 334, 317, 370, 371, 558, 289,
    320, 347, 605, 347, 318, 318, 318, 332, 304, 332, 375, 347, 605, 376, 328,

    328, 328, 736, 756, 370, 371, 334, 382, 392, 756, 334, 425, 388, 319, 347, 376, 332,
    332, 375, 374, 393, 374, 347, 384, 384, 384, 389, 370, 371, 374, 382, 334, 363, 384,
    334, 394, 425, 320, 376, 347, 397, 375, 388, 389, 392, 347, 399, 374, 395, 398, 400,
    384, 401, 405, 406, 374, 402, 403, 442, 384, 393, 376, 394, 397, 464, 388, 413, 392,
    389, 409, 435, 428, 374, 432, 464, 442, 384, 400, 374, 402, 403, 406, 384, 393, 395,
    398, 399, 394, 401, 413, 422, 439, 422, 405, 428, 435, 409, 432, 444, 438,

    422, 443, 400, 447, 432, 448, 406, 395, 398, 399, 440, 401, 440, 439, 449, 450, 405,
    438, 456, 457, 440, 409, 461, 444, 443, 445, 460, 445, 447, 467, 448, 449, 450, 472,
    464, 445, 468, 439, 453, 453, 453, 471, 438, 458, 458, 458, 456, 467, 453, 461, 474,
    457, 473, 458, 460, 477, 489, 514, 468, 479, 478, 472, 480, 485, 493, 484, 494, 486,
    488, 524, 507, 456, 467, 495, 461, 457, 496, 497, 529, 460, 471, 489, 468, 499, 473,
    473, 472, 474, 478, 507, 494, 479, 479, 484, 477, 485, 508, 523, 495, 480,

    488, 496, 497, 471, 494, 509, 499, 510, 473, 473, 474, 515, 511, 478, 507, 479, 479,
    477, 484, 485, 486, 508, 480, 518, 488, 493, 500, 514, 500, 509, 519, 488, 510, 525,
    522, 526, 500, 511, 523, 524, 515, 528, 534, 509, 527, 527, 527, 530, 529, 531, 533,
    537, 518, 522, 527, 535, 566, 547, 519, 547, 573, 523, 525, 541, 539, 515, 544, 547,
    548, 579, 550, 526, 559, 560, 570, 568, 530, 518, 522, 532, 532, 532, 528, 519, 535,
    531, 541, 525, 539, 532, 551, 544, 551, 548, 526, 550, 559, 561, 560, 561,

    551, 530, 562, 571, 568, 528, 574, 561, 531, 535, 577, 580, 534, 533, 584, 588, 537,
    735, 567, 567, 567, 575, 575, 575, 590, 600, 566, 562, 567, 568, 573, 575, 640, 730,
    570, 729, 571, 641, 592, 579, 592, 726, 574, 577, 581, 581, 581, 580, 592, 590, 600,
    596, 725, 596, 581, 627, 598, 724, 598, 607, 571, 596, 606, 606, 606, 574, 598, 577,
    623, 607, 580, 588, 609, 606, 609, 611, 620, 611, 617, 617, 617, 630, 609, 621, 584,
    611, 620, 622, 617, 619, 619, 619, 627, 621, 634, 643, 640, 622, 646, 619,

    646, 641, 722, 650, 623, 650, 659, 688, 646, 653, 656, 653, 656, 650, 660, 627, 659,
    630, 719, 653, 643, 658, 658, 658, 660, 674, 677, 623, 661, 661, 661, 634, 658, 606,
    664, 674, 664, 675, 676, 661, 630, 672, 672, 672, 664, 718, 681, 675, 676, 717, 690,
    672, 690, 621, 634, 687, 687, 687, 688, 694, 690, 694, 677, 697, 701, 697, 700, 700,
    700, 694, 706, 714, 710, 708, 701, 713, 709, 700, 711, 704, 706, 656, 681, 708, 703,
    677, 709, 716, 716, 716, 702, 720, 658, 720, 728, 699, 728, 731, 698, 661,

    718, 720, 696, 732, 734, 681, 693, 731, 676, 710, 692, 748, 713, 732, 734, 739, 739,
    739, 744, 691, 744, 748, 753, 753, 753, 689, 687, 685, 684, 682, 680, 678, 710, 673,
    697, 713, 670, 700, 668, 667, 666, 662, 657, 708, 655, 652, 648, 645, 644, 642, 639,
    637, 635, 633, 631, 628, 626, 624, 716, 618, 616, 614, 613, 612, 608, 728, 604, 603,
    602, 601, 599, 595, 593, 589, 734, 585, 583, 582, 578, 576, 572, 565, 564, 563, 556,
    555, 739, 554, 553, 744, 549, 546, 545, 753, 782, 782, 783, 783, 783, 783,

    783, 783, 784, 784, 784, 784, 784, 784, 785, 785, 786, 786, 542, 786, 786, 786, 787,
    540, 787, 787, 788, 788, 788, 789, 536, 789, 789, 790, 790, 790, 791, 791, 791, 791,
    791, 791, 792, 792, 516, 792, 792, 792, 793, 793, 793, 793, 793, 793, 794, 794, 794,
    794, 794, 794, 795, 795, 795, 795, 795, 795, 796, 796, 796, 796, 796, 796, 797, 797,
    797, 797, 797, 797, 798, 798, 798, 798, 798, 798, 799, 799, 799, 799, 799, 799, 800,
    800, 800, 800, 800, 800, 801, 801, 801, 801, 801, 801, 802, 802, 802, 802,

    802, 802, 803, 803, 803, 803, 803, 803, 804, 804, 804, 804, 804, 804, 805, 805, 805,
    805, 805, 805, 806, 806, 806, 806, 806, 806, 807, 807, 807, 807, 807, 807, 808, 808,
    808, 808, 808, 808, 809, 809, 809, 809, 809, 809, 810, 810, 810, 810, 810, 810, 811,
    811, 811, 811, 811, 811, 812, 812, 812, 812, 812, 812, 813, 813, 813, 813, 813, 813,
    814, 814, 814, 814, 814, 814, 815, 815, 815, 815, 815, 815, 816, 816, 816, 816, 816,
    816, 817, 817, 817, 817, 817, 817, 818, 818, 818, 818, 818, 818, 819, 819,

    819, 819, 819, 819, 820, 820, 820, 820, 820, 820, 821, 821, 821, 821, 821, 821, 822,
    822, 822, 822, 822, 822, 823, 823, 823, 823, 823, 823, 824, 824, 824, 824, 824, 824,
    825, 825, 825, 825, 825, 825, 826, 826, 826, 826, 826, 826, 827, 827, 827, 827, 827,
    827, 828, 828, 828, 828, 828, 828, 829, 829, 829, 829, 829, 829, 513, 512, 505, 504,
    503, 502, 501, 498, 491, 490, 459, 452, 451, 431, 430, 429, 426, 419, 417, 415, 414,
    378, 377, 364, 359, 358, 357, 356, 353, 352, 351, 348, 344, 342, 341, 333,

    327, 326, 315, 314, 310, 309, 300, 299, 295, 294, 285, 284, 282, 281, 272, 271, 267,
    266, 255, 254, 253, 238, 231, 229, 228, 219, 196, 194, 192, 181, 180, 179, 174, 173,
    165, 150, 139, 128, 118, 107, 100, 93,  85,  69,  67,  66,  64,  57,  56,  55,  43,
    42,  37,  29,  23,  781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,

    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781};

static yyconst flex_int16_t yy_rule_linenum[107] = {
    0,   125, 126, 127, 128, 129, 134, 136, 137, 138, 139, 140, 141, 143, 144, 146, 152,
    243, 267, 273, 294, 301, 312, 317, 331, 336, 343, 366, 377, 379, 393, 407, 422, 432,
    457, 463, 468, 473, 478, 488, 496, 504, 513, 541, 562, 563, 564, 565, 567, 572, 597,
    599, 601, 646, 647, 650, 652, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670,
    671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687,
    688, 689, 690, 691, 692, 693, 694, 695, 696, 702, 708, 720, 746, 748, 750, 767,

    783, 784, 794, 797, 798, 800};

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT      reject_used_but_not_detected
#define yymore()    yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
/*
 * Copyright(C) 1999-2025 National Technology & Engineering Solutions
 * of Sandia, LLC (NTESS).  Under the terms of Contract DE-NA0003525 with
 * NTESS, the U.S. Government retains certain rights in this software.
 *
 * See packages/seacas/LICENSE for details
 */

#include <assert.h>
#include <fcntl.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <stack>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "apr_getline.h"
#include "apr_scanner.h"
#include "apr_tokenize.h"
#include "apr_util.h"
#include "aprepro.h"
#include "fmt/format.h"
#include "fmt/ostream.h"
#include "fmt/ranges.h"

#define YY_NO_UNISTD_H
/* import the parser's token type into a local typedef */
typedef SEAMS::Parser::token      token;
typedef SEAMS::Parser::token_type token_type;

/* By default yylex returns int, we use token_type. Unfortunately yyterminate
 * by default returns 0, which is not of token_type. */
#define yyterminate() return token::END

namespace SEAMS {
  extern bool echo;
  void        yyerror(const char *s);
} // namespace SEAMS

namespace {
  bool begin_double_brace = false;
  bool end_double_brace   = false;
  bool string_is_ascii(const char *line, size_t len)
  {
    for (size_t i = 0; i < len; i++) {
      if (!(std::isspace(static_cast<unsigned char>(line[i])) ||
            std::isprint(static_cast<unsigned char>(line[i])))) {
        return false;
      }
    }
    return true;
  }
} // namespace

int file_must_exist = 0; /* Global used by include/conditional include */

/* Global variables used by the looping mechanism */
SEAMS::file_rec *outer_file = nullptr;
int              loop_lvl   = 0;
std::fstream    *tmp_file;
const char      *temp_f;

#if defined __NVCC__
#pragma diag_suppress code_is_unreachable
#endif

#define MAX_IF_NESTING 1024

int    if_state[MAX_IF_NESTING]    = {0};     // INITIAL
int    if_case_run[MAX_IF_NESTING] = {false}; /* Has any if or elseif condition executed */
int    if_lvl                      = 0;
int    if_skip_level               = 0;
bool   suppress_nl                 = false;
bool   switch_active               = false; // Are we in a switch
bool   switch_case_run             = false; // has there been a case which matched condition run?
bool   switch_skip_to_endcase      = false;
double switch_condition            = 0.0; // Value specified in "switch(condition)"

// For substitution history
int         curr_index = 0;
std::string history_string;
size_t      hist_start = 0;

#define YY_USER_ACTION curr_index += yyleng;

/*** Flex Declarations and Options ***/
/* enable c++ scanner class generation */
/* change the name of the scanner class. results in "SEAMSFlexLexer" */
/* enable scanner to generate debug output. disable this for release
 * versions. */
/* enables the use of start condition stacks */

#define INITIAL       0
#define PARSING       1
#define GET_FILENAME  2
#define IF_SKIP       3
#define GET_VAR       4
#define VERBATIM      5
#define IF_WHILE_SKIP 6
#define GET_LOOP_VAR  7
#define LOOP          8
#define LOOP_SKIP     9
#define END_CASE_SKIP 10

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
#include <unistd.h>
/* %endif */
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

/* %if-c-only Reentrant structure and macros (non-C++). */
/* %if-reentrant */
/* %if-c-only */
/* %endif */
/* %if-reentrant */
/* %endif */
/* %endif End reentrant structures and macros. */
/* %if-bison-bridge */
/* %endif */
/* %not-for-header */

/* %ok-for-header */

/* %endif */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *, yyconst char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(yyconst char *);
#endif

#ifndef YY_NO_INPUT
/* %if-c-only Standard (non-C++) definition */
/* %not-for-header */

/* %ok-for-header */

/* %endif */
#endif

/* %if-c-only */
/* %endif */

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* %if-c-only Standard (non-C++) definition */
/* %endif */
/* %if-c++-only C++ definition */
#define ECHO LexerOutput(yytext, yyleng)
/* %endif */
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                            \
  /* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ */          \
                                                                                                   \
  /* %if-c++-only C++ definition \ */                                                              \
  if ((result = LexerInput((char *)buf, max_size)) < 0)                                            \
    YY_FATAL_ERROR("input in flex scanner failed");
/* %endif */

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
/* %if-c-only */
/* %endif */
/* %if-c++-only */
#define YY_FATAL_ERROR(msg) LexerError(msg)
/* %endif */
#endif

/* %if-tables-serialization structures and prototypes */
/* %not-for-header */

/* %ok-for-header */

/* %not-for-header */

/* %tables-yydmap generated elements */
/* %endif */
/* end tables serialization structures and prototypes */

/* %ok-for-header */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1
/* %if-c-only Standard (non-C++) definition */
/* %endif */
/* %if-c++-only C++ definition */
#define YY_DECL int yyFlexLexer::yylex()
/* %endif */
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

/* %% [6.0] YY_RULE_SETUP definition goes here */
#define YY_RULE_SETUP YY_USER_ACTION

/* %not-for-header */

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char         *yy_cp, *yy_bp;
  int           yy_act;

  if (!(yy_init)) {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start))
      (yy_start) = 1; /* first start state */

    if (!yyin)
      /* %if-c-only */
      /* %endif */
      /* %if-c++-only */
      yyin = &std::cin;
    /* %endif */

    if (!yyout)
      /* %if-c-only */
      /* %endif */
      /* %if-c++-only */
      yyout = &std::cout;
    /* %endif */

    if (!YY_CURRENT_BUFFER) {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  {
    /* %% [7.0] user's declarations go here */

    while (1) /* loops until end-of-file is reached */
    {
      /* %% [8.0] yymore()-related code goes here */
      yy_cp = (yy_c_buf_p);

      /* Support of yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      /* %% [9.0] code to set up and find next match goes here */
      yy_current_state = (yy_start);
    yy_match:
      do {
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state]) {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos)  = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 782)
            yy_c = yy_meta[(unsigned int)yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
        ++yy_cp;
      } while (yy_base[yy_current_state] != 3056);

    yy_find_action:
      /* %% [10.0] code to find the action number goes here */
      yy_act = yy_accept[yy_current_state];
      if (yy_act == 0) { /* have to back up */
        yy_cp            = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act           = yy_accept[yy_current_state];
      }

      YY_DO_BEFORE_ACTION;

      /* %% [11.0] code for yylineno update goes here */

    do_action: /* This label is used only to access EOF actions. */

      /* %% [12.0] debug code goes here */
      if (yy_flex_debug) {
        if (yy_act == 0)
          std::cerr << "--scanner backing up\n";
        else if (yy_act < 107)
          std::cerr << "--accepting rule at line " << yy_rule_linenum[yy_act] << "(\"" << yytext
                    << "\")\n";
        else if (yy_act == 107)
          std::cerr << "--accepting default rule (\"" << yytext << "\")\n";
        else if (yy_act == 108)
          std::cerr << "--(end of buffer or a NUL)\n";
        else
          std::cerr << "--EOF (start condition " << YY_START << ")\n";
      }

      switch (yy_act) { /* beginning of action switch */
                        /* %% [13.0] actions go here */
      case 0:           /* must back up */
        /* undo the effects of YY_DO_BEFORE_ACTION */
        *yy_cp           = (yy_hold_char);
        yy_cp            = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        goto yy_find_action;

      case 1:
        YY_RULE_SETUP { BEGIN(INITIAL); }
        YY_BREAK
      case 2:
        /* rule 2 can match eol */
        YY_RULE_SETUP
        {
          echo = true;
          BEGIN(INITIAL);
        }
        YY_BREAK
      case 3:
      case 4:
        YY_RULE_SETUP
        {
          if (echo)
            ECHO;
        }
        YY_BREAK
      case 5:
        /* rule 5 can match eol */
        YY_RULE_SETUP
        {
          if (echo)
            ECHO;
          aprepro.ap_file_list.top().lineno++;
        }
        YY_BREAK

      /* Aprepro "comment" -- skip entire line */
      case 6:
        /* rule 6 can match eol */
        YY_RULE_SETUP
        {
          yytext++;
          yytext[1] = ' ';
          if (echo)
            ECHO;
          aprepro.ap_file_list.top().lineno++;
        }
        YY_BREAK
      case 7:
        YY_RULE_SETUP { BEGIN(VERBATIM); }
        YY_BREAK
      case 8:
        YY_RULE_SETUP
        {
          echo = false;
          BEGIN(VERBATIM);
        }
        YY_BREAK
      case 9:
      case 10:
        YY_RULE_SETUP { echo = true; }
        YY_BREAK
      case 11:
      case 12:
        YY_RULE_SETUP { echo = false; }
        YY_BREAK
      case 13:
        YY_RULE_SETUP { aprepro.stateImmutable = true; }
        YY_BREAK
      case 14:
        YY_RULE_SETUP { aprepro.stateImmutable = aprepro.ap_options.immutable; }
        YY_BREAK
      case 15:
        YY_RULE_SETUP { BEGIN(GET_LOOP_VAR); }
        YY_BREAK

      case 16:
        /* rule 16 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          /* `yytext` includes closing `)}` and newline...  Strip these */
          char *pt    = strchr(yytext, ')');
          *pt         = '\0';
          auto tokens = tokenize(yytext, " ,\t");
          if (aprepro.ap_options.debugging) {
            fmt::print(stderr, "DEBUG LOOP: tokens = {}\n", fmt::join(tokens, ", "));
          }

          /* Determine if the first token is a symbol or an explicit number... */
          const auto &count           = tokens[0];
          bool        all_dig         = count.find_first_not_of("0123456789") == std::string::npos;
          int         loop_iterations = 0;
          if (all_dig) {
            loop_iterations = std::stoi(count);
          }
          else {
            symrec *s;
            if (!check_valid_var(tokens[0].c_str())) {
              aprepro.warning("Invalid variable name syntax '" + tokens[0] + "'");
              BEGIN(LOOP_SKIP);
            }
            else {
              s = aprepro.getsym(tokens[0]);
              if (s == nullptr ||
                  (s->type != token::SVAR && s->type != token::IMMSVAR && s->value.var == 0.)) {
                BEGIN(LOOP_SKIP);
              }
              else {
                loop_iterations = (int)s->value.var;
              }
            }
          }

          if (loop_iterations <= 0) {
            BEGIN(LOOP_SKIP);
            if (aprepro.ap_options.debugging) {
              fmt::print(stderr, "DEBUG LOOP: iteration count = {}, Skipping loop...\n",
                         loop_iterations);
            }
          }
          else {
            temp_f = get_temp_filename();
            SEAMS::file_rec new_file(temp_f, 0, true, loop_iterations);
            outer_file          = &aprepro.ap_file_list.top();
            new_file.loop_level = outer_file->loop_level + 1;

            // Get optional loop index...
            std::string sym_name;
            if (tokens.size() == 1) {
              // Default loop index variable name if not specified in loop command.
              sym_name = fmt::format("__loop_{}", new_file.loop_level);
            }
            else {
              sym_name = tokens[1];
            }
            SEAMS::symrec *li = aprepro.getsym(sym_name);
            if (li == nullptr) {
              li = aprepro.putsym(sym_name, SEAMS::Aprepro::SYMBOL_TYPE::VARIABLE, true);
            }

            // Get optional loop index initial value.  Default to 0 if not specified.
            double init = 0.0;
            if (tokens.size() >= 3) {
              init = std::stod(tokens[2]);
            }
            li->value.var = init;

            // Get optional loop index increment value.  Default to 1 if not specified.
            if (tokens.size() >= 4) {
              double increment        = std::stod(tokens[3]);
              new_file.loop_increment = increment;
            }

            new_file.loop_index = li;
            aprepro.ap_file_list.push(new_file);

            tmp_file = new std::fstream(temp_f, std::ios::out);
            loop_lvl++;
            BEGIN(LOOP);
            aprepro.isCollectingLoop = true;
            if (aprepro.ap_options.debugging) {
              fmt::print(stderr,
                         "DEBUG LOOP: iteration count = {}, loop_index variable = {}, initial "
                         "value = {}, increment = {}\n",
                         loop_iterations, sym_name, init, new_file.loop_increment);
            }
          }
        }
        YY_BREAK

      case 17:
        /* rule 17 can match eol */
        YY_RULE_SETUP
        {
          outer_file->lineno++;
          if (loop_lvl > 0)
            --loop_lvl;

          if (loop_lvl == 0) {
            BEGIN(INITIAL);
            tmp_file->close();
            delete tmp_file;

            if (!aprepro.doLoopSubstitution)
              yy_push_state(VERBATIM);

            aprepro.isCollectingLoop = false;

            yyin = aprepro.open_file(aprepro.ap_file_list.top().name, "r");
            yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(yyin, YY_BUF_SIZE));
            curr_index = 0;
          }
          else {
            (*tmp_file) << yytext;
          }
        }
        YY_BREAK
      case 18:
        /* rule 18 can match eol */
        YY_RULE_SETUP
        {
          loop_lvl++; /* Nested Loop */
          (*tmp_file) << yytext;
          outer_file->lineno++;
        }
        YY_BREAK
      case 19:
        /* rule 19 can match eol */
        YY_RULE_SETUP
        {
          if (aprepro.ap_options.interactive || aprepro.string_interactive()) {
            aprepro.warning("Aborting loop(s).", false);

            // Leave the looping state and remove the loop file
            BEGIN(INITIAL);
            tmp_file->close();
            delete tmp_file;

            if (aprepro.ap_file_list.top().tmp_file) {
              remove(aprepro.ap_file_list.top().name.c_str());
              aprepro.ap_file_list.pop();
            }

            loop_lvl                 = 0;
            aprepro.isCollectingLoop = false;
          }
        }
        YY_BREAK
      case 20:
        /* rule 20 can match eol */
        YY_RULE_SETUP
        {
          (*tmp_file) << yytext;
          outer_file->lineno++;
        }
        YY_BREAK

      case 21:
        /* rule 21 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          if (loop_lvl > 0)
            --loop_lvl;

          if (loop_lvl == 0) {
            BEGIN(INITIAL);
            aprepro.isCollectingLoop = false;
          }
        }
        YY_BREAK
      case 22:
        /* rule 22 can match eol */
        YY_RULE_SETUP
        {
          loop_lvl++; /* Nested Loop */
          aprepro.ap_file_list.top().lineno++;
        }
        YY_BREAK
      case 23:
        /* rule 23 can match eol */
        YY_RULE_SETUP
        {
          if (aprepro.ap_options.interactive || aprepro.string_interactive()) {
            aprepro.warning("Aborting loops(s).", false);

            // Leave the looping state
            BEGIN(INITIAL);

            loop_lvl                 = 0;
            aprepro.isCollectingLoop = false;
          }
        }
        YY_BREAK
      case 24:
        /* rule 24 can match eol */
        YY_RULE_SETUP { /* Do not increment line count */ ; }
        YY_BREAK

      case 25:
        /* rule 25 can match eol */
        YY_RULE_SETUP
        {
          yyless(0);
          curr_index = 0;
          BEGIN(INITIAL);
          switch_skip_to_endcase = false;
        }
        YY_BREAK
      case 26:
        /* rule 26 can match eol */
        YY_RULE_SETUP
        {
          if (!switch_active) {
            yyerror("default statement found outside switch statement.");
          }

          if (!switch_case_run) {
            switch_case_run = true;
            BEGIN(INITIAL);
            switch_skip_to_endcase = false;
            if (aprepro.ap_options.debugging)
              fprintf(stderr, "DEBUG SWITCH: 'default' code executing at line %d\n",
                      aprepro.ap_file_list.top().lineno);
          }
          else {
            if (aprepro.ap_options.debugging)
              fprintf(stderr,
                      "DEBUG SWITCH: 'default' not executing since a previous case already ran at "
                      "line %d\n",
                      aprepro.ap_file_list.top().lineno);

            /* Need to skip all code until end of case */
            BEGIN(END_CASE_SKIP);
          }
        }
        YY_BREAK
      case 27:
        /* rule 27 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          BEGIN(INITIAL);
          switch_active          = false;
          switch_skip_to_endcase = false;
          suppress_nl            = false;
          if (aprepro.ap_options.debugging)
            fprintf(stderr, "DEBUG SWITCH: 'endswitch' at line %d\n",
                    aprepro.ap_file_list.top().lineno);
        }
        YY_BREAK
      case 28:
        /* rule 28 can match eol */
        YY_RULE_SETUP { aprepro.ap_file_list.top().lineno++; }
        YY_BREAK
      case 29:
        /* rule 29 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          if (!switch_active) {
            yyerror("endswitch statement found without matching switch.");
          }
          switch_active          = false;
          switch_skip_to_endcase = false;
        }
        YY_BREAK

      /* This restores the old behavior of ifdef and ifndef
       * where they would eat up any leading whitespace on
       * a line.
       */
      case 30:
        YY_RULE_SETUP
        {
          // Used to avoid undefined variable warnings in old ifdef/ifndef construct
          aprepro.inIfdefGetvar = true;
          unput('(');
          unput('f');
          unput('e');
          unput('d');
          unput('f');
          unput('i');
          unput('_');
          unput('{');
          curr_index = 0;
        }
        YY_BREAK
      case 31:
        YY_RULE_SETUP
        {
          // Used to avoid undefined variable warnings in old ifdef/ifndef construct
          aprepro.inIfdefGetvar = true;
          unput('(');
          unput('f');
          unput('e');
          unput('d');
          unput('n');
          unput('f');
          unput('i');
          unput('_');
          unput('{');
          curr_index = 0;
        }
        YY_BREAK
      case 32:
        YY_RULE_SETUP
        {
          // This lets us strip leading optional '#' and spaces
          unput('(');
          unput('f');
          unput('i');
          unput('_');
          unput('{');
          curr_index = 0;
        }
        YY_BREAK
      case 33:
        YY_RULE_SETUP
        {
          // This lets us strip leading optional '#' and spaces
          unput('(');
          unput('f');
          unput('i');
          unput('e');
          unput('s');
          unput('l');
          unput('e');
          unput('_');
          unput('{');
          curr_index = 0;
        }
        YY_BREAK

      /* If an if was found while skipping, then eat
       * that entire if block until endif
       * found since there is no way that
       * any of the code in that if block could be executed.
       * Make sure to handle multiple levels of skipped ifs...
       *
       * NOTE: if_lvl was not incremented, so don't need to decrement when
       *       endif found.
       */
      case 34:
        /* rule 34 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          if (--if_skip_level == 0)
            BEGIN(IF_SKIP);
        }
        YY_BREAK
      case 35:
        /* rule 35 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          if_skip_level++;
        }
        YY_BREAK
      case 36:
        /* rule 36 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          if_skip_level++;
        }
        YY_BREAK
      case 37:
        /* rule 37 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          if_skip_level++;
        }
        YY_BREAK
      case 38:
        /* rule 38 can match eol */
        YY_RULE_SETUP { aprepro.ap_file_list.top().lineno++; }
        YY_BREAK

      /* IF an if, ifdef, or ifndef found while skipping, then
       * skip the entire block up and including the endif.
       * The (IF_WHILE_SKIP) start condition handles this skipping.
       */
      case 39:
        YY_RULE_SETUP
        {
          if (aprepro.ap_options.debugging)
            fprintf(stderr, "DEBUG IF: 'ifdef'  found while skipping at line %d\n",
                    aprepro.ap_file_list.top().lineno);
          if_skip_level = 1;
          BEGIN(IF_WHILE_SKIP);
        }
        YY_BREAK
      case 40:
        YY_RULE_SETUP
        {
          if (aprepro.ap_options.debugging)
            fprintf(stderr, "DEBUG IF: 'if'  found while skipping at line %d\n",
                    aprepro.ap_file_list.top().lineno);
          if_skip_level = 1;
          BEGIN(IF_WHILE_SKIP);
        }
        YY_BREAK
      case 41:
        YY_RULE_SETUP
        {
          if (aprepro.ap_options.debugging)
            fprintf(stderr, "DEBUG IF: 'ifndef'  found while skipping at line %d\n",
                    aprepro.ap_file_list.top().lineno);
          if_skip_level = 1;
          BEGIN(IF_WHILE_SKIP);
        }
        YY_BREAK

      case 42:
        /* rule 42 can match eol */
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          if (aprepro.ap_options.debugging)
            fprintf(stderr, "DEBUG IF: 'else'   at level = %d at line %d\n", if_lvl,
                    aprepro.ap_file_list.top().lineno);
          if (YY_START == VERBATIM) {
            if (echo)
              ECHO;
          }
          else if (if_state[if_lvl] == IF_SKIP) {
            if (!if_case_run[if_lvl]) {
              BEGIN(INITIAL);
              if_state[if_lvl]    = INITIAL;
              if_case_run[if_lvl] = true;
            }
            else {
              BEGIN(IF_SKIP);
              if_state[if_lvl] = IF_SKIP;
            }
          }
          else if (if_state[if_lvl] == INITIAL) {
            BEGIN(IF_SKIP);
            if_state[if_lvl] = IF_SKIP;
          }

          /* If neither is true, this is a nested
             if that should be skipped */
        }
        YY_BREAK

      case 43:
        /* rule 43 can match eol */
        YY_RULE_SETUP
        {
          /* If any previous 'block' of this if has executed, then
           * just skip this block; otherwise see if condition is
           * true and execute this block
           */
          if (aprepro.ap_options.debugging)
            fprintf(stderr, "DEBUG IF: 'elseif'   at level = %d at line %d\n", if_lvl,
                    aprepro.ap_file_list.top().lineno);

          if (if_case_run[if_lvl]) { /* A previous else/elseif has run */
            aprepro.ap_file_list.top().lineno++;
            /* Already in IF_SKIP, so don't need to change state */
          }
          else {
            /* Need to check the elseif condition; push back and parse */
            yyless(0);
            curr_index = 0;
            BEGIN(INITIAL);
            if_state[if_lvl] = INITIAL;
          }
        }
        YY_BREAK
      case 44:
      case 45:
      case 46:
      case 47:
        YY_RULE_SETUP { ; }
        YY_BREAK
      case 48:
        /* rule 48 can match eol */
        YY_RULE_SETUP { aprepro.ap_file_list.top().lineno++; }
        YY_BREAK

      case 49:
        /* rule 49 can match eol */
        YY_RULE_SETUP
        {

          if (YY_START == VERBATIM) {
            if (echo)
              ECHO;
          }
          else {
            if (if_state[if_lvl] == IF_SKIP || if_state[if_lvl] == INITIAL) {
              BEGIN(INITIAL);
              suppress_nl = false;
            }
            /* If neither is true, this is a nested
               if that should be skipped */
            if (aprepro.ap_options.debugging)
              printf("DEBUG IF: 'endif'  at level = %d at line %d\n", if_lvl,
                     aprepro.ap_file_list.top().lineno);
            if (--if_lvl < 0) {
              if_lvl = 0;
              yyerror("Improperly Nested ifdef/ifndef statements");
            }
            /* Ignore endif if not skipping */
          }
          aprepro.ap_file_list.top().lineno++;
        }
        YY_BREAK
      case 50:
        YY_RULE_SETUP
        {
          BEGIN(GET_FILENAME);
          file_must_exist = true;
        }
        YY_BREAK
      case 51:
        YY_RULE_SETUP
        {
          BEGIN(GET_FILENAME);
          file_must_exist = false;
        }
        YY_BREAK
      case 52:
        YY_RULE_SETUP
        {
          aprepro.ap_file_list.top().lineno++;
          BEGIN(INITIAL);
          {
            symrec *s;
            int     quoted = 0;
            char   *pt     = strchr(yytext, ')');
            *pt            = '\0';
            /* Check to see if surrounded by double quote */
            if (aprepro.ap_options.debugging) {
              fmt::print(stderr, "DEBUG GET_FILENAME: yytext = '{}'\n", yytext);
            }
            if ((pt = strchr(yytext, '"')) != nullptr) {
              yytext++;
              quoted = 1;
            }
            if ((pt = strrchr(yytext, '"')) != nullptr) {
              *pt    = '\0';
              quoted = 1;
            }

            if (quoted == 0) {
              /* See if this is an aprepro variable referring to a name */
              s = aprepro.getsym(yytext);
              if (s == nullptr || (s->type != token::SVAR && s->type != token::IMMSVAR)) {
                pt = yytext;
              }
              else {
                pt = (char *)s->value.svar.c_str();
              }
            }
            else {
              pt = yytext;
            }

            if (aprepro.ap_options.debugging) {
              fmt::print(stderr, "DEBUG GET_FILENAME: filename = '{}'\n", pt);
            }
            bool added = add_include_file(pt, file_must_exist);

            if (added && !aprepro.doIncludeSubstitution)
              yy_push_state(VERBATIM);

            aprepro.ap_file_list.top().lineno++;
          }
        }
        YY_BREAK
      case 53:
      case 54:
        YY_RULE_SETUP
        {
          sscanf(yytext, "%lf", &yylval->val);
          return (token::NUM);
        }
        YY_BREAK
      case 55:
        YY_RULE_SETUP; // Empty rule
        YY_BREAK
      case 56:
        YY_RULE_SETUP
        {
          symrec *s;
          s = aprepro.getsym(yytext);
          if (s == nullptr)
            s = aprepro.putsym(yytext, SEAMS::Aprepro::SYMBOL_TYPE::UNDEFINED_VARIABLE, false);
          yylval->tptr = s;
          return ((token::yytokentype)s->type);
        }
        YY_BREAK
      case 57:
        YY_RULE_SETUP
        return (token::EQUAL);
        YY_BREAK
      case 58:
        YY_RULE_SETUP
        return (token::EQ_PLUS);
        YY_BREAK
      case 59:
        YY_RULE_SETUP
        return (token::EQ_MINUS);
        YY_BREAK
      case 60:
        YY_RULE_SETUP
        return (token::EQ_TIME);
        YY_BREAK
      case 61:
        YY_RULE_SETUP
        return (token::EQ_DIV);
        YY_BREAK
      case 62:
        YY_RULE_SETUP
        return (token::EQ_POW);
        YY_BREAK
      case 63:
        YY_RULE_SETUP
        return (token::EQ_POW);
        YY_BREAK
      case 64:
        YY_RULE_SETUP
        return (token::INC);
        YY_BREAK
      case 65:
        YY_RULE_SETUP
        return (token::DEC);
        YY_BREAK
      case 66:
        YY_RULE_SETUP
        return (token::PLU);
        YY_BREAK
      case 67:
        YY_RULE_SETUP
        return (token::SUB);
        YY_BREAK
      case 68:
        YY_RULE_SETUP
        return (token::TIM);
        YY_BREAK
      case 69:
        YY_RULE_SETUP
        return (token::TIM); /* ~ is same as multiply */
        YY_BREAK
      case 70:
        YY_RULE_SETUP
        return (token::CONCAT); /* String concatenation */
        YY_BREAK
      case 71:
        YY_RULE_SETUP
        return (token::DIV);
        YY_BREAK
      case 72:
        YY_RULE_SETUP
        return (token::MOD);
        YY_BREAK
      case 73:
        YY_RULE_SETUP
        return (token::POW);
        YY_BREAK
      case 74:
        YY_RULE_SETUP
        return (token::POW);
        YY_BREAK
      case 75:
        /* rule 75 can match eol */
        YY_RULE_SETUP
        aprepro.ap_file_list.top().lineno++;
        YY_BREAK
      case 76:
        YY_RULE_SETUP
        return (token::LPAR);
        YY_BREAK
      case 77:
        YY_RULE_SETUP
        return (token::RPAR);
        YY_BREAK
      case 78:
        YY_RULE_SETUP
        return (token::COMMA);
        YY_BREAK
      case 79:
        YY_RULE_SETUP
        return (token::SEMI);
        YY_BREAK
      case 80:
        YY_RULE_SETUP
        return (token::COLON);
        YY_BREAK
      case 81:
        YY_RULE_SETUP
        return (token::QUEST);
        YY_BREAK
      case 82:
        YY_RULE_SETUP
        return (token::LT);
        YY_BREAK
      case 83:
        YY_RULE_SETUP
        return (token::GT);
        YY_BREAK
      case 84:
        YY_RULE_SETUP
        return (token::LE);
        YY_BREAK
      case 85:
        YY_RULE_SETUP
        return (token::GE);
        YY_BREAK
      case 86:
        YY_RULE_SETUP
        return (token::EQ);
        YY_BREAK
      case 87:
        YY_RULE_SETUP
        return (token::NE);
        YY_BREAK
      case 88:
        YY_RULE_SETUP
        return (token::LAND);
        YY_BREAK
      case 89:
        YY_RULE_SETUP
        return (token::LOR);
        YY_BREAK
      case 90:
        YY_RULE_SETUP
        return (token::NOT);
        YY_BREAK
      case 91:
        YY_RULE_SETUP
        return (token::LBRACK);
        YY_BREAK
      case 92:
        YY_RULE_SETUP
        return (token::RBRACK);
        YY_BREAK
      case 93:
        /* rule 93 can match eol */
        YY_RULE_SETUP
        {
          char *pt = strrchr(yytext, '"');
          *pt      = '\0';
          new_string(yytext + 1, &yylval->string);
          return token::QSTRING;
        }
        YY_BREAK
      case 94:
        /* rule 94 can match eol */
        YY_RULE_SETUP
        {
          char *pt = strrchr(yytext, '\'');
          *pt      = '\0';
          new_string(yytext + 1, &yylval->string);
          return token::QSTRING;
        }
        YY_BREAK
      case 95:
        YY_RULE_SETUP
        {
          // Add to the history string
          save_history_string();

          if (switch_skip_to_endcase)
            BEGIN(END_CASE_SKIP);
          else
            BEGIN(if_state[if_lvl]);
          return (token::RBRACE);
        }
        YY_BREAK
      case 96:
        YY_RULE_SETUP
        {
          if (begin_double_brace) {
            end_double_brace = true;
          }
          else {
            yyerror("Found an unexpected double end brace ('}}').\n\t"
                    "It can only end an expression started with a double brace ('{{').\n\tCheck "
                    "syntax.");
          }

          // Add to the history string
          save_history_string();

          if (switch_skip_to_endcase)
            BEGIN(END_CASE_SKIP);
          else
            BEGIN(if_state[if_lvl]);
          unput('}');
          unput('O');
          unput('H');
          unput('C');
          unput('E');
          unput('{');
          return (token::RBRACE);
        }
        YY_BREAK
      case 97:
        YY_RULE_SETUP
        {
          if (echo)
            LexerOutput("{", 1);
        }
        YY_BREAK
      case 98:
        YY_RULE_SETUP
        {
          if (echo)
            LexerOutput("}", 1);
        }
        YY_BREAK
      case 99:
        YY_RULE_SETUP
        {
          // Check if we need to save the substitution history first.
          if (aprepro.ap_options.keep_history && (aprepro.ap_file_list.top().name != "_string_")) {
            if (curr_index > yyleng)
              hist_start = curr_index - yyleng;
            else
              hist_start = 0;
          }

          BEGIN(PARSING);
          echo               = false;
          begin_double_brace = true;
          return (token::LBRACE);
        }
        YY_BREAK
      case 100:
        YY_RULE_SETUP
        {
          // Check if we need to save the substitution history first.
          if (aprepro.ap_options.keep_history && (aprepro.ap_file_list.top().name != "_string_")) {
            if (curr_index > yyleng)
              hist_start = curr_index - yyleng;
            else
              hist_start = 0;
          }

          BEGIN(PARSING);

          return (token::LBRACE);
        }
        YY_BREAK
      case 101:
      case 102:
        YY_RULE_SETUP
        {
          if (aprepro.ap_options.end_on_exit) {
            if (echo)
              ECHO;
            return ((token::yytokentype)-1);
          }
          else if (echo)
            ECHO;
        }
        YY_BREAK
      case 103:
        YY_RULE_SETUP
        {
          if (echo)
            ECHO;
        }
        YY_BREAK
      case 104:
      case 105:
        YY_RULE_SETUP
        {
          if (echo && if_state[if_lvl] != IF_SKIP)
            ECHO;
        }
        YY_BREAK
      case 106:
        /* rule 106 can match eol */
        YY_RULE_SETUP
        {
          if (echo && !suppress_nl)
            ECHO;
          suppress_nl = false;
          if (end_double_brace) {
            echo               = true;
            begin_double_brace = false;
            end_double_brace   = false;
          }
          aprepro.ap_file_list.top().lineno++;
        }
        YY_BREAK
      case 107:
        YY_RULE_SETUP
        ECHO;
        YY_BREAK
      case YY_STATE_EOF(INITIAL):
      case YY_STATE_EOF(PARSING):
      case YY_STATE_EOF(GET_FILENAME):
      case YY_STATE_EOF(IF_SKIP):
      case YY_STATE_EOF(GET_VAR):
      case YY_STATE_EOF(VERBATIM):
      case YY_STATE_EOF(IF_WHILE_SKIP):
      case YY_STATE_EOF(GET_LOOP_VAR):
      case YY_STATE_EOF(LOOP):
      case YY_STATE_EOF(LOOP_SKIP):
      case YY_STATE_EOF(END_CASE_SKIP): yyterminate();

      case YY_END_OF_BUFFER: {
        /* Amount of text matched not including the EOB char. */
        int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

        /* Undo the effects of YY_DO_BEFORE_ACTION. */
        *yy_cp = (yy_hold_char);
        YY_RESTORE_YY_MORE_OFFSET

        if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW) {
          /* We're scanning a new file or input source.  It's
           * possible that this happened because the user
           * just pointed yyin at a new source and called
           * yylex().  If so, then we have to assure
           * consistency between YY_CURRENT_BUFFER and our
           * globals.  Here is the right place to do so, because
           * this is the first action (other than possibly a
           * back-up) that will match for the new input source.
           */
          (yy_n_chars)                               = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
          YY_CURRENT_BUFFER_LVALUE->yy_input_file    = yyin;
          YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
        }

        /* Note that here we test for yy_c_buf_p "<=" to the position
         * of the first EOB in the buffer, since yy_c_buf_p will
         * already have been incremented past the NUL character
         * (since all states make transitions on EOB to the
         * end-of-buffer state).  Contrast this with the test
         * in input().
         */
        if ((yy_c_buf_p) <=
            &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)]) { /* This was really a NUL. */
          yy_state_type yy_next_state;

          (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

          yy_current_state = yy_get_previous_state();

          /* Okay, we're now positioned to make the NUL
           * transition.  We couldn't have
           * yy_get_previous_state() go ahead and do it
           * for us because it doesn't know how to deal
           * with the possibility of jamming (and we don't
           * want to build jamming into it because then it
           * will run more slowly).
           */

          yy_next_state = yy_try_NUL_trans(yy_current_state);

          yy_bp = (yytext_ptr) + YY_MORE_ADJ;

          if (yy_next_state) {
            /* Consume the NUL. */
            yy_cp            = ++(yy_c_buf_p);
            yy_current_state = yy_next_state;
            goto yy_match;
          }

          else {
            /* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
            yy_cp = (yy_c_buf_p);
            goto yy_find_action;
          }
        }

        else
          switch (yy_get_next_buffer()) {
          case EOB_ACT_END_OF_FILE: {
            (yy_did_buffer_switch_on_eof) = 0;

            if (yywrap()) {
              /* Note: because we've taken care in
               * yy_get_next_buffer() to have set up
               * yytext, we can now set up
               * yy_c_buf_p so that if some total
               * hoser (like flex itself) wants to
               * call the scanner after we return the
               * YY_NULL, it'll still work - another
               * YY_NULL will get returned.
               */
              (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

              yy_act = YY_STATE_EOF(YY_START);
              goto do_action;
            }

            else {
              if (!(yy_did_buffer_switch_on_eof))
                YY_NEW_FILE;
            }
            break;
          }

          case EOB_ACT_CONTINUE_SCAN:
            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            yy_cp = (yy_c_buf_p);
            yy_bp = (yytext_ptr) + YY_MORE_ADJ;
            goto yy_match;

          case EOB_ACT_LAST_MATCH:
            (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

            yy_current_state = yy_get_previous_state();

            yy_cp = (yy_c_buf_p);
            yy_bp = (yytext_ptr) + YY_MORE_ADJ;
            goto yy_find_action;
          }
        break;
      }

      default: YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    } /* end of scanning one token */
  } /* end of user's declarations */
} /* end of yylex */
/* %ok-for-header */

/* %if-c++-only */
/* %not-for-header */

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::yyFlexLexer(std::istream *arg_yyin, std::ostream *arg_yyout)
{
  yyin          = arg_yyin;
  yyout         = arg_yyout;
  yy_c_buf_p    = 0;
  yy_init       = 0;
  yy_start      = 0;
  yy_flex_debug = 0;
  yylineno      = 1; // this will only get updated if %option yylineno

  yy_did_buffer_switch_on_eof = 0;

  yy_looking_for_trail_begin = 0;
  yy_more_flag               = 0;
  yy_more_len                = 0;
  yy_more_offset = yy_prev_more_offset = 0;

  yy_start_stack_ptr = yy_start_stack_depth = 0;
  yy_start_stack                            = NULL;

  yy_buffer_stack     = 0;
  yy_buffer_stack_top = 0;
  yy_buffer_stack_max = 0;

  yy_state_buf = 0;
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
yyFlexLexer::~yyFlexLexer()
{
  delete[] yy_state_buf;
  SEAMSfree(yy_start_stack);
  yy_delete_buffer(YY_CURRENT_BUFFER);
  SEAMSfree(yy_buffer_stack);
}

/* The contents of this function are C++ specific, so the () macro is not used.
 */
void yyFlexLexer::switch_streams(std::istream *new_in, std::ostream *new_out)
{
  if (new_in) {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    yy_switch_to_buffer(yy_create_buffer(new_in, YY_BUF_SIZE));
  }

  if (new_out)
    yyout = new_out;
}

#ifdef YY_INTERACTIVE
int yyFlexLexer::LexerInput(char *buf, int /* max_size */)
#else
int yyFlexLexer::LexerInput(char *buf, int max_size)
#endif
{
  if (yyin->eof() || yyin->fail())
    return 0;

#ifdef YY_INTERACTIVE
  yyin->get(buf[0]);

  if (yyin->eof())
    return 0;

  if (yyin->bad())
    return -1;

  return 1;

#else
  (void)yyin->read(buf, max_size);

  if (yyin->bad())
    return -1;
  else
    return yyin->gcount();
#endif
}

void yyFlexLexer::LexerOutput(const char *buf, int size) { (void)yyout->write(buf, size); }
/* %ok-for-header */

/* %endif */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
int yyFlexLexer::yy_get_next_buffer()
/* %endif */
{
  char *dest   = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = (yytext_ptr);
  int   number_to_move, i;
  int   ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer ==
      0) { /* Don't try to fill the buffer, so this is an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1) {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)) - 1;

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else {
    yy_size_t num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0) { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer) {
        yy_size_t new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
            /* Include room in for 2 EOB chars. */
            SEAMSrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2);
      }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if (!b->yy_ch_buf)
        YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE)
      num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0) {
    if (number_to_move == YY_MORE_ADJ) {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else {
      ret_val                                    = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if ((yy_size_t)((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
    /* Extend the array by 50%, plus the number we really need. */
    yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
        (char *)SEAMSrealloc((void *)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)]     = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

/* %if-c-only */
/* %not-for-header */

/* %endif */
/* %if-c++-only */
yy_state_type yyFlexLexer::yy_get_previous_state()
/* %endif */
{
  yy_state_type yy_current_state;
  char         *yy_cp;

  /* %% [15.0] code to get the start state into yy_current_state goes here */
  yy_current_state = (yy_start);

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp) {
    /* %% [16.0] code to find the next state goes here */
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state]) {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos)  = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 782)
        yy_c = yy_meta[(unsigned int)yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
yy_state_type yyFlexLexer::yy_try_NUL_trans(yy_state_type yy_current_state)
/* %endif */
{
  int yy_is_jam;
  /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
  char *yy_cp = (yy_c_buf_p);

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state]) {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos)  = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 782)
      yy_c = yy_meta[(unsigned int)yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int)yy_c];
  yy_is_jam        = (yy_current_state == 781);

  return yy_is_jam ? 0 : yy_current_state;
}

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yyunput(int c, char *yy_bp)
/* %endif */
{
  char *yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2) { /* need to shift things up to make room */
                                                         /* +2 for EOB chars. */
    yy_size_t number_to_move = (yy_n_chars) + 2;
    char *dest   = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    char *source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  /* %% [18.0] update yylineno here */

  (yytext_ptr)   = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p)   = yy_cp;
}
/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */
/* %if-c++-only */
int yyFlexLexer::yyinput()
/* %endif */
{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else { /* need more input */
      yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer()) {
      case EOB_ACT_LAST_MATCH:
        /* This happens because yy_g_n_b()
         * sees that we've accumulated a
         * token and flags that we need to
         * try matching the token before
         * proceeding.  But for input(),
         * there's no matching to consider.
         * So convert the EOB_ACT_LAST_MATCH
         * to EOB_ACT_END_OF_FILE.
         */

        /* Reset buffer status. */
        yyrestart(yyin);

        /*FALLTHROUGH*/

      case EOB_ACT_END_OF_FILE: {
        if (yywrap())
          return EOF;

        if (!(yy_did_buffer_switch_on_eof))
          YY_NEW_FILE;
#ifdef __cplusplus
        return yyinput();
#else
        return input();
#endif
      }

      case EOB_ACT_CONTINUE_SCAN: (yy_c_buf_p) = (yytext_ptr) + offset; break;
      }
    }
  }

  c              = *(unsigned char *)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p)  = '\0';                           /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  /* %% [19.0] update BOL and yylineno */

  return c;
}
/* %if-c-only */
/* %endif */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yyrestart(std::istream *input_file)
/* %endif */
{

  if (!YY_CURRENT_BUFFER) {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
/* %endif */
{

  /* TODO. We should be able to replace this entire function body
   * with
   *		yypop_buffer_state();
   *		yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p)                        = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_load_buffer_state()
/* %endif */
{
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin                        = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char)              = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
YY_BUFFER_STATE yyFlexLexer::yy_create_buffer(std::istream *file, int size)
/* %endif */
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)SEAMSalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *)SEAMSalloc(b->yy_buf_size + 2);
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_delete_buffer(YY_BUFFER_STATE b)
/* %endif */
{

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    SEAMSfree((void *)b->yy_ch_buf);

  SEAMSfree((void *)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_init_buffer(YY_BUFFER_STATE b, std::istream *file)
/* %endif */

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file  = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER) {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  /* %if-c-only */
  /* %endif */
  /* %if-c++-only */
  b->yy_is_interactive = 0;
  /* %endif */
  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_flush_buffer(YY_BUFFER_STATE b)
/* %endif */
{
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol        = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state();
}

/* %if-c-or-c++ */
/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yypush_buffer_state(YY_BUFFER_STATE new_buffer)
/* %endif */
{
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p)                        = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}
/* %endif */

/* %if-c-or-c++ */
/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yypop_buffer_state(void)
/* %endif */
{
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER) {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}
/* %endif */

/* %if-c-or-c++ */
/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yyensure_buffer_stack(void)
/* %endif */
{
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack)) {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1;
    (yy_buffer_stack) =
        (struct yy_buffer_state **)SEAMSalloc(num_to_alloc * sizeof(struct yy_buffer_state *));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state *));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {

    /* Increase the buffer to prepare for a possible push. */
    int grow_size = 8 /* arbitrary grow size */;

    num_to_alloc      = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state **)SEAMSrealloc(
        (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state *));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset((yy_buffer_stack) + (yy_buffer_stack_max), 0,
           grow_size * sizeof(struct yy_buffer_state *));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}
/* %endif */

/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_push_state(int new_state)
/* %endif */
{
  if ((yy_start_stack_ptr) >= (yy_start_stack_depth)) {
    yy_size_t new_size;

    (yy_start_stack_depth) += YY_START_STACK_INCR;
    new_size = (yy_start_stack_depth) * sizeof(int);

    if (!(yy_start_stack))
      (yy_start_stack) = (int *)SEAMSalloc(new_size);

    else
      (yy_start_stack) = (int *)SEAMSrealloc((void *)(yy_start_stack), new_size);

    if (!(yy_start_stack))
      YY_FATAL_ERROR("out of memory expanding start-condition stack");
  }

  (yy_start_stack)[(yy_start_stack_ptr)++] = YY_START;

  BEGIN(new_state);
}

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::yy_pop_state()
/* %endif */
{
  if (--(yy_start_stack_ptr) < 0)
    YY_FATAL_ERROR("start-condition stack underflow");

  BEGIN((yy_start_stack)[(yy_start_stack_ptr)]);
}

/* %if-c-only */
/* %endif */
/* %if-c++-only */
int yyFlexLexer::yy_top_state()
/* %endif */
{
  return (yy_start_stack)[(yy_start_stack_ptr)-1];
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

/* %if-c-only */
/* %endif */
/* %if-c++-only */
void yyFlexLexer::LexerError(yyconst char msg[])
{
  std::cerr << msg << std::endl;
  exit(YY_EXIT_FAILURE);
}
/* %endif */

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                                                  \
  do {                                                                                             \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    yytext[yyleng] = (yy_hold_char);                                                               \
    (yy_c_buf_p)   = yytext + yyless_macro_arg;                                                    \
    (yy_hold_char) = *(yy_c_buf_p);                                                                \
    *(yy_c_buf_p)  = '\0';                                                                         \
    yyleng         = yyless_macro_arg;                                                             \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/* %if-c-only */
/* %if-reentrant */
/* %endif */
/* %if-reentrant */
/* %endif */
/* %endif */

/* %if-reentrant */
/* %if-bison-bridge */
/* %endif */
/* %endif if-c-only */

/* %if-c-only */
/* %endif */

/* %if-c-only SNIP! this currently causes conflicts with the c++ scanner */
/* %if-reentrant */
/* %endif */
/* %endif */

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *s1, yyconst char *s2, int n)
{
  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(yyconst char *s)
{
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void *SEAMSalloc(yy_size_t size) { return (void *)malloc(size); }

void *SEAMSrealloc(void *ptr, yy_size_t size)
{
  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return (void *)realloc((char *)ptr, size);
}

void SEAMSfree(void *ptr) { free((char *)ptr); /* see SEAMSrealloc() for (char *) cast */ }

/* %if-tables-serialization definitions */
/* %define-yytables   The name for this specific scanner's tables. */
#define YYTABLES_NAME "yytables"
/* %endif */

/* %ok-for-header */

/* When the scanner receives an end-of-file indication from YY_INPUT, it then
 * checks the yywrap() function. If yywrap() returns false (zero), then it is
 * assumed that the function has gone ahead and set up `yyin' to point to
 * another input file, and scanning continues. If it returns true (non-zero),
 * then the scanner terminates, returning 0 to its caller. */

namespace SEAMS {

  Scanner::Scanner(Aprepro &aprepro_yyarg, std::istream *in, std::ostream *out)
      : SEAMSFlexLexer(in, out), aprepro(aprepro_yyarg)
  {
    aprepro.outputStream.push(out);
  }

  Scanner::~Scanner()
  {
    while (aprepro.ap_file_list.size() > 1) {
      const auto &kk = aprepro.ap_file_list.top();
      if (kk.name != "STDIN") {
        yyFlexLexer::yy_load_buffer_state();
        delete yyin;
        yyin = nullptr;
      }
      aprepro.ap_file_list.pop();
      yyFlexLexer::yypop_buffer_state();
    };
  }

  bool Scanner::add_include_file(const std::string &filename, bool must_exist)
  {
    std::fstream *yytmp = nullptr;
    if (must_exist)
      yytmp = aprepro.open_file(filename, "r");
    else
      yytmp = aprepro.check_open_file(filename, "r");

    if (yytmp) {
      if (yyin && !yy_init) {
        yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(yyin, YY_BUF_SIZE));
      }

      yyin = yytmp;
      if (aprepro.ap_options.debugging) {
        fmt::print(stderr, "DEBUG add_include_file: '{}'\n", filename);
      }

      SEAMS::file_rec new_file(filename.c_str(), 0, false, 0);
      aprepro.ap_file_list.push(new_file);

      yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(yytmp, YY_BUF_SIZE));
      curr_index = 0;
    }
    return yytmp != nullptr;
  }

  void Scanner::LexerOutput(const char *buf, int size)
  {
    // Do this before writing so that we have the correct index in the
    // output stream.
    if (aprepro.ap_options.keep_history) {
      aprepro.add_history(history_string, buf);
      history_string.clear();
      hist_start = 0;
    }

    aprepro.outputStream.top()->write(buf, size);
    if (aprepro.ap_options.interactive && aprepro.outputStream.size() == 1) {
      // In interactive mode, output to stdout in addition to the
      // output stream, unless user has redirected output...
      std::cout << buf;
    }
  }

  int Scanner::LexerInput(char *buf, int max_size)
  {
    if (yyin->eof() || yyin->fail()) {
      return 0;
    }

    if (aprepro.ap_options.interactive && yyin == &std::cin && isatty(0) != 0 && isatty(1) != 0) {
      char *line = SEAMS::getline_int(nullptr);

      if (strlen(line) == 0) {
        return 0;
      }

      if (!string_is_ascii(line, strlen(line))) {
        aprepro.warning("input line contains non-ASCII (probably UTF-8) characters which might be "
                        "parsed incorrectly.");
      }

      SEAMS::gl_histadd(line);

      if (strlen(line) > (size_t)max_size - 2) {
        yyerror("input line is too long");
        return 0;
      }

      strcpy(buf, line);
      strcat(buf, "\n");

      return strlen(buf);
    }
    else {
      (void)yyin->read(buf, max_size);

      if (yyin->bad()) {
        return -1;
      }
      else {
        if (!string_is_ascii(buf, yyin->gcount())) {
          aprepro.warning("input file contains non-ASCII (probably UTF-8) characters which will "
                          "might be parsed incorrectly.");
        }
        return yyin->gcount();
      }
    }
  }

  int Scanner::yywrap()
  {
    // Clear the history string.
    history_string.clear();
    hist_start = 0;
    curr_index = 0;

    // If we are using the string interactive method, we want to return to
    // our original state if parsing was cutoff prematurely.
    if (aprepro.string_interactive() && YY_START == PARSING) {
      if (switch_skip_to_endcase) {
        BEGIN(END_CASE_SKIP);
      }
      else {
        BEGIN(if_state[if_lvl]);
      }
    }

    if (aprepro.ap_file_list.size() <= 1) { /* End of main file, not in nested include */
      return (1);
    }
    else if (aprepro.string_interactive() && loop_lvl) {
      return (1);
    }
    else if (aprepro.isCollectingLoop) {
      yyerror("End-of-file detected inside loop. Check loop syntax. {endloop} must be on line by "
              "itself.");
      return (1);
    }
    else {
      /* We are in an included or looping file */
      if (aprepro.ap_file_list.top().tmp_file) {
        if (aprepro.ap_options.debugging) {
          fmt::print(stderr, "DEBUG LOOP: Loop count = {}, Filename = {}\n",
                     aprepro.ap_file_list.top().loop_count, aprepro.ap_file_list.top().name);
        }
        if (--aprepro.ap_file_list.top().loop_count <= 0) {
          // On Windows, you can't remove the temp file until all the references to the
          // file object have been released, so we will delete it here.
          delete yyin;
          yyin = nullptr;

          if (aprepro.ap_file_list.top().name != "_string_") {
            if (!aprepro.ap_options.debugging) {
              remove(aprepro.ap_file_list.top().name.c_str()); /* Delete file if temporary */
            }
            if (!aprepro.doLoopSubstitution) {
              yy_pop_state();
            }
          }

          aprepro.ap_file_list.pop();
          yyFlexLexer::yypop_buffer_state();
        }
        else {
          // Do not pop ap_file_list; we are rereading that file...
          delete yyin;
          yyin = nullptr;
          yyFlexLexer::yypop_buffer_state();
          yyin = aprepro.open_file(aprepro.ap_file_list.top().name, "r");
          yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(yyin, YY_BUF_SIZE));
          aprepro.ap_file_list.top().lineno = 0;

          if (aprepro.ap_file_list.top().loop_index != nullptr) {
            aprepro.ap_file_list.top().loop_index->value.var +=
                aprepro.ap_file_list.top().loop_increment;
          }
        }
      }
      else {
        delete yyin;
        yyin = nullptr;
        aprepro.ap_file_list.pop();
        yyFlexLexer::yypop_buffer_state();

        if (aprepro.ap_file_list.top().name == "standard input") {
          yyin = &std::cin;
        }

        /* Turn echoing back on at end of included files. */
        echo = true;

        // If we are not doing aprepro substitutions for the included file, but
        // just collecting lines, pop the state from VERBATIM back to what it
        // was previously.
        if (!aprepro.doIncludeSubstitution) {
          yy_pop_state();
        }

        /* Set immutable mode back to global immutable
         * state at end of included file*/
        aprepro.stateImmutable = aprepro.ap_options.immutable;
      }

      // Reset the current character index.
      curr_index = 0;
      if (yyin != nullptr) {
        curr_index = yyin->tellg();
      }

      return (0);
    }
  }

  /* Print error message to standard error and return.  Note: internally
   *   'lineno' starts at zero.  To avoid confusion, we add 1 to value
   *   when it is output.
   */

  void Scanner::yyerror(const char *s) { aprepro.error(s); }

  char *Scanner::execute(char string[])
  {
    /* Push the contents of 'string' onto the stack to be reread.
     * 'string' will be surrounded by {} so it must be a valid expression.
     */

    /*
     * NOTE: The closing } has not yet been scanned in the call to execute();
     *       therefore, we read it ourselves using input(), then we push:
     *       '}{' + our string + '}'
     */
    int i;
    while ((i = yyFlexLexer::yyinput()) != '}' && i != EOF)
      curr_index++; /* eat up values */

    // Increment curr_index to account for the '}' and save history
    curr_index++;
    save_history_string();

    /* Allocate space for string + '}' + '{' + end_of_string */
    std::string new_string;
    new_string += "}{";
    new_string += string;
    new_string += "}";

    aprepro.ap_file_list.push(SEAMS::file_rec("_string_", 0, true, -1));

    auto ins = new std::istringstream(new_string); // Declare an input string stream.
    yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(ins, new_string.size()));
    return (nullptr);
  }

  /* Push the contents of 'string' onto the stack to be reread.
   * 'string' will not be surrounded by {}.
   */

  char *Scanner::rescan(char *string)
  {
    int i;
    /*
     * NOTE: The closing } has not yet been scanned in the call to rescan();
     *       therefore, we read it ourselves using input(), then we push our
     *       string and then put the closing } back on the stack last
     *       (to be read first),
     */
    while ((i = yyFlexLexer::yyinput()) != '}' && i != EOF)
      curr_index++; /* eat up values */

    // Increment curr_index to account for the '}' and save history
    curr_index++;
    save_history_string();

    {
      aprepro.ap_file_list.push(SEAMS::file_rec("_string_", 0, true, -1));
      std::string new_string("}");
      new_string += string;

      if (aprepro.ap_options.debugging) {
        fmt::print(stderr, "DEBUG RESCAN: '{}'\n", new_string);
      }
      auto ins = new std::istringstream(new_string); // Declare an input string stream.
      yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(ins, new_string.size()));
    }
    return (nullptr);
  }

  char *Scanner::import_handler(char *string)
  {
    /*
     * NOTE: The closing } has not yet been scanned in the call to rescan();
     *       therefore, we read it ourselves using input().
     */
    int i = 0;
    while ((i = yyFlexLexer::yyinput()) != '}' && i != EOF)
      curr_index++; /* eat up values */

    add_include_file(string, true);
    std::string info_string = std::string("Imported File: '") + string + "'";
    aprepro.info(info_string, true);

    if (!aprepro.doIncludeSubstitution) {
      yy_push_state(VERBATIM);
    }

    /*
     * Now we need to push back the closing } so it is the first thing read.
     * We no longer have the initial file stream (is is pushed down on stack)
     * so we need to add a new file stream consisting of just a single character.
     * Wasteful, but best I can come up with at this time.
     */
    aprepro.ap_file_list.push(SEAMS::file_rec("_string_", 0, true, -1));
    std::string new_string("}");
    auto        ins = new std::istringstream(new_string); // Declare an input string stream.
    yyFlexLexer::yypush_buffer_state(yyFlexLexer::yy_create_buffer(ins, new_string.size()));

    if (aprepro.ap_options.debugging) {
      std::cerr << "DEBUG IMPORT: " << string << "\n";
    }
    return (nullptr);
  }

  char *Scanner::if_handler(double x)
  {
    if_lvl++;
    if (if_lvl >= MAX_IF_NESTING) {
      yyerror("Too many nested if statements");
    }
    else {
      if (x == 0) {
        if_state[if_lvl]    = IF_SKIP;
        if_case_run[if_lvl] = false;
      }
      else {
        suppress_nl         = true;
        if_state[if_lvl]    = INITIAL;
        if_case_run[if_lvl] = true;
      }
      if (aprepro.ap_options.debugging) {
        std::cerr << "DEBUG IF: If level " << if_lvl << " " << if_state[if_lvl] << "\n";
      }
    }
    return (nullptr);
  }

  char *Scanner::elseif_handler(double x)
  {
    if (x == 0 || if_case_run[if_lvl]) {
      if_state[if_lvl] = IF_SKIP;
    }
    else {
      suppress_nl         = true;
      if_state[if_lvl]    = INITIAL;
      if_case_run[if_lvl] = true;
    }
    if (aprepro.ap_options.debugging) {
      std::cerr << "DEBUG IF: elseif at level " << if_lvl << " " << if_state[if_lvl] << "\n";
    }
    return (nullptr);
  }

  char *Scanner::switch_handler(double x)
  {
    // save that we are in a switch statement
    // save the value of 'x' for use in deciding which case to execute
    if (switch_active) {
      yyerror("switch statement found while switch already active. Nested switch not supported.");
    }

    switch_active          = true;
    switch_case_run        = false;
    switch_condition       = x;
    switch_skip_to_endcase = true; /* Skip everything until first case */
    suppress_nl            = true;

    if (aprepro.ap_options.debugging) {
      std::cerr << "DEBUG SWITCH: 'switch' with condition = " << switch_condition << " at line "
                << aprepro.ap_file_list.top().lineno << "\n";
    }
    return (nullptr);
  }

  char *Scanner::case_handler(double x)
  {
    // make sure we are in a switch statement
    // if 'x' matches the value saved in the switch statement
    // and no other case has been executed, then
    // execute the code in the case and set a flag indicating
    // the switch has run;
    // if 'x' does not match the value saved, then skip to endcase
    suppress_nl = true;

    if (!switch_active) {
      yyerror("case statement found outside switch statement.");
    }

    if (!switch_case_run && x == switch_condition) {
      switch_case_run = true;
      if (aprepro.ap_options.debugging) {
        fprintf(stderr,
                "DEBUG SWITCH: 'case' condition = %g matches switch condition = %g at line %d\n", x,
                switch_condition, aprepro.ap_file_list.top().lineno);
      }
    }
    else {
      if (aprepro.ap_options.debugging) {
        fprintf(stderr,
                "DEBUG SWITCH: 'case' condition = %g does not match switch condition = %g "
                "(or case already matched) at line %d\n",
                x, switch_condition, aprepro.ap_file_list.top().lineno);
      }

      // Need to skip all code until end of case
      switch_skip_to_endcase = true;
    }
    return (nullptr);
  }

  void Scanner::save_history_string()
  {
    if (!aprepro.ap_options.keep_history) {
      return;
    }

    // Don't do it if the file is the one used by execute and rescan.
    if (aprepro.ap_file_list.top().name == "_string_" ||
        aprepro.ap_file_list.top().name == "standard input") {
      return;
    }

    size_t hist_end = curr_index;
    size_t len      = hist_end - hist_start;

    if (len <= 0)
      return;

    // Clear any possible end-of-stream if e.g., reading from a istringstream.
    std::ios::iostate state = yyin->rdstate();
    size_t            loc   = yyin->tellg();
    yyin->clear();

    // Go back in the stream to where we started keeping history.
    yyin->seekg(hist_start);
    if (!yyin->good()) {
      yyerror("Stream state bad in `save_history_string` seekg");
      return;
    }

    // Read everything up to this point again and save it.
    auto tmp = new char[len + 1];
    yyin->read(tmp, len);
    if (!yyin->good()) {
      yyerror("Stream state bad in `save_history_string` read");
      return;
    }
    tmp[len] = '\0';

    history_string = tmp;
    delete[] tmp;
    hist_start = 0;

    // restore stream state
    yyin->seekg(loc);
    yyin->setstate(state);
  }
} // namespace SEAMS

/* This implementation of SEAMSFlexLexer::yylex() is required to fill the
 * vtable of the class SEAMSFlexLexer. We define the scanner's main yylex
 * function via YY_DECL to reside in the Scanner class instead. */

#ifdef yylex
#undef yylex
#endif
int SEAMSFlexLexer::yylex()
{
  std::cerr << "in SEAMSFlexLexer::yylex() !" << '\n';
  return 0;
}

/* When the scanner receives an end-of-file indication from YY_INPUT, it then
 * checks the yywrap() function. If yywrap() returns false (zero), then it is
 * assumed that the function has gone ahead and set up `yyin' to point to
 * another input file, and scanning continues. If it returns true (non-zero),
 * then the scanner terminates, returning 0 to its caller. */

int SEAMSFlexLexer::yywrap() { return 1; }
