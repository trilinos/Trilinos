              INSTRUCTIONS FOR ADDING PYTHON WRAPPERS
                 TO YOUR EXISTING TRILINOS PACKAGE

                  Bill Spotz, wfspotz@sandia.gov

                         October 10, 2005

I have compiled a list of necessary steps to generate wrappers for
your Trilinos package to interface it with python.  The workhorse for
doing this is swig (Simple Wrapper and Interface Generator).  It takes
an interface file (*.i -- which lists header files and contains other
directives) and generates a wrapper file (*_wrap.cpp) and a python
proxy file (*.py).  The generated C++ file must be compiled into a
shared object or dynamic library, depending on the platform.  There
are two portable ways to do this.  One, write a python script (called
setup.py by convention) that imports the distutils module and define
the package and extensions using distutils classes and functions.  Or
two, use libtool.  This New_Package package has been wrapped with the
first method.

While the Trilinos project tries to impose as few restrictions on
packages as possible, there is great benefit in following a few
standards with regard to python wrappers.  The first standard is that
Trilinos packages should be imported into python using

     from PyTrilinos import YOUR_PACKAGE

syntax.  This will keep all the Trilinos python modules installed in
the same place and reduce clutter at the global namespace level.
This is achieved by using the "package=" option in the swig %module
directive when writing your interface file: 

     %module(package=PyTrilinos) YOUR_PACKAGE

and by including the PyTrilinos package name in the definitions in
the setup.py script.  See {new_package,epetra,epetraext}/python/src/
setup.py for examples.

The other standard is maintaining a common directory structure.  This
helps by (1) allowing test scripts for a package that depends on other
packages to find those modules easily, and (2) allowing automatic
documentation tools to search directories to find interface files and
keep current documentation on which header files of which packages
have been wrapped.  In the CVS repository, this directory structure is
currently

    python/                          Subdirectories
    python/Makefile.*                Automake/autoconf Makefiles
    python/doc                       Documentation directory
    python/doc/Makefile.*            Automake/autoconf Makefiles
    python/example                   Example scripts directory
    python/example/Makefile.*        Automake/autoconf Makefiles
    python/example/setpath.py        Python script that sets the
                                       python search path
    python/example/ex*.py            Example scripts
    python/src                       Source file directory
    python/src/.deps                 Dependency directory
    python/src/.deps/dummy           Empty dummy file, used to force
                                       creation of dependency directory
                                       in build tree
    python/src/Makefile.*            Automake/autoconf Makefiles
    python/src/TRILINOS_HOME_DIR.in  Creates text file with full path
                                       to Trilinos source directory
    python/src/__init__.py.in        Creates python module
                                       initialization file
    python/src/setup.py              Python script for building and
                                       installing extension modules
    python/src/*.i                   SWIG interface files
    python/test               	     Test scripts directory
    python/test/Makefile.*           Automake/autoconf Makefiles
    python/test/setpath.py           Python script that sets the
                                       python search path
    python/test/test*.py             Unit test scripts

The new_package package has been wrapped to provide an example of how
Trilinos packages can provide a python interface while following these
standards.  You will also need to become familiar with writing swig
interface files and setup.py scripts.  My hope is that the new_package
wrappers will provide sufficient examples to get you most of the way.

To add python wrappers to your existing Trilinos package, do the
following:

1. From new_package/config, copy the following files to
   YOUR_PACKAGE/config:

     ac_pkg_swig.m4
     ac_python_module.m4
     az_python.m4
     swig.am
     tac_enable_python.m4

   The following files are often already in package config
   directories, but you should double check to make sure they are
   there:

     string-replace.pl
     strip_dup_incl_paths.pl
     strip_dup_libs.pl

2. Edit YOUR_PACKAGE/configure.ac.  Copy the following lines into
   YOUR_PACKAGE/configure.ac:

     # ------------------------------------------------------------------------
     # Enable optional python wrappers
     # ------------------------------------------------------------------------
     TAC_ENABLE_PYTHON

   The location you paste it is probably not crucial, but I have been
   putting it just before the "Specify other directories" section
   present in most of the Trilinos configure.ac files.  At the end of
   configure.ac, add the following files to the AC_CONFIG_FILES macro:

     python/Makefile
     python/src/Makefile
     python/src/TRILINOS_HOME_DIR
     python/src/__init__.py
     python/src/.deps/dummy
     python/test/Makefile
     python/example/Makefile

   (Note the python/src/.deps/dummy file.  Because the Makefile
   ultimately compiles the wrapper files by running "python setup.py
   build", the automake system does not recognize the compilation and
   does not automatically create dependency files.  Thus we force
   configure to create the .deps directory manually by creating a
   dummy file in it.)

3. Edit YOUR_PACKAGE/Makefile.am to contain the following:

     if PYTHON_USE
     PYTHON_SUBDIR=python
     endif

   and make sure the SUBDIRS definition includes $(PYTHON_SUBDIR).

4. Create the python directory structure for your package.  There is
   a script in the new_package directory, CreatePythonDir.py, to help
   with this.  You can run with the --help option for documentation,
   but usually "CreatePythonDir.py Your_Package" will work
   sufficiently well.  This will create a directory,
   "your_package_python", with all the necessary files in it using your
   package name where appropriate.  Move this directory to your
   package directory, renaming it to "python".

In YOUR_PACKAGE/python/src, do the following:

5. Edit Makefile.am.  Update the definition of SWIG_CXXFLAGS to be a
   complete list of needed "-I" include directories and "-D"
   definitions (and anything else) that swig will need to generate the
   wrappers.  Change the definition of INTERFACES to be a list of the
   swig interface files that should be wrapped.  (Note that a python
   module defines a namespace, so it is best to define a single
   interface file for each namespace in your package.)  You can
   probably delete the lines that involve SWAHILI.

6. Edit the __init__.py.in file.  Change the definition of the list
   "all" to include the names of all of the modules in your package.
   Many packages will have just one module name, but if your package
   supports namespaces, you should create a module for each namespace.

7. Edit the setup.py script.

   a. The first crucial component of getting the setup.py script to
      work is to transfer make variables (especially those determined
      during configuration) to the setup.py script.  If your
      python/src/Makefile.am "include"s all the needed export
      Makefiles, this process should be completely automated.  There
      is a line in the setup.py script:

        globals().update(makeVars)

      After this line, every make variable from python/src/Makefile in
      the build directory will be a variable in the python global
      namespace.  The names will be the same names as the make
      variables and the values will be python strings.

   b. Double check the _INCLUDES and _LIBS variables used to set the
      "options" variable.  If your package supports an export Makefile
      and you have included it in python/src/Makefile.am, then
      YOUR_PACKAGE_INCLUDES and YOUR_PACKAGE_LIBS should automatically
      be in the python global namespace.

   c. When you define the python extension(s) using the Extension()
      class, the first argument is the module name and the second
      argument is a list of the source files that must be compiled and
      linked to create the module.  This always includes the wrapper
      file generated by swig, but you can add additional files to this
      list.  The rest of the arguments should not need to be changed.

   d. The call to function "setup" at the end of the script is the key
      to the setup.py script.  Make sure the module names are correct
      in all the arguments and that the ext_modules keyword argument
      is a complete list of all the extension modules you wish to
      have included in your top-level module.

8. Edit the SWIG interface file, python/src/Your_Package.i.  Create
   any additional interface files needed by your project.  A good way
   to start is to simply wrap your package's Version function.
   Writing an interface file is relatively straight-forward, but
   beyond the scope of these instructions.  Use what is given as an
   example and consult the documentation at http://www.swig.org.

At this point, if you have kept the interface file simple, there
should be sufficient infrastructure in place to bootstrap at the
directory level, configure and attempt a make.  When you configure,
use "--enable-python[=path]" or "--with-python[=path]" to trigger
creation of the wrappers.  If swig is not in your path or you wish to
specify a different swig, use "--with-swig=path".  After debugging,
you can go on to the following steps:

9.  Edit the python/test/Makefile.am file.  Define TEST_SUITE to be a
    list of test scripts, omitting the ".py" extension.  For each test
    listed in TEST_SUITE, there should be a corresponding python
    script in the test directory, named with a ".py" extension.
    (Don't forget to keep the EXTRA_DIST macro up-to-date.)  The
    new_package test uses the python unittest facility, and is an
    excellent framework for quickly developing unit tests for your
    wrapped package.

10. If your tests require access to python wrappers from another
    package, the proper path needs to be added to python's search
    path.  This is done by editing python/test/setpath.py.  Use the
    logic for finding epetra's path in new_package's setpath.py as a
    guide.

11. Running "make" will copy the test and example scripts from the
    source directory to the build directory.  They can be run
    directly.

12. Repeat steps 9--11 for the python/example subdirectory.  The
    Makefile defines EXAMPLE_SUITE instead of TEST_SUITE, but
    otherwise the procedure is the same.

Test Harness

13. Any of the test or example scripts you want to be run as part of
    the nightly test harness should be added to the
    your_package/test/definition file.  See any supported package as
    an example.

Bugzilla

14. Now that your package has a python interface, be sure to inform
    the bugzilla administrator, so that he can add "Python wrappers"
    as a valid component of the package for the reporting of bugs.

Good luck!
