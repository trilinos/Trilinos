#====================================================================
# ------------------------
# | CVS File Information |
# ------------------------
# 
# $RCSfile$
#
# $Author$
#
# $Date$
#
# $Revision$
#
# $Name$
#====================================================================

                          AZTEC Tutorial

A sample AZTEC application is provided in the file 'az_tutorial.c'. The 11 
exercises below are performed by continually modifying the sample program. 
By doing the exercises, the new user will be introduced to many of AZTEC's
features.  Unless otherwise stated, problem x will require modification to 
the program used for problem x-1. Complete answers to the exercises are
given at the end of this document.

To compile and run the original sample program, the OBJ line in the 
application Makefile must be changed to : OBJ = az_tutorial.o. 'az_tutorial.c' 
corresponds to setting up and solving a 2D Poisson approximation on a 6 x 6 
grid where the right hand side corresponds to a delta function in the lower 
left corner of the grid. Below we illustrate the program body:

line no.
-------

    62    /* get number of processors and the name of this processor */
    63  #ifdef AZ_MPI
    64    MPI_Init(&argc,&argv);
    65    AZ_set_proc_config(proc_config, MPI_COMM_WORLD);
    66  #else
    67    AZ_set_proc_config(proc_config, AZ_NOT_MPI);
    68 #endif
    69
    70    /* Define partitioning:  matrix rows (ascending order) owned by this node */
    71    
    72    nrow = n*n;
    73    AZ_read_update(&N_update, &update, proc_config, nrow, 1, AZ_linear);
    74
    75    /*
    76     * Create the matrix: each processor creates only rows appearing in update[]
    77     * (using global col. numbers).
    78     */
    79
    80    bindx = (int    *) calloc(N_update*MAX_NZ_ROW+1,sizeof(int));
    81    val   = (double *) calloc(N_update*MAX_NZ_ROW+1,sizeof(double));
    82    if (val == NULL) perror("Error: Not enough space to create matrix");
    83
    84    bindx[0] = N_update+1;
    85
    86    for (i = 0; i < N_update; i++) {
    87      create_matrix_row(update[i], i, val, bindx);
    88    }
    89  
    90    /* convert matrix to a local distributed matrix */
    91  
    92    AZ_transform(proc_config, &external, bindx, val, update, &update_index,
    93                 &extern_index, &data_org, N_update, NULL, NULL, NULL, NULL,
    94                 AZ_MSR_MATRIX);
    95  
    96    /* initialize AZTEC options */
    97  
    98    AZ_defaults(options, params);
    99  
   100    /* Set rhs (delta function at lower left corner) and initialize guess */
   101  
   102    b = (double *) calloc(N_update, sizeof(double));
   103    x = (double *) calloc(N_update + data_org[AZ_N_external], sizeof(double));
   104    if ((x == NULL) && (i != 0)) perror("Not enough space in rhs");
   105  
   106    for (i = 0; i < N_update; i++) {
   107      x[update_index[i]] = 0.0;
   108      b[update_index[i]] = 0.0;
   109      if (update[i] == 0) b[update_index[i]] = 1.0;
   110    }
   111  
   112  
   113    /* solve the system of equations using b  as the right hand side */
   114  
   115    AZ_solve(x, b, options, params, NULL, bindx, NULL, NULL, NULL, val, data_org,
   116             status, proc_config);
   117  
   118    /* Free allocated memory */
   119  
   120  
   121    free((void *) update);   free((void *) update_index);
   122    free((void *) external); free((void *) extern_index);
   123  
   124    free((void *) x);    free((void *) b);       free((void *) bindx);
   125    free((void *) val);  free((void *) data_org);
   126  
   127  
   128  #ifdef AZ_MPI
   129    MPI_Finalize();
   130  #endif
   131  
   132  } /* main */
   133  
   134  
   135  
   136  
   137  
   138  
   139  
   140  /***************************************************************************/
   141  /***************************************************************************/
   142  /***************************************************************************/
   143  
   144  void create_matrix_row(int row, int location, double val[], int bindx[])
   145  
   146  /* Add one row to an MSR matrix corresponding to a discrete approximation to the
   147   * 2D Poisson operator on an n x n square.
   148   *
   149   * Parameters:
   150   *    row          == global row number of the new row to be added.
   151   *    location     == local row where diagonal of the new row will be stored.
   152   *    val,bindx    == (see user's guide). On output, val[] and bindx[]
   153   *                    are appended such that the new row has been added.
   154   */
   155  
   156  {
   157    int k;
   158  
   159    /* check neighbors in each direction and add nonzero if neighbor exits */
   160  
   161    k = bindx[location];
   162    bindx[k]  = row + 1; if ((row  )%n != n-1) val[k++] = -1.;
   163    bindx[k]  = row - 1; if ((row  )%n !=   0) val[k++] = -1.;
   164    bindx[k]  = row + n; if ((row/n)%n != n-1) val[k++] = -1.;
   165    bindx[k]  = row - n; if ((row/n)%n !=   0) val[k++] = -1.;
   166  
   167    bindx[location+1] = k;  val[location]     = 4.; /* matrix diagonal */
   168  }



If you run this program, the iteration output should approximately be the 
following:

                *******************************************************
                ***** Preconditioned GMRES solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.333333e-01
                iter:    2              residual = 1.549193e-01
                iter:    3              residual = 8.498208e-02
                iter:    4              residual = 5.178089e-02
                iter:    5              residual = 3.392084e-02
                iter:    6              residual = 2.343361e-02
                iter:    7              residual = 1.673219e-02
                iter:    8              residual = 1.183812e-02
                iter:    9              residual = 7.732077e-03
                iter:   10              residual = 4.398328e-03
                iter:   11              residual = 1.241776e-03
                iter:   12              residual = 5.528073e-04
                iter:   13              residual = 1.918082e-04
                iter:   14              residual = 6.826307e-05
                iter:   15              residual = 1.470372e-05
                iter:   16              residual = 3.001987e-06
                iter:   17              residual = 2.111772e-07
 
---

IMPORTANT: SAVE A COPY OF THIS PROGRAM IN THE FILE 'original.c'.

Problem 1: 2D Poisson PARTITIONING (6 x 6)
=========
To partition or distribute problems over processors, each processor
must set 'N_update' to the number of matrix rows it will own and the 
array 'update' to the specific matrix row numbers (in ascending order)
owned by this processor. In our sample program, a linear partitioning is 
used via the function AZ_read_update() (line 73).

Change the AZ_read_update() call so that it instead reads the paritioning
from the file '.update'. Initialize this file so that the row r (0 <= r < 36)
is assigned to processor number r%P (mod function in "C") where P is
the number of processors used with this '.update' file. 

Note: AZ_read_update() is not particularly fast in that it reads a 
single file and thus distributes rows serially. For large data sets
it is generally better to use some kind of parallel input/output.
See the AZ_read_update() description in the Aztec User's Guide for 
more information.

The output of this program should be the same as that of the original
sample problem as we have only changed the assignment of rows to processors.  

Problem 2: DENSE MSR matrix (4 x 4)
=========
IMPORTANT: COPY THE FILE 'original.c' INTO 'az_tutorial.c'. YOU MIGHT WANT 
TO SAVE 'az_tutorial.c' BEFORE DOING THIS.

Change this program to solve the matrix application

   /              \        / \
   |  7  3  2  1  |       | 1 |  
   |  5  8  3  1  |  x  = | 0 |
   |  5  3  9  2  |       | 0 |
   |  1  2  1  6  |       | 0 |
   \              /       \   /

Using x = 0 as an initial guess.

Hint: Change in line 72 to indicate the number of matrix rows (nrow=4). 
Other than this, only the subroutine create_matrix_row() needs to 
be changed. The "Data Formats" and "High Level Data Interface" sections 
of the Aztec User's Guide explain the MSR data format used to represent 
the matrix. Essentially, to append a row to a matrix already containing 
j rows (rows are locally numbered from 0 to j-1), we need to do the 
following:

   a) set index, k, to point to the free space for the offdiagonal elements:
      k = bindx[j]

   b) Store each off diagonal element as follows:

         val[k] = 1st off-diagonal, bindx[k] = 1st off-diagonal column number
         k = k + 1
         val[k] = 2nd off-diagonal, bindx[k] = 2nd off-diagonal column number
         etc

   c) put the diagonal element of the new row in  val[j]

   d) store free space pointer in bindx[j+1] (i.e. bindx[j+1] = k).


This program should produce approximately the following iteration output:

 
                *******************************************************
                ***** Preconditioned GMRES solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 7.141428e-01
                iter:    2              residual = 1.687498e-01
                iter:    3              residual = 2.119830e-02
                iter:    4              residual = 1.928932e-16

---


Problem 3: Aztec OPTIONS (solver) - 2D Poisson (6 x 6)
=========
IMPORTANT: COPY THE FILE 'original.c' INTO 'az_tutorial.c'. YOU MIGHT WANT 
TO SAVE 'az_tutorial.c' BEFORE DOING THIS.

The original sample program uses the GMRES algorithm as this is the default 
AZTEC method (indicated by setting options[AZ_solver] in AZ_defaults). Change
the sample program so that we use the TFQMR method and so that the algorithm
terminates when the initial residual is reduced by 10^5 (instead of the 
default 10^6).  See the "Aztec Options" section of the Aztec User's Guide for 
more information.
Note: this example is just for demonstration purposes as we should really use
the conjugate gradient algorithm for this symmetric problem.

The  resulting iteration output of the program should now approximately be:


                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.352989e-01
                iter:    3              residual = 7.202456e-02
                iter:    4              residual = 4.273759e-02
                iter:    5              residual = 2.571415e-02
                iter:    6              residual = 1.391762e-02
                iter:    7              residual = 6.317909e-03
                iter:    8              residual = 2.292283e-03
                iter:    9              residual = 6.648821e-04
                iter:   10              residual = 1.506405e-04
                iter:   11              residual = 1.590716e-05
                iter:   12              residual = 9.021697e-07
 
---
 
Problem 4: BROADCASTING n ( grid-size parameter ) - 2D Poisson (n x n)
=========
Currently, the grid size parameter, n (for an n x n grid), is fixed.
To make a grid size parameter that the user can input, one processor
must read the input and then broadcast the value.  Using the function 
AZ_broadcast(), add the lines necessary to have processor 0 (node name 
is given by proc_config[AZ_node]) read the grid size parameter from the 
user and broadcast the information to the other processors. See the 
AZ_broadcast() description in the Aztec User's Guide for more information.

If the program is run and the value 7 is given as input (for a 
7 x 7 grid), the  resulting iteration output should approximately be:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.352989e-01
                iter:    3              residual = 7.203379e-02
                iter:    4              residual = 4.316646e-02
                iter:    5              residual = 2.765714e-02
                iter:    6              residual = 1.777434e-02
                iter:    7              residual = 1.055632e-02
                iter:    8              residual = 5.501200e-03
                iter:    9              residual = 2.430743e-03
                iter:   10              residual = 8.779539e-04
                iter:   11              residual = 2.893932e-04
                iter:   12              residual = 7.050597e-05
                iter:   13              residual = 1.091404e-05
                iter:   14              residual = 7.701444e-07
---

IMPORTANT: SAVE THIS PROGRAM IN THE FILE 'principal.c'.

Problem 5: RIGHT hand side - 2D Poisson (n x n)
=========
Change the right hand side so that there is a '1' in each of the four
corners of the grid and a '0' everywhere else.

Note: The global right hand side vector 'B' needs to be distributed over 
the processors. That is, the specific element B[k] is stored on only 1 
processor.  The function AZ_transform() permutes the matrix such that the 
element B[k] must be stored in b[update_index[i]] on the processor for which 
there exists an i (0 <= i < N_update) such that update[i] = k.

If this program is run using the value 7 as input, the resulting iteration
output should approximately be:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.464818e-01
                iter:    3              residual = 9.497719e-02
                iter:    4              residual = 6.810138e-02
                iter:    5              residual = 4.444184e-02
                iter:    6              residual = 2.311353e-02
                iter:    7              residual = 3.528172e-03
                iter:    8              residual = 3.851591e-04
                iter:    9              residual = 1.561198e-17

---

Problem 6: RIGHT hand side II - 2D Poisson (n x n)
=========
In some cases, we wish to initialize the right hand side vector at 
the same time that we initialize the matrix (ie. before AZ_transform()). 
Unfortunately, the array 'update_index' (used in the previous exercise) 
is only available after the AZ_transform() call. Instead of using the
array 'update_index', the global right hand side element B[k] can be 
stored as element tmp_b[i] on the processor for which there exists an 
i (0 <= i < N_update) such that update[i] = k. After AZ_transform() the 
tmp_b elements can be moved into their proper b[update_index[i]] location.

Change the sample program so that the right hand side is initialized
at the same time as the matrix. Then, after AZ_transform() is invoked
permute the right hand side so that it matches the matrix permutation
done in AZ_tranform().

If this program is run using the value 7 as input, the resulting output 
should be the same as for Problem 5.

Problem 7: EDITTING rhs - 2D Poisson (n x n)
=========
Modify the program so that after solving the system in Problem 6 it
zeros out the 1's in the 2 right corners of the right hand side, and
solves the system again using the previous solution as an initial guess.
Use the function AZ_find_index() to determine the location in 'update' 
of the points 'n-1' and 'n*n-1'.

If this program is run using the value 7 as input, the resulting 
iteration output should approximately be:


                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.464818e-01
                iter:    3              residual = 9.497719e-02
                iter:    4              residual = 6.810138e-02
                iter:    5              residual = 4.444184e-02
                iter:    6              residual = 2.311353e-02
                iter:    7              residual = 3.528172e-03
                iter:    8              residual = 3.851591e-04
                iter:    9              residual = 1.561198e-17
 

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.411253e-01
                iter:    3              residual = 8.361324e-02
                iter:    4              residual = 5.469282e-02
                iter:    5              residual = 3.524117e-02
                iter:    6              residual = 2.006837e-02
                iter:    7              residual = 1.048266e-02
                iter:    8              residual = 5.623542e-03
                iter:    9              residual = 2.611812e-03
                iter:   10              residual = 8.182422e-04
                iter:   11              residual = 1.897014e-04
                iter:   12              residual = 3.757968e-05
                iter:   13              residual = 6.296418e-07


Problem 8: EDITTING MATRIX - 2D Poisson (n x n)
=========
There might also arise cases where we wish to modify a matrix 
which has already been permuted by AZ_transform(). In this case
we must use 'update_index' and 'extern_index' to determine where
matrix values are stored.

Write a new routine called 'post_create_matrix_row()' which overwrites the
AZ_transform'ed matrix in between the 2 AZ_solve() calls in Problem 7.
The matrix modification will only be applied to rows corresponding
to grid points on the right boundary of the domain. Change the 
stencil at these boundary rows from 
             -1
         -1   4          to          -1  1.
             -1

Note: This exercise can be a bit tricky. The idea is to use AZ_find_index()
on 'update' and/or on 'external' to find the location of the left
neighbor. The stencil value for this neighbor is to be kept as -1.
For all other neighbors, the stencil value is changed to 0.

IMPORTANT: AZ_find_index() can not be used on 'update_index' and
'extern_index' as these are not in ascending order.

If this program is run using the value 7 as input, the resulting iteration
output should approximately be:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.464818e-01
                iter:    3              residual = 9.497719e-02
                iter:    4              residual = 6.810138e-02
                iter:    5              residual = 4.444184e-02
                iter:    6              residual = 2.311353e-02
                iter:    7              residual = 3.528172e-03
                iter:    8              residual = 3.851591e-04
                iter:    9              residual = 1.561198e-17
 

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 1.462427e+00
                iter:    2              residual = 1.574105e+00
                iter:    3              residual = 1.270515e+00
                iter:    4              residual = 1.094866e+00
                iter:    5              residual = 1.077147e+00
                iter:    6              residual = 1.038635e+00
                iter:    7              residual = 8.276535e-01
                iter:    8              residual = 6.019309e-01
                iter:    9              residual = 4.498290e-01
                iter:   10              residual = 1.996331e-01
                iter:   11              residual = 6.072724e-02
                iter:   12              residual = 2.070181e-02
                iter:   13              residual = 8.442455e-04
                iter:   14              residual = 5.841776e-04
                iter:   15              residual = 3.081943e-04
                iter:   16              residual = 7.862072e-05
                iter:   17              residual = 3.015537e-05
                iter:   18              residual = 1.175332e-06

Problem 9: IRREGULAR grid - 2D Poisson-like (n lines)
=========
IMPORTANT: COPY THE FILE 'principal.c' INTO 'az_tutorial.c'. YOU MIGHT WANT 
TO SAVE 'az_tutorial.c' BEFORE DOING THIS.

Change this program so that we can handle fairly arbitrary 2D regions.
In particular, the user will input the number of horizontal lines in
the grid as the parameter 'n'. He will also supply two integer 
returning functions: left() and right(). left(i) returns the starting
x value in the ith horizontal line. right(i) returns the ending x 
value in the ith horizontal line.

For example, the functions

int left(int n)
{
  return(0);
}
 
int right(int n)
{
  if (n == 0) return(3);
  if (n == 1) return(2);
  if (n == 2) return(1);
  if (n == 3) return(2);
  else return(7);
}

used on a problem with 4 horizontal lines corresponds to the grid 

               9  10  11
               7   8 
               4   5   6
               0   1   2   3

with Poisson matrix

               4  -1   0   0  -1   0   0   0   0   0   0   0
              -1   4  -1   0   0  -1   0   0   0   0   0   0
               0  -1   4  -1   0   0  -1   0   0   0   0   0
               0   0  -1   4   0   0   0   0   0   0   0   0
              -1   0   0   0   4  -1   0  -1   0   0   0   0
               0  -1   0   0  -1   4  -1   0  -1   0   0   0
               0   0  -1   0   0  -1   4   0   0   0   0   0
               0   0   0   0  -1   0   0   4  -1  -1   0   0
               0   0   0   0   0  -1   0  -1   4   0  -1   0
               0   0   0   0   0   0   0  -1   0   4  -1   0
               0   0   0   0   0   0   0   0  -1  -1   4  -1  
               0   0   0   0   0   0   0   0   0   0  -1   4 

Running this problem with the same initial guess (x = 0) and 
right hand side (b = e_1, where e_1 is the vector of all zeros 
except for the first element which is 1) should approximately 
produce the iteration output:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 3.078276e-01
                iter:    2              residual = 1.212586e-01
                iter:    3              residual = 3.382271e-02
                iter:    4              residual = 5.095646e-03
                iter:    5              residual = 1.262783e-03
                iter:    6              residual = 1.029025e-04
                iter:    7              residual = 1.146834e-05
                iter:    8              residual = 6.605168e-09

---

Problem 10: 3D Poisson (n x n x n)
==========
IMPORTANT: COPY THE FILE 'principal.c' (created in Problem 4) INTO 
'az_tutorial.c'. YOU MIGHT WANT TO SAVE 'az_tutorial.c' BEFORE DOING THIS.

Change this program from a 2D Poisson approximation on the n x n square 
to a 3D Poisson approximation on the n x n x n cube. Run this problem
with the same initial guess (x = 0) and right hand side (B = e_1)

NOTE: Remember to allocate enough memory for 'bindx' and 'val' to 
accomodate the 7 point stencil.

If this program is run using the value 7 as input, the resulting 
iteration output should approximately be:


                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 2.193551e-01
                iter:    2              residual = 7.539287e-02
                iter:    3              residual = 3.318523e-02
                iter:    4              residual = 1.690645e-02
                iter:    5              residual = 9.507550e-03
                iter:    6              residual = 5.724587e-03
                iter:    7              residual = 3.588558e-03
                iter:    8              residual = 2.265129e-03
                iter:    9              residual = 1.380014e-03
                iter:   10              residual = 7.732288e-04
                iter:   11              residual = 3.832266e-04
                iter:   12              residual = 1.652267e-04
                iter:   13              residual = 6.181623e-05
                iter:   14              residual = 2.009490e-05
                iter:   15              residual = 1.346214e-06


Problem 11: 3D VBR example (n x n x n)
==========
Change the 3D Poisson operator to approximate the system of 
m coupled PDE equations on an n x n x n grid:

Pois( u^(0) ) + .1    sum    Pois( u^(i) )  = f^0
                  0 <= i  < m 
                    i != 0

Pois( u^(1) ) + .1    sum    Pois( u^(i) )  = f^1
                  0 <= i  < m 
                    i != 1


                       .
                       .
                       .
Pois( u^(m-1) ) + .1    sum    Pois( u^(i) )  = f^(m-1)
                  0 <= i  < m 
                    i != m-1

where Pois(v) = v_xx + v_yy + v_zz.

Use the VBR format and let the value of m be a global variable
input by the user. Run this program with the same initial guess
(x = 0) and the same combined right hand side (B = e_1, that is 
f^0 = e_1, f^1 = 0, f^2 = 0, ..., f^(m-1) = 0).

Hint: The m x m diagonal blocks of this matrix should consist of 
the value 6. on the diagonal entries and the value .6 on all the 
off-diagonals entries.  The m x m off-diagonal blocks of this 
matrix should consist of the value -1. on the diagonal entries and 
the value -.1 on all the off diagonals entries.

If this program is run with 7 and 3 as input (i.e. a system of
3 coupled PDEs on a 7 x 7 x 7 grid), the iteration output should
approximately be:

                *******************************************************
                ***** Preconditioned TFQMR solution
                ***** No preconditioning
                ***** No scaling
                *******************************************************
 
                iter:    0              residual = 1.000000e+00
                iter:    1              residual = 2.885746e-01
                iter:    2              residual = 1.241962e-01
                iter:    3              residual = 6.121277e-02
                iter:    4              residual = 3.385888e-02
                iter:    5              residual = 2.037280e-02
                iter:    6              residual = 1.293223e-02
                iter:    7              residual = 8.521449e-03
                iter:    8              residual = 5.685374e-03
                iter:    9              residual = 3.711614e-03
                iter:   10              residual = 2.284157e-03
                iter:   11              residual = 1.284914e-03
                iter:   12              residual = 6.570774e-04
                iter:   13              residual = 3.102746e-04
                iter:   14              residual = 1.369291e-04
                iter:   15              residual = 5.682475e-05
                iter:   16              residual = 6.471154e-06


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                     Answers to exercises:
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   
Problem 1:
=========
Change line 73 to 
 73    AZ_read_update(&N_update,&update,proc_config,nrow,1,AZ_file);

Create the file .update. To run on 4 processors, this file should
contain the following information:

   9
 3  7 11 15 19 23 27 31 35
   9
 2  6 10 14 18 22 26 30 34
   9
 1  5  9 13 17 21 25 29 33
   9
 0  4  8 12 16 20 24 28 32


To run on 1 processor, this file should contain:

   36
 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 
22 23 24 25 26 27 28 29 30 31 32 33 34 35

Problem 2:
=========
Change line 72 to 
 72    nrow=4;

The uncommented new create_matrix_row() routine should resemble: 

void create_matrix_row(int row,int location,double val[], int bindx[])
{
   int k;
 
   k = bindx[location];
   if (row == 0) {
      bindx[k] = 1;   val[k++] = 3;
      bindx[k] = 2;   val[k++] = 2;
      bindx[k] = 3;   val[k++] = 1;
                      val[location] = 7.;
   }
   else if (row == 1) {
      bindx[k] = 0;   val[k++] = 5;
      bindx[k] = 2;   val[k++] = 3;
      bindx[k] = 3;   val[k++] = 1;
                      val[location] = 8.;
   }
   else if (row == 2) {
      bindx[k] = 0;   val[k++] = 5;
      bindx[k] = 1;   val[k++] = 3;
      bindx[k] = 3;   val[k++] = 2;
                      val[location] = 9.;
   }
   else if (row == 3) {
      bindx[k] = 0;   val[k++] = 1;
      bindx[k] = 1;   val[k++] = 2;
      bindx[k] = 2;   val[k++] = 1;
                      val[location] = 6.;
   }
   else perror("Invalid row number");
   bindx[location+1] = k;
}

Problem 3: 
=========
After line 98 add:

 98a   options[AZ_solver] = AZ_tfqmr;
 98b   params[AZ_tol]     = 1.0e-5;

Problem 4: 
=========
After line 68 (corresponding to original program listing) add:

 68a   if (proc_config[AZ_node] == 0) {
 68b      printf("Enter grid size (n, for n x n grid)\n");
 68c      scanf("%d",&n);
 68d   }
 68e   AZ_broadcast((char *) &n, sizeof(int), proc_config, AZ_PACK);
 68f   AZ_broadcast(NULL       ,           0, proc_config, AZ_SEND);

and enter the value 7 when prompted for the grid size.
   
Problem 5: 
=========
Change line 100 (corresponding to original program listing) to 

 100   /* Set rhs (delta function at grid corners) and initialize guess */

After line 109 (corresponding to original program listing) add:

 109a    if (update[i] == n-1  ) b[update_index[i]] = 1.0;
 109b    if (update[i] == n*n-n) b[update_index[i]] = 1.0;
 109c    if (update[i] == n*n-1) b[update_index[i]] = 1.0;

Alternatively, b can be assigned via 

        if (update[i] == 0    ) b[i] = 1.0;
        if (update[i] == n-1  ) b[i] = 1.0;
        if (update[i] == n*n-n) b[i] = 1.0;
        if (update[i] == n*n-1) b[i] = 1.0;
and AZ_reorder_vec() could be invoked after the loop to
reorder b so that it corresponds to the transformed system.

Problem 6:
=========
In our solution, we move the declaration of b (line 102 of the 
original program) to just after line 79 (of original program).

Just after the 'create_matrix_row' line (line 87 in original program), we add
      b[i] = 0.0;

Just before the 'AZ_transform' line (line 92) , we add

  for (i = 0; i < N_update; i++) {
        if (update[i] == 0    ) b[i] = 1.0;
        if (update[i] == n-1  ) b[i] = 1.0;
        if (update[i] == n*n-n) b[i] = 1.0;
        if (update[i] == n*n-1) b[i] = 1.0;
  }
Just after the 'AZ_tranform' line, we add
    AZ_reorder_vec(b, data_org, update_index, NULL);

and then we remove all references to 'b[update_index]'.


Problem 7:
=========
After line 116 (corresponding to original program listing), add:

 116a
 116b   i = AZ_find_index(  n-1, update, N_update);
 116c   if (i != -1) b[update_index[i]] = 0.0;
 116d   i = AZ_find_index(n*n-1, update, N_update);
 116e   if (i != -1) b[update_index[i]] = 0.0;
 116f
 116g   AZ_solve(x,b, options, params, NULL,bindx,NULL,NULL,NULL,val,
 116h          data_org, status, proc_config);

Note: when solving the same system mulitple times with different right 
hand sides, it is possible to reuse factorization information produced 
by the matrix scaling options and some of the preconditioners (AZ_ilu, 
AZ_lu, AZ_bilu). To do this, set options[AZ_pre_calc] to AZ_reuse
after the first solve AZ_solve().
   
Problem 8:
=========
We declared a new external function 

 21a   extern void post_create_matrix_row_5pt(int row, int location, double val[], 
 21b                     int bindx[], int update[], int update_index[], 
 21c                     int external[], int extern_index[], int data_org[]);

and added the following lines before the second call to AZ_solve().

 116f1  for (i = 0 ; i < N_update ; i++ ) {
 116f2     if (update[i]%n == n-1) 
 116f3        post_create_matrix_row_5pt(update[i],update_index[i],val,bindx, update, 
 116f4                       update_index, external, extern_index, data_org);
 116f5  }
 116f6

The uncommented new subroutine follows:
    
    void post_create_matrix_row_5pt(int row, int location, double val[], int bindx[],
                        int update[], int update_index[], int external[],
                        int extern_index[], int data_org[])
    {
       int i, k, neighbor = -1;
 
       if (row%n != 0) {
          i = AZ_find_index(row-1, update, data_org[AZ_N_internal] +
                                       data_org[AZ_N_border]);
          if (i == -1) {
             i = AZ_find_index(row-1, external, data_org[AZ_N_external]);
             if (i != -1) neighbor = extern_index[i];
          }
          else neighbor = update_index[i];
       }
 
       for (k = bindx[location] ; k < bindx[location+1] ; k++ )
          if (bindx[k] != neighbor) val[k] = 0.;
 
       val[location]     = 1.; /* matrix diagonal */
    }


Problem 9:
=========
In addition to the functions left() and right() given in the problem
it is necessary to make the following changes.

Replace 

 21    extern void create_matrix_row(int row,int i,double val[],int bindx[]);

by

 21    extern void create_matrix_row(int row,int location,double val[],int bindx[],
 21a                      int yline_head, int yval,int n);
 21b   extern int left(int yval); 
 21c   extern int right(int yval);
 21d   int    yval, yline_head, next;

Replace

 68b      printf("Enter grid size (n, for n x n grid)\n");

by 

 68b      printf("Enter grid size (n, n horizontal lines in grid)\n");

Replace

 73    AZ_read_update(&N_update,&update,proc_config,nrow,1,AZ_linear);

by

 73    total = 0;   /* total is set to the total number of grid points */
 73a   for (i = 0 ; i < n ; i++ ) { total += (right(i) - left(i)+1);}
 73b   AZ_read_update(&N_update,&update,proc_config,total,1,AZ_linear);

Note: total needs to be declared as well.
Replace

 86    for (i = 0 ; i < N_update ; i++ ) {
 87       create_matrix_row(update[i],i,val,bindx);
 88    }

by 

 86    yval     = 0;   yline_head = 0;
 87    next     = right(0) - left(0) + 1;
 88    for (i = 0 ; i < N_update ; i++ ) {
 88a      while ( next <= update[i] ) {
 88b         yline_head = next;   yval++;
 88c         next = yline_head + right(yval) - left(yval) + 1;
 88d      }
 88e      create_matrix_row(update[i],i,val,bindx,yline_head,yval,n);
 88f   }

and add the subroutine create_matrix_row():

void create_matrix_row(int row,int location,double val[],int bindx[],
             int yline_head, int yval,int n)
{
/* Add one row to an MSR matrix corresponding to a discrete approximation
 * on an irregular 2D domain. Specifically, the grid contains n horizontal
 * lines. The x values on line j start at left(j) and end at right(j).
 *
 * Parameters:
 *    row          == global row number of the new row to be added.
 *    location     == local row where diagonal of the new row will be stored.
 *    val,bindx    == (see user's guide). On output, val[] and bindx[]
 *                    are appended such that the new row has been added.
 *    yline_head   == global row number of the first grid point in the
 *                    horizontal line containing 'row'.
 *    yval         == horizontal line y = yval contains 'row'.
 *    n            == total number of horizontal lines in grid.
 */
   int b_neigh = 0, t_neigh = 0, l_neigh = 0, r_neigh = 0;
   int lval0 = 0, rval1 = 0, lval2 = 0, rval2 = 0, lval3 = 0, rval3 = 0;
   extern int left(), right();
   int normalized, k;
 
   normalized = yline_head - left(yval);
   l_neigh    = row-1;   lval0 = normalized +  left(yval) + 1;
   r_neigh    = row+1;   rval1 = normalized + right(yval) - 1;
 
   if (yval != 0) {
      b_neigh = row+left(yval)-right(yval-1)-1;
      lval2   = normalized +  left(yval-1);
      rval2   = normalized + right(yval-1);
   }
   else rval2 = lval2 - 1;
   if (yval != n-1) {
      t_neigh = row-left(yval+1)+right(yval)+1;
      lval3   = normalized +  left(yval+1);
      rval3   = normalized + right(yval+1);
   }
   else rval3 = lval3 - 1;
 
   /* check neighbors in each direction and add nonzero if neighbor exits */

   k = bindx[location];
   bindx[k] = l_neigh; if  (row >= lval0)                    val[k++] = -1.;
   bindx[k] = r_neigh; if  (row <= rval1)                    val[k++] = -1.;
   bindx[k] = b_neigh; if ((row >= lval2) && (row <= rval2)) val[k++] = -1.;
   bindx[k] = t_neigh; if ((row >= lval3) && (row <= rval3)) val[k++] = -1.;
   bindx[location+1] = k;  val[location]     = 4.; /* matrix diagonal */
}
  
Problem 10:
==========
Change line 68b in Problem 4 program to 

 68b      printf("Enter grid size (n, for n x n x n grid)\n");

Change line 72 in Problem 4 program to 

 72    nrow=n*n*n;

Change 
       #define MAX_NZ_ROW 5
to 
       #define MAX_NZ_ROW 7

so that the proper amount of memory is allocated in lines 80 & 81.

Change line 147 to 

 147  * to the 3D Poisson operator on an n x n x n square.

After line 165, add the following lines:

165a   bindx[k]  = row + n*n; if ((row/(n*n))%n != n-1) val[k++] = -1.;
165b   bindx[k]  = row - n*n; if ((row/(n*n))%n !=   0) val[k++] = -1.;

and finally change the matrix diagonal in line 167 to 

117    bindx[location+1] = k;  val[location]     = 6.; /* matrix diagonal */

Problem 11:
==========
Our new program is as follows:

/* This software was developed at Sandia National Labs under US Energy Dept.
 * contract DE-AC-4-76DP00789 and is copyrighted by Sandia Corporation.  */

#include <stdio.h>
#include <stdlib.h>
#ifdef AZ_MPI
#include <mpi.h>
#endif
#include "az_aztec.h"
#define perror(str) { fprintf(stderr,"%s\n",str);   exit(-1); }

int m, n = 6;      /* EQUATIONS WILL BE SOLVED ON an n x n x n GRID. */

void main(int argc, char *argv[])

/* Set up a coupled PDE test problem and solve it with AZTEC.                */

{
   double *b,*x;                    /* rhs and approximate solution          */
   int    i, j, nrow;
   extern void create_matrix_row(int row,int location, int rpntr[],int bpntr[],
			int bindx[], int indx[],double val[]);

            /* See Aztec User's Guide for the variables that follow:         */
                               
   int    proc_config[AZ_PROC_SIZE];/* Processor information.                */
   int    options[AZ_OPTIONS_SIZE]; /* Array used to select solver options.  */
   double params[AZ_PARAMS_SIZE];   /* User selected solver paramters.       */
   int    *data_org;                /* Array to specify data layout          */
   double status[AZ_STATUS_SIZE];   /* Information returned from AZ_solve(). */
   int    *update,                  /* vector elements updated on this node. */
          *external;                /* vector elements needed by this node.  */
   int    *update_index;            /* ordering of update[] and external[]   */
   int    *extern_index;            /* locally on this processor.            */
   int    *bindx;                   /* Sparse matrix to be solved is stored  */
   double *val;                     /* in these MSR arrays.                  */
   int    *indx,*cpntr,*bpntr,*rpntr;
   int    N_update;                 /* # of unknowns updated on this node    */

#ifdef AZ_MPI
   MPI_Init(&argc,&argv);
#endif

   /* get number of processors and the name of this processor */

   AZ_processor_info(proc_config);

   if (proc_config[AZ_node] == 0) {
      printf("Enter grid size (n, for n x n x n grid)\n");
      scanf("%d",&n);
      printf("Enter number of PDEs\n");
      scanf("%d",&m);
   }
   AZ_broadcast((char *) &n, sizeof(int), proc_config, AZ_PACK);
   AZ_broadcast((char *) &m, sizeof(int), proc_config, AZ_PACK);
   AZ_broadcast(NULL       ,           0, proc_config, AZ_SEND);

   /* Define partitioning:matrix rows (ascending order) owned by this node */

   nrow = n*n*n;
   AZ_read_update(&N_update,&update,proc_config,nrow,1,AZ_linear);

   /* create the matrix: each processor creates only rows  */
   /* appearing in update[] (using global col. numbers).   */

   rpntr   = (int    *) calloc(N_update+1,sizeof(int));
   bpntr   = (int    *) calloc(N_update+1,sizeof(int));
   bindx   = (int    *) calloc(N_update*7+1,sizeof(int));
   indx    = (int    *) calloc(N_update*7+1,sizeof(int));
   val     = (double *) calloc(m*m*N_update*7+1,sizeof(double));
   if (val == NULL) perror("Error: Not enough space to create matrix")

   rpntr[0] = 0; bpntr[0] = 0; indx[0]  = 0;
   for (i = 0 ; i < N_update ; i++ ) {
      create_matrix_row(update[i],i,rpntr,bpntr,bindx,indx,val);
   }

   /* convert matrix to a local distributed matrix */

   AZ_transform(proc_config,&external,bindx,val,update,&update_index,
        &extern_index,&data_org,N_update,indx,bpntr,rpntr,&cpntr,AZ_VBR_MATRIX);

   /* initialize AZTEC options */

   AZ_defaults(options, params);
   options[AZ_solver] = AZ_tfqmr;
   params[AZ_tol]     = 1.0e-5;

  /* Set rhs (delta function at lower left corner) and initialize guess */

  b = (double *) calloc(m*N_update,sizeof(double));
  x = (double *) calloc(m*N_update + data_org[AZ_N_external],sizeof(double));
  if ((x == NULL) && (i != 0)) perror("Not enough space in rhs")

  for (i=0 ; i < N_update; i++ ) { 
    for (j = 0 ; j < m ; j++ ) {
       x[m*update_index[i]+j] = 0.0;
       b[m*update_index[i]+j] = 0.0;
    }
    if (update[i] == 0 ) b[m*update_index[i]] = 1.0;
  }

  /* solve the system of equations using b  as the right hand side */

   AZ_solve(x,b, options, params, indx,bindx,rpntr,cpntr,bpntr,val,
	    data_org, status, proc_config);

#ifdef AZ_MPI
   MPI_Finalize();
#endif
}

/***************************************************************************/
/***************************************************************************/

void create_matrix_row(int row,int location, int rpntr[],int bpntr[],int bindx[],
	int indx[],double val[])
{
/* Add one row to an MSR matrix corresponding to a discrete approximation
 * to the 3D Poisson operator on an n x n x n square.
 *
 * Parameters:
 *    row          == global row number of the new row to be added.
 *    location     == local row where diagonal of the new row will be stored.
 *    val,bindx    == (see user's guide). On output, val[] and bindx[] 
 *                    are appended such that the new row has been added.
 */
   int k;
   extern void VBR_block(int indx[],int *k,double val[],double factor);

   /* check neighbors in each direction and add nonzero if neighbor exits */

   rpntr[location+1] = rpntr[location] + m;

   k = bpntr[location];
   bindx[k]  = row;                                 VBR_block(indx,&k,val, 6.);
   bindx[k]  = row + 1;   if ((row  )%n != n-1)     VBR_block(indx,&k,val,-1.);
   bindx[k]  = row - 1;   if ((row  )%n !=   0)     VBR_block(indx,&k,val,-1.);
   bindx[k]  = row + n;   if ((row/n)%n != n-1)     VBR_block(indx,&k,val,-1.);
   bindx[k]  = row - n;   if ((row/n)%n !=   0)     VBR_block(indx,&k,val,-1.);
   bindx[k]  = row + n*n; if ((row/(n*n))%n != n-1) VBR_block(indx,&k,val,-1.);
   bindx[k]  = row - n*n; if ((row/(n*n))%n !=   0) VBR_block(indx,&k,val,-1.);

   bpntr[location+1] = k; 
}

void VBR_block(int indx[],int *k,double val[],double factor)
{
   int i,j,indx_ptr;

   indx_ptr = indx[*k];
   indx[*k+1] = indx_ptr + m*m;  
   for (i = 0 ; i < m ; i++ ) {
     for (j = 0 ; j < m ; j++ ) {
        if (i == j) val[indx_ptr++] = factor;
	else val[indx_ptr++] = factor * .1;
     }
   }
   (*k)++;
}

All the necessary changes include:
  1) new declarations (m,j,*indx,*cpntr,*bpntr,*rpntr)
  2) changes in the create_matrix_row(), AZ_transform(), and AZ_solve() parameters
  3) adding 3 lines to input m and broadcast it.
  4) storage allocation for val,rpntr,bpntr,indx,val,b and x
  5) initializing rpntr[0], bpntr[0], indx[0] to 0
  6) changing the right hand side and initial guess for VBR format
  7) changing create_matrix_row() to call VBR_block instead of setting val[].
  8) adding the subroutine VBR_block()
