//@HEADER
// ************************************************************************
// 
//          Kokkos: Node API and Parallel Node Kernels
//              Copyright (2008) Sandia Corporation
// 
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
// 
// ************************************************************************
//@HEADER

#ifndef __Kokkos_Raw_SparseMatVec_def_hpp
#define __Kokkos_Raw_SparseMatVec_def_hpp

/// \file Kokkos_Raw_SparseMatVec_def.hpp
/// \brief Definitions of "raw" sequential sparse triangular solve routines.
/// \warning This code was generated by the SparseTriSolve.py script.  
///   If you edit this header by hand, your edits will disappear the 
///   next time you run the generator script.

namespace Kokkos {
namespace Raw {

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajor (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i + c*colStrideY] += A_ij * X[j + c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i + c*colStrideY] += alpha * A_ij * X[j + c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajor4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i] += A_ij * X[j];
        Y[i + colStrideY] += A_ij * X[j + colStrideX];
        Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
        Y[i + 3*colStrideY] += A_ij * X[j + 3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y[i + c*colStrideY] += A_ij * X[j + c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i] += alpha * A_ij * X[j];
        Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
        Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
        Y[i + 3*colStrideY] += alpha * A_ij * X[j + 3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y[i + c*colStrideY] += alpha * A_ij * X[j + c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajor1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajor2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajor3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajor4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
      Y[i + 3*colStrideY] += A_ij * X[j + 3*colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
      Y[i + 3*colStrideY] += alpha * A_ij * X[j + 3*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajor (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] = beta * Y_i[c*colStrideY];
        }
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i + c*colStrideY] += A_ij * X[j + c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] = beta * Y_i[c*colStrideY];
        }
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i + c*colStrideY] += alpha * A_ij * X[j + c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajor4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get strip-mined, but requires Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y[i] *= beta;
          Y[i + colStrideY] *= beta;
          Y[i + 2*colStrideY] *= beta;
          Y[i + 3*colStrideY] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i] += A_ij * X[j];
        Y[i + colStrideY] += A_ij * X[j + colStrideX];
        Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
        Y[i + 3*colStrideY] += A_ij * X[j + 3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y[i + c*colStrideY] += A_ij * X[j + c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y[i] *= beta;
          Y[i + colStrideY] *= beta;
          Y[i + 2*colStrideY] *= beta;
          Y[i + 3*colStrideY] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i] += alpha * A_ij * X[j];
        Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
        Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
        Y[i + 3*colStrideY] += alpha * A_ij * X[j + 3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y[i + c*colStrideY] += alpha * A_ij * X[j + c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajor1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] = beta * Y[i];
      }
      Y[i] += A_ij * X[j];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] *= beta;
      }
      Y[i] += alpha * A_ij * X[j];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajor2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] = beta * Y[i];
        Y[i + colStrideY] = beta * Y[i + colStrideY];
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] *= beta;
        Y[i + colStrideY] *= beta;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajor3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] = beta * Y[i];
        Y[i + colStrideY] = beta * Y[i + colStrideY];
        Y[i + 2*colStrideY] = beta * Y[i + 2*colStrideY];
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] *= beta;
        Y[i + colStrideY] *= beta;
        Y[i + 2*colStrideY] *= beta;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajor4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] = beta * Y[i];
        Y[i + colStrideY] = beta * Y[i + colStrideY];
        Y[i + 2*colStrideY] = beta * Y[i + 2*colStrideY];
        Y[i + 3*colStrideY] = beta * Y[i + 3*colStrideY];
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
      Y[i + 3*colStrideY] += A_ij * X[j + 3*colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] *= beta;
        Y[i + colStrideY] *= beta;
        Y[i + 2*colStrideY] *= beta;
        Y[i + 3*colStrideY] *= beta;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
      Y[i + 3*colStrideY] += alpha * A_ij * X[j + 3*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajor (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += A_ij * X[j*rowStrideX + c];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += alpha * A_ij * X[j*rowStrideX + c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajor4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
        Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
        Y[i*rowStrideY + 3] += A_ij * X[j*rowStrideX + 3];
      }
      for ( ; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += A_ij * X[j*rowStrideX + c];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
        Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
        Y[i*rowStrideY + 3] += alpha * A_ij * X[j*rowStrideX + 3];
      }
      for ( ; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += alpha * A_ij * X[j*rowStrideX + c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajor1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajor2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajor3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajor4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
      Y[i*rowStrideY + 3] += A_ij * X[j*rowStrideX + 3];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
      Y[i*rowStrideY + 3] += alpha * A_ij * X[j*rowStrideX + 3];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajor (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] = beta * Y_i[c];
        }
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += A_ij * X[j*rowStrideX + c];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] = beta * Y_i[c];
        }
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += alpha * A_ij * X[j*rowStrideX + c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajor4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get strip-mined, but requires Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y[i*rowStrideY] *= beta;
          Y[i*rowStrideY + 1] *= beta;
          Y[i*rowStrideY + 2] *= beta;
          Y[i*rowStrideY + 3] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
        Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
        Y[i*rowStrideY + 3] += A_ij * X[j*rowStrideX + 3];
      }
      for ( ; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += A_ij * X[j*rowStrideX + c];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y[i*rowStrideY] *= beta;
          Y[i*rowStrideY + 1] *= beta;
          Y[i*rowStrideY + 2] *= beta;
          Y[i*rowStrideY + 3] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
        Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
        Y[i*rowStrideY + 3] += alpha * A_ij * X[j*rowStrideX + 3];
      }
      for ( ; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += alpha * A_ij * X[j*rowStrideX + c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajor1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] = beta * Y[i*rowStrideY];
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] *= beta;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajor2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] = beta * Y[i*rowStrideY];
        Y[i*rowStrideY + 1] = beta * Y[i*rowStrideY + 1];
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] *= beta;
        Y[i*rowStrideY + 1] *= beta;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajor3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] = beta * Y[i*rowStrideY];
        Y[i*rowStrideY + 1] = beta * Y[i*rowStrideY + 1];
        Y[i*rowStrideY + 2] = beta * Y[i*rowStrideY + 2];
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] *= beta;
        Y[i*rowStrideY + 1] *= beta;
        Y[i*rowStrideY + 2] *= beta;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajor4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] = beta * Y[i*rowStrideY];
        Y[i*rowStrideY + 1] = beta * Y[i*rowStrideY + 1];
        Y[i*rowStrideY + 2] = beta * Y[i*rowStrideY + 2];
        Y[i*rowStrideY + 3] = beta * Y[i*rowStrideY + 3];
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
      Y[i*rowStrideY + 3] += A_ij * X[j*rowStrideX + 3];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] *= beta;
        Y[i*rowStrideY + 1] *= beta;
        Y[i*rowStrideY + 2] *= beta;
        Y[i*rowStrideY + 3] *= beta;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
      Y[i*rowStrideY + 3] += alpha * A_ij * X[j*rowStrideX + 3];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i + c*colStrideY] += A_ij * X[j + c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i + c*colStrideY] += alpha * A_ij * X[j + c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i] += A_ij * X[j];
        Y[i + colStrideY] += A_ij * X[j + colStrideX];
        Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
        Y[i + 3*colStrideY] += A_ij * X[j + 3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y[i + c*colStrideY] += A_ij * X[j + c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i] += alpha * A_ij * X[j];
        Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
        Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
        Y[i + 3*colStrideY] += alpha * A_ij * X[j + 3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y[i + c*colStrideY] += alpha * A_ij * X[j + c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
      Y[i + 3*colStrideY] += A_ij * X[j + 3*colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
      Y[i + 3*colStrideY] += alpha * A_ij * X[j + 3*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] = beta * Y_i[c*colStrideY];
        }
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i + c*colStrideY] += A_ij * X[j + c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] = beta * Y_i[c*colStrideY];
        }
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i + c*colStrideY] += alpha * A_ij * X[j + c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get strip-mined, but requires Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y[i] *= beta;
          Y[i + colStrideY] *= beta;
          Y[i + 2*colStrideY] *= beta;
          Y[i + 3*colStrideY] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i] += A_ij * X[j];
        Y[i + colStrideY] += A_ij * X[j + colStrideX];
        Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
        Y[i + 3*colStrideY] += A_ij * X[j + 3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y[i + c*colStrideY] += A_ij * X[j + c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y[i] *= beta;
          Y[i + colStrideY] *= beta;
          Y[i + 2*colStrideY] *= beta;
          Y[i + 3*colStrideY] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i] += alpha * A_ij * X[j];
        Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
        Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
        Y[i + 3*colStrideY] += alpha * A_ij * X[j + 3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y[i + c*colStrideY] += alpha * A_ij * X[j + c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] = beta * Y[i];
      }
      Y[i] += A_ij * X[j];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] *= beta;
      }
      Y[i] += alpha * A_ij * X[j];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] = beta * Y[i];
        Y[i + colStrideY] = beta * Y[i + colStrideY];
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] *= beta;
        Y[i + colStrideY] *= beta;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] = beta * Y[i];
        Y[i + colStrideY] = beta * Y[i + colStrideY];
        Y[i + 2*colStrideY] = beta * Y[i + 2*colStrideY];
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] *= beta;
        Y[i + colStrideY] *= beta;
        Y[i + 2*colStrideY] *= beta;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] = beta * Y[i];
        Y[i + colStrideY] = beta * Y[i + colStrideY];
        Y[i + 2*colStrideY] = beta * Y[i + 2*colStrideY];
        Y[i + 3*colStrideY] = beta * Y[i + 3*colStrideY];
      }
      Y[i] += A_ij * X[j];
      Y[i + colStrideY] += A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += A_ij * X[j + 2*colStrideX];
      Y[i + 3*colStrideY] += A_ij * X[j + 3*colStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i] *= beta;
        Y[i + colStrideY] *= beta;
        Y[i + 2*colStrideY] *= beta;
        Y[i + 3*colStrideY] *= beta;
      }
      Y[i] += alpha * A_ij * X[j];
      Y[i + colStrideY] += alpha * A_ij * X[j + colStrideX];
      Y[i + 2*colStrideY] += alpha * A_ij * X[j + 2*colStrideX];
      Y[i + 3*colStrideY] += alpha * A_ij * X[j + 3*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += A_ij * X[j*rowStrideX + c];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += alpha * A_ij * X[j*rowStrideX + c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
        Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
        Y[i*rowStrideY + 3] += A_ij * X[j*rowStrideX + 3];
      }
      for ( ; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += A_ij * X[j*rowStrideX + c];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
        Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
        Y[i*rowStrideY + 3] += alpha * A_ij * X[j*rowStrideX + 3];
      }
      for ( ; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += alpha * A_ij * X[j*rowStrideX + c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  Ordinal j = 0;
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
      Y[i*rowStrideY + 3] += A_ij * X[j*rowStrideX + 3];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
      Y[i*rowStrideY + 3] += alpha * A_ij * X[j*rowStrideX + 3];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] = beta * Y_i[c];
        }
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += A_ij * X[j*rowStrideX + c];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] = beta * Y_i[c];
        }
      }
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += alpha * A_ij * X[j*rowStrideX + c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get strip-mined, but requires Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y[i*rowStrideY] *= beta;
          Y[i*rowStrideY + 1] *= beta;
          Y[i*rowStrideY + 2] *= beta;
          Y[i*rowStrideY + 3] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
        Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
        Y[i*rowStrideY + 3] += A_ij * X[j*rowStrideX + 3];
      }
      for ( ; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += A_ij * X[j*rowStrideX + c];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y[i*rowStrideY] *= beta;
          Y[i*rowStrideY + 1] *= beta;
          Y[i*rowStrideY + 2] *= beta;
          Y[i*rowStrideY + 3] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
      }
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 gets strip-mined, but requires Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
        Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
        Y[i*rowStrideY + 3] += alpha * A_ij * X[j*rowStrideX + 3];
      }
      for ( ; c < numVecs; ++c) {
        Y[i*rowStrideY + c] += alpha * A_ij * X[j*rowStrideX + c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] = beta * Y[i*rowStrideY];
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] *= beta;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] = beta * Y[i*rowStrideY];
        Y[i*rowStrideY + 1] = beta * Y[i*rowStrideY + 1];
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] *= beta;
        Y[i*rowStrideY + 1] *= beta;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] = beta * Y[i*rowStrideY];
        Y[i*rowStrideY + 1] = beta * Y[i*rowStrideY + 1];
        Y[i*rowStrideY + 2] = beta * Y[i*rowStrideY + 2];
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] *= beta;
        Y[i*rowStrideY + 1] *= beta;
        Y[i*rowStrideY + 2] *= beta;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  Ordinal i = 0;
  // Special case for CSR only: Y(0,:) = 0.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] = beta * Y[i*rowStrideY];
        Y[i*rowStrideY + 1] = beta * Y[i*rowStrideY + 1];
        Y[i*rowStrideY + 2] = beta * Y[i*rowStrideY + 2];
        Y[i*rowStrideY + 3] = beta * Y[i*rowStrideY + 3];
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += A_ij * X[j*rowStrideX + 2];
      Y[i*rowStrideY + 3] += A_ij * X[j*rowStrideX + 3];
    }
  }
  else { // alpha != STS::one()
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal j = ind[k];
      while (k >= ptr[i+1]) {
        ++i;
        // We haven't seen row i before; prescale Y(i,:).
        Y[i*rowStrideY] *= beta;
        Y[i*rowStrideY + 1] *= beta;
        Y[i*rowStrideY + 2] *= beta;
        Y[i*rowStrideY + 3] *= beta;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      Y[i*rowStrideY + 1] += alpha * A_ij * X[j*rowStrideX + 1];
      Y[i*rowStrideY + 2] += alpha * A_ij * X[j*rowStrideX + 2];
      Y[i*rowStrideY + 3] += alpha * A_ij * X[j*rowStrideX + 3];
    }
  }
}

} // namespace Raw
} // namespace Kokkos

#endif // #ifndef __Kokkos_Raw_SparseMatVec_def_hpp
