# Make sure we added this option to the build
ASSERT_DEFINED(${PACKAGE_NAME}_ENABLE_TSQR)

IF(${PACKAGE_NAME}_ENABLE_TSQR)

  SET(HEADERS "")
  SET(SOURCES "")
  INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})

  ASSERT_DEFINED(TSQR_ENABLE_Fortran)
  if (TSQR_ENABLE_Fortran)
    # TSQR has an optional Fortran dependency.  Fortran is used to
    # build Tsqr_Combine.f90, which is the back end of
    # TSQR::CombineFortran.  It's not good enough for Trilinos to be
    # build with Fortran support, because TSQR depends on Fortran 2003
    # features.  "Trilinos is built with Fortran support" usually
    # means no better than Fortran 90, and sometimes just Fortran 77.
    enable_language (Fortran)

    # Generate macros for Fortran >= 90 name mangling.  Only
    # Tsqr_CombineFortran.cpp uses these.  TSQR's BLAS and LAPACK
    # wrappers use the F77_BLAS_MANGLE macro that Trilinos defines.  The
    # advantage of FortranCInterface is that it includes macros for
    # mangling the names of Fortran routines contained in modules.
    include(FortranCInterface)
    FortranCInterface_HEADER(${CMAKE_CURRENT_BINARY_DIR}/Tsqr_FortranCInterface.hpp)
    APPEND_SET(HEADERS 
      ${CMAKE_CURRENT_BINARY_DIR}/Tsqr_FortranCInterface.hpp)
  endif ()

  # Add TSQR-specific CMake files to the CMake module path.  Save the
  # old module path so we can restore it afterwards.
  set (CMAKE_MODULE_PATH_SAVE ${CMAKE_MODULE_PATH})
  set (CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/cmake)

  include (TsqrBlasAndLapack)
  include (TsqrCheckLapackRoutine)
  include (TsqrTestLapack)

  # Generate a header file (Tsqr_Config.hpp) with the appropriate
  # #defines.  Tsqr_Config.hpp.in is in the cmake/ subdirectory, which
  # was added to the CMAKE_MODULE_PATH above.  Putting the header in
  # CMAKE_CURRENT_BINARY_DIR will ensure correct installation of the
  # generated header file.
  configure_file ("Tsqr_Config.hpp.in" "${CMAKE_CURRENT_BINARY_DIR}/Tsqr_Config.hpp")
  # Teuchos/src/CMakeLists.txt shows the canonical way to add a
  # generated header file (which doesn't start out in the source tree)
  # to HEADERS.  Putting the header in CMAKE_CURRENT_BINARY_DIR will
  # ensure correct installation of the generated header file.
  APPEND_SET(HEADERS
    ${CMAKE_CURRENT_BINARY_DIR}/Tsqr_Config.hpp)

  ASSERT_DEFINED(TSQR_ENABLE_Fortran)
  if (TSQR_ENABLE_Fortran)
    # Generate LAPACK wrapper routines for _LARF(G)(P) used by
    # Tsqr_CombineFortran.f90.  The wrappers are written to
    # ${TSQR_FORTRAN_MODULE_FILENAME}.  We only need these if we are
    # building TSQR::CombineFortran.
    include (TsqrLapackWrappers)
    
    # TSQR_FORTRAN_MODULE_FILENAME comes from TsqrLapackWrappers; that
    # file is generated by CMake.  The remaining files are just header
    # or source files in this directory; they are not generated.
    APPEND_SET(SOURCES
      ${TSQR_FORTRAN_MODULE_FILENAME}
      Tsqr_CombineFortran.f90
      Tsqr_CombineFortran.cpp)
    APPEND_SET(HEADERS 
      Tsqr_CombineFortran.hpp)
  endif ()

  # Non-generated header files
  INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR})
  APPEND_SET(HEADERS
    Tsqr_ApplyType.hpp
    Tsqr_Blas.hpp
    Tsqr_CacheBlocker.hpp
    Tsqr_CacheBlockingStrategy.hpp
    Tsqr_CombineDefault.hpp
    Tsqr_Combine.hpp
    Tsqr_CombineBenchmark.hpp
    Tsqr_CombineBenchmarker.hpp
    Tsqr_CombineNative.hpp
    Tsqr_CombineTest.hpp
    Tsqr_ConfigDefs.hpp
    Tsqr_Lapack.hpp
    Tsqr_LocalVerify.hpp
    Tsqr_Matrix.hpp
    Tsqr_MatView.hpp
    Tsqr_nodeTestProblem.hpp
    Tsqr_NodeTsqr.hpp
    Tsqr_NodeTsqrFactory.hpp
    Tsqr_Random_MatrixGenerator.hpp
    Tsqr_Random_NormalGenerator.hpp
    Tsqr_ScalarTraits.hpp
    Tsqr_SeqTest.hpp
    Tsqr_SequentialCholeskyQR.hpp
    Tsqr_SequentialTsqr.hpp
    Tsqr_StatTimeMonitor.hpp
    Tsqr_TbbTest.hpp
    Tsqr_TimeStats.hpp
    Tsqr_TrivialTimer.hpp
    Tsqr_Util.hpp
    Tsqr_verifyTimerConcept.hpp
    )
  # Headers for TBB-enabled shared-memory parallel TSQR.
  IF (TSQR_ENABLE_Intel_TBB)
    APPEND_SET(HEADERS
      TbbTsqr_ApplyTask.hpp
      TbbTsqr_CacheBlockTask.hpp
      TbbTsqr_ExplicitQTask.hpp
      TbbTsqr_FactorTask.hpp
      TbbTsqr_FillWithZerosTask.hpp
      TbbTsqr.hpp
      TbbTsqr_Partitioner.hpp
      TbbTsqr_RevealRankTask.hpp
      TbbTsqr_TbbParallelTsqr.hpp
      TbbTsqr_TbbRecursiveTsqr_Def.hpp
      TbbTsqr_TbbRecursiveTsqr.hpp
      TbbTsqr_UnCacheBlockTask.hpp
      )
  ENDIF ()
  # Non-generated source files.  Does not include source files
  # corresponding to complex arithmetic routines; those are below.  We
  # have to separate them out because Trilinos does not build with
  # complex arithmetic support by default.
  APPEND_SET(SOURCES
    Tsqr_ApplyType.cpp 
    Tsqr_Blas.cpp 
    Tsqr_DLapack.cpp
    Tsqr_SLapack.cpp
    Tsqr_CombineTest.cpp
    Tsqr_SeqTest.cpp
    Tsqr_StatTimeMonitor.cpp
    Tsqr_TimeStats.cpp
    Tsqr_TrivialTimer.cpp
    )
  # More non-generated source files, corresponding to complex
  # arithmetic routines.  The default value of TSQR_ENABLE_Complex is
  # the value of Teuchos_ENABLE_COMPLEX.
  IF (TSQR_ENABLE_Complex)
    APPEND_SET(SOURCES
      Tsqr_CLapack.cpp
      Tsqr_ZLapack.cpp
      )
  ENDIF ()

  PACKAGE_ADD_LIBRARY(
    kokkosnodetsqr
    HEADERS ${HEADERS}
    SOURCES ${SOURCES}
    DEPLIBS kokkos
    )

  # Restore original CMake module path
  set (CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH_SAVE})

  # Our tests test for both performance and numerical accuracy.  They
  # also function as general benchmarks, given the right command-line
  # arguments.
  PACKAGE_ADD_TEST_DIRECTORIES(test)

ENDIF () # ${PACKAGE_NAME}_ENABLE_TSQR
