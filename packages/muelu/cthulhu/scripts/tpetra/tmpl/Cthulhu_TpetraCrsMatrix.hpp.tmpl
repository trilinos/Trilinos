$TMPL_HEADERS

#include "Cthulhu_TpetraConfigDefs.hpp"

#include "Tpetra_CrsMatrix.hpp"

#include "Cthulhu_CrsMatrix.hpp"
#include "Cthulhu_TpetraMap.hpp"
#include "Cthulhu_TpetraMultiVector.hpp"
#include "Cthulhu_TpetraVector.hpp"
#include "Cthulhu_TpetraCrsGraph.hpp"
#include "Cthulhu_Exceptions.hpp"

namespace Cthulhu {

  // TODO: move that elsewhere
  // template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  // const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps> toTpetraCrsMatrix(const Cthulhu::DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &);
  //

  $TMPL_TEMPLATE_PARAM
  class $TMPL_CLASS
  $TMPL_INHERITANCE
  {

    // The following typedef are used by the CTHULHU_DYNAMIC_CAST() macro.
    typedef TpetraCrsMatrix<Scalar,LocalOrdinal,GlobalOrdinal,Node> TpetraCrsMatrixClass;

  public:

$TMPL_PUBLIC_FUNCTIONS

    //! Implements DistObject interface
    //{@

    //! Access function for the Tpetra::Map this DistObject was constructed with.
    const Teuchos::RCP< const Map< LocalOrdinal, GlobalOrdinal, Node > > getMap() const { return rcp( new TpetraMap< LocalOrdinal, GlobalOrdinal, Node >(mtx_->getMap()) ); }

    //! Import.
    void doImport(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &source, 
                  const Import< LocalOrdinal, GlobalOrdinal, Node > &importer, CombineMode CM) { 

      CTHULHU_DYNAMIC_CAST(const TpetraCrsMatrixClass, source, tSource, "Cthulhu::TpetraCrsMatrix::doImport only accept Cthulhu::TpetraCrsMatrix as input arguments.");//TODO: remove and use toTpetra()
      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal,Node> > v = tSource.getTpetra_CrsMatrix();
      //mtx_->doImport(toTpetraCrsMatrix(source), *tImporter.getTpetra_Import(), toTpetra(CM));
      mtx_->doImport(*v, toTpetra(importer), toTpetra(CM));
    }

    //! Export.
    void doExport(const DistObject<char,LocalOrdinal, GlobalOrdinal, Node> &dest,
                  const Import< LocalOrdinal, GlobalOrdinal, Node >& importer, CombineMode CM) {

      CTHULHU_DYNAMIC_CAST(const TpetraCrsMatrixClass, dest, tDest, "Cthulhu::TpetraCrsMatrix::doImport only accept Cthulhu::TpetraCrsMatrix as input arguments.");//TODO: remove and use toTpetra()
      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal,Node> > v = tDest.getTpetra_CrsMatrix();
      mtx_->doExport(*v, toTpetra(importer), toTpetra(CM)); 

    }

    //! Import (using an Exporter).
    void doImport(const DistObject<char,LocalOrdinal, GlobalOrdinal, Node> &source,
                  const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {

      CTHULHU_DYNAMIC_CAST(const TpetraCrsMatrixClass, source, tSource, "Cthulhu::TpetraCrsMatrix::doImport only accept Cthulhu::TpetraCrsMatrix as input arguments.");//TODO: remove and use toTpetra()
      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal,Node> > v = tSource.getTpetra_CrsMatrix();
      mtx_->doImport(*v, toTpetra(exporter), toTpetra(CM));

    }

    //! Export (using an Importer).
    void doExport(const DistObject<char,LocalOrdinal, GlobalOrdinal, Node> &dest,
                  const Export< LocalOrdinal, GlobalOrdinal, Node >& exporter, CombineMode CM) {

      CTHULHU_DYNAMIC_CAST(const TpetraCrsMatrixClass, dest, tDest, "Cthulhu::TpetraCrsMatrix::doImport only accept Cthulhu::TpetraCrsMatrix as input arguments.");//TODO: remove and use toTpetra()
      RCP< const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal,Node> > v = tDest.getTpetra_CrsMatrix();
      mtx_->doExport(*v, toTpetra(exporter), toTpetra(CM)); 

    }

    // @}

    //! @name Cthulhu specific
    //@{

    //! TpetraCrsMatrix constructor to wrap a Tpetra::CrsMatrix object
    TpetraCrsMatrix(const Teuchos::RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps> > &mtx) : mtx_(mtx) {  }

    //! Get the underlying Tpetra matrix
    RCP<const Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps> > getTpetra_CrsMatrix() const { return mtx_; }
    
    //! Get the underlying Tpetra matrix
    RCP<Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps> > getTpetra_CrsMatrixNonConst() const { return mtx_; } //TODO: remove
 
   //@}
    
  private:
    
    RCP< Tpetra::CrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps> > mtx_;

  }; // TpetraImport class

  // TODO: move that elsewhere
  // template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  // const Tpetra::DistObject<char, LocalOrdinal, GlobalOrdinal, Node> toTpetraCrsMatrix(const DistObject<char, LocalOrdinal, GlobalOrdinal, Node> &mtx) {
  //   typedef TpetraCrsMatrix<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps> TpetraCrsMatrixClass;
  //   CTHULHU_DYNAMIC_CAST(const TpetraCrsMatrixClass, mtx, tMtx, "toTpetra");
  //   return *tMtx.getTpetra_CrsMatrix();
  // }
  //

} // Cthulhu namespace

$TMPL_FOOTERS
