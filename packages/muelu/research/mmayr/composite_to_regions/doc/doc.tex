\documentclass[11pt]{article}
\usepackage{amsfonts}
\usepackage{amsmath}

\oddsidemargin    0.1in
\evensidemargin   0.1in
\textwidth        6.5in
\newcommand{\REMOVE}[1]{}
\def\optionbox#1#2{\noindent$\hphantom{hix}${\parbox[t]{2.10in}{\sf
#1}}{\parbox[t]{3.9in}{#2}} \\[1.1em]}



\begin{document}
\phantom{.}
\vspace{-1in}
\begin{center}\large
{\bf Using Trilinos Capabilities for Composite-To-Regional Transitions}
\end{center}
\vspace{.4in}

We assume that an application has a standard Trilinos-style matrix without any
notion of regions and shared interfaces within the CRS data structure. However,
the matrix does correspond to something regional. That is, the underlying
mesh used to create the matrix can be viewed as a union of structured matrices.
There are two cases that we want to address.
\newline
\vskip -.08in
\indent $\bullet$ {\sf RegionsSpanProcs}
\begin{quote}
       No processor owns more than one region. However, processors may own only
       a piece of a region (i.e., regions may be distributed across processors).
       An example is given below.
\end{quote}
\vspace{-.15in}
\begin{verbatim}
Composite
Owning   0  0  0  0  1  1  1  1  2  2  2  2  2  2  2  2  3  3  3  4  4  5  5  6
Proc

composite
GID      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
         |--------------------|-----------------------|-----------------------|
                   region 0             region 1               region 2

         no proc has more than 1 region, but region 0 and region 2 cross procs
\end{verbatim}
\vspace{-.1in}
\begin{quote}
Notice that though composite GID 7 is owned by proc 1, proc 2
will completely own region 1 and will not own anything associated with region 0
during regional computations. Thus, proc 2 will have a replicated copy of GID 7.
\end{quote}
\indent $\bullet$ {\sf MultipleRegionsPerProc}
\begin{quote}
       A processor may own more than one region, but no region can span across
       multiple processors. An example follows.
\end{quote}
\vspace{-.15in}
\begin{verbatim}
Composite
Owning   0  0  0  0  1  1  1  1  2  2  2  2  2  2  2  2  3  3  3  4  4  4  4  4
Proc

composite
GID      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
         |-----|-----|--------|-----|--------|--------|----|---|-----|--|-----|
            r0    r1     r2      r3     r4       r5     r6   r7   r8  r9   r10

         no regions cross procs, procs 0 & 3 have 2 regions
                                 procs 2 & 4 have 3 regions
                                 proc  1 has 1 region
\end{verbatim}
Note: I'm not completely sure that I have all the proc owners perfectly right for shared interfaces (e.g., whether GID 7 is owned by proc 1 or 2). I think most are right, but I'm not totally sure.
Though the two cases are fairly different, we are hoping that they can share code.  It is further assumed that applications can provide three additional pieces of information for each processor:
\begin{itemize}
\item an array {\sf myRegions} that gives all regions that {\sf myRank} owns (either fully or partially).
\item a multivector {\sf regionsPerGID} such that {\sf regionsPerGID[~j~][~i~]} gives the $j^{th}$ region that shares {\sf myRank}'s $i^{th}$ owned composite GID.  Here, $i$ is the local ID on {\sf myRank}.  The number of vectors within the multivector is equal to {\sf maxRegionsPerGID}, which is also given by the application. Minus ones are used when the number of regions sharing an owned
composite GID is less than {\sf maxRegionsPerGID}.
\item a function {\sf LIDregion(ptr,myLID,myRegionLID)} that returns the local regional ID on {\sf myRank} associated with {\sf myRegions[myRegionLID]}. This function must be defined for myLIDs associated with both owned and ghost nodes.
If a myLID is not part of {\sf myRegions[myRegionLID]}, then the function returns a minus one. {\sf ptr} is an application supplied void pointer that can be used by application to implement the function.
\end{itemize}

In the above two examples, {\sf maxRegionsPerGID}=2.
In our {\sf MultipleRegionsPerProc} example, proc 0's version of
{\sf regionsPerGID} would be
\vspace{-.1in}
\begin{verbatim}
                0  -1
                0  -1
                0   1
                1  -1
\end{verbatim}
\vspace{-.1in}
\noindent
The $3^{rd}$ line or row indicates that the $3^{rd}$ owned composite GID (= 2) belongs to region 0 and region 1. If a composite GID is shared by fewer than {\sf maxRegionsPerGID}, then it will have a series of -1's at the end of its corresponding {\sf regionsPerGID} row. In our {\sf RegionsSpanProcs} example, proc 2's version of  {\sf LIDregion(ptr,myLID,0)} would return $GID(myLID)-7$
for myLIDs associated with GIDs from 7 to 15. Proc 2 also has a ghostLID
associated with GID 16 where this function would return a minus one.

The main nasty task that we would like to handle via Epetra or Tpetra's Import() is the
extracting and replicating of rows/columns associated with regional matrices. This is
somewhat similar to overlapping Schwarz, though there are some differences. To accomplish
this task via Import() for both cases ({\sf RegionsSpanProcs } and
{\sf MultipleRegionsPerProc}), we introduce the  {\sf regionGroup} concept
to handle the {\sf MultipleRegionsPerProc}
situation. The basic idea is that even if processors own more than one region, they
will only have one region per {\sf regionGroup}. That is, the number of {\sf regionGroup}'s is equal to
{\sf maxRegionsPerProc}. The $i^{th}$ {\sf regionGroup} on proc k would be
{\sf myRegions[~i~]} if
i $<$ {\sf myRegions.size()}. Otherwise, the $i^{th}$ {\sf regionGroup} would be empty.
The {\sf regionGroup} idea allows us to perform an Import() in a way that replicates rows
associated with shared nodes and also breaks connections between nodes associated
with different regions. This is because within a {\sf regionGroup} each proc has only one
region. This means that any rows that need to be replicated within a {\sf regionGroup} will be on different processors as no proc can extract/build
multiple regional matrices (at the same time) that might require replication
of shared nodes.
Further, all $a_{ij}$ entries that must be discarded (to break connections between
matrix rows associated with different regions) correspond to cases where $i$
and $j$ reside within different processor portions of the rowMaps.
While there are inefficiency concerns with the {\sf regionGroup} idea we note
\begin{itemize}
   \item all processors have just one region in most situations
   \item we can often arrange things so that all processors have the
         same number of regions when multiple regions per proc are desired.
   \item it may be possible to cleverly re-arrange maps so that we can just do
      one communication instead of {\sf maxRegionsPerProc} communications when
      updating region vectors.
   \item we cannot do one Import() per region as this does not scale. Even if we have sub-communicators for regions, the composite matrix is owned by MPI\_Comm\_World and so each Import() must be done on all procs.
\end{itemize}
There are two main task to employ the proposed scheme
\begin{itemize}
   \item compute row/col maps to perform an Import() that extracts
      the desired regional sub-matrices

   \item compute  domain/range maps so matvec's work properly on newly
      extracted sub-matrices.
\end{itemize}

Understanding the second task requires more knowledge on the distinction
between range/domain maps and row/col maps. Here is my view ... (Matthias: I think that is correct).
\begin{itemize}
   \item when doing $y = A u$, the domain map determines what elements of u are
      stored on each processor while the range map determines the owned elements for y.

   \item the row/col map determine the $a_{ij}$'s owned by each processor. That is,
      a proc owns all $a_{ij}$'s associated with i's in its rowMap and all j's
      in its colMap.
\end{itemize}

So in extracting proper regional sub-matrices, we must pick row and column maps
that are a subset of the original composite column maps.
If we want to do matvecs, we need to operate on the regional vectors, which
will have domain/range maps that are bigger than the composite vector
domain/range maps. This means that we
need to make new domain/range maps where distinct GIDs are given to
the same shared node that is associated with different regions. This also
means that we need to change the row/col map after performing the extraction
so that they are consistent with the reworked domain/range map.
The proposed strategy is then to extract sub-matrices by specifying
row/col maps, and basically not worry about having the wrong range/domain
maps. Then, compute new maps with new GIDs and use the expertStaticFillComplete()
function in conjunction with the underlying raw CRS arrays from the extracted
matrices. Scary, but could work. Note that the new range map will be identical
to the new domain map and the new row map.  The new row/col map will have
the same GIDs as the old row/col map for any non-shared nodes. It will also
have the same GIDs as the old row/col map for the lowest numbered region
in any shared nodes.  For the other regions, a new id will be assigned according
to the following algorithm ...
\begin{quote}
$\bullet$ each proc goes through its owned version of {\sf regionsPerGID}
filling an array {\sf firstNewGID}
\end{quote}
\vspace{-.2in}
\begin{verbatim}
       firstNewGID[0]=0
       firstNewGID[1]=[#of regions (non -1s) for GID( 0 )]-1 + firstNewGID[0]
       firstNewGID[2]=[#of regions (non -1s) for GID( 1 )]-1 + firstNewGID[1]
       firstNewGID[k]=[#of regions (non -1s) for GID(k-1)]-1 + firstNewGID[k-1]
\end{verbatim}
\vspace{-.2in}
\begin{quote}
where $ 1 \le k < ${\sf nRows}. Then, define
\end{quote}
\vspace{-.2in}
\begin{verbatim}
       upperBndNumNewGIDs = firstNewGID[nRows-1]+maxRegPerGID-1
\end{verbatim}
\vspace{-.2in}
\begin{quote}
So {\sf firstNewGID[~k~]} gives the number of already reserved new GIDs
     (due to sharing within the first k-1 GIDs) and {\sf upperBndNumNewGIDs}
     is an upper bound on the total number of new GIDs that this proc creates.
     It is an upper bound because we assumed that the last composite node
     adds maxRegPerGID-1 new GIDs.
\end{quote}
\vspace{-.2in}
\begin{quote}
$\bullet$ {\sf upperBndNumNewGIDsAllProcs = max(upperBndNumNewGIDs)}
\end{quote}
\vspace{-.2in}
\begin{quote}
$\bullet$ an offset is added to {\sf firstNewGID} so that it now actually
corresponds to the first NewGID associated with each row of {\sf regionsPerGID}.
This offset is given by {\sf upperBndNewNewGIDsAllProc*myRank+nTotalCompIds}.
\end{quote}
\vspace{-.2in}
\begin{quote}
$\bullet$ procs communicate so that everyone has
ghosted version of {\sf firstNewGID} and {\sf regionsPerGID} .
\end{quote}
\vspace{-.2in}
\begin{quote}
$\bullet$ Let {\sf curRegion} (= {\sf myRegions[~k~]} where k is between 0
and {\sf maxRegPerProc}-1) denote the current region that this processor is
working on. The {\it basic} idea in assigning new GIDs to the extended
form of all maps (e.g., domain, range, row, col) is to
repeat the following for each owned or ghosted GID of
{\sf myRank}:
\begin{enumerate}
\item determine the position where curRegion resides within
      the list of regions shared by this GID.
\item when position == 0, take newGID = oldGID.
\item when position $> 0$,
\newline
       newGID = {\sf firstNewGID[~j~]}+position-1
when working on the $j^{th}$ GID.
\end{enumerate}
However, there are a couple of additional wrinkles. In particular,
we must put the maps in the proper order and we must distinguish
between entries that only go in the extended domain/range/row map and the
additional entries that go in the extended col map. To do this, we use the
function {\sf LIDregion()}. Specifically, only {\sf LIDregion()} queries that
do not return a minus one can go in the extended domain/range/row map
while those that do return a minus one (and are shared by {\sf curRegion})
will be appended to the end of the domain/range/row map lists to construct
the col map. Further, the results of {\sf LIDregion()} are stored and
sorted so that the domain/range/row maps will list GIDs in the right order.
\end{quote}

To build the row maps needed for extraction we basically do something like
\begin{verbatim}
   for (int i = 0; i < Nowned+Nghost; i++) tempRegIDs[i]=LIDregion(ptr,i,k);

   [sortedTemp,index] = sort(tempRegIDs);
   count = 0;
   for (int i = 0; i < Nowned+Nghost; i++) {
      if (sortedTemp[i] != -1) rowMap[count++] = compositeGID[index[i]];
   }
\end{verbatim}
Here, Matlab notation is used for the sort and k is the index into
{\sf myRegions[k]}.

\REMOVE{
in the {\sf MultipleRegionsPerProc}
case, we basically need to include any GID that is shared by the region that
we are working on in {\sf RegionGroup}. Notice that when two procs each
include a GID in their version of the new row map, this GID is associated
with two different regions (and so it needs to be replicated). This is
because the  {\sf MultipleRegionsPerProc} case excludes the possibility
that two procs are working on the same region.  The {\sf RegionsSpanProcs}
case is similar, except that two procs might own the same region. Thus,
we only want to add the same GID to two different processor's version
of the new row map when this GID corresponds to two different regions.
This is because the matrix row needs to be replicated whenever it corresponds
to a shared node residing in multiple regions. However, when a node
is not shared but belongs to the composite col map of multiple procs, we
do not want it replicated. We only want one proc to have this GID in its
row map. To do this, we start by taking all GIDs in {\sf myRank}'s
composite row map and adding this to the new row map. Notice that {\sf myRank}
owns only one region and so anything GID that it owns must be part of this
one region.  Next, {\sf myRank} looks in the ghost entries of its composite
col map and includes GIDs into the new map if this GID is an interface and
it belongs to my one and only region. If it is


                   proc bc
                     |
           region    |  region b
             a       o
                     |



. Notice that when two procs each
adding to the new row map all GIDs
adds any GID associated with my composite row map as I own only one region
and so all composite row map entries must be part of this region.




but is not owned by
and that I own
That is, add GID(k) if there is a $j$ such that {\sf regionsPerGID[~k~][~j~]}
corresponds to the region that we are working on.
}
\REMOVE{
For some reason,
I wrote a clever version of this for the {\sf RegionsSpanProcs} case.
This code builds a vector corresponding to composite col map with all -1's.

It
additionally adds any GID that is in col map but not in row map
    \begin{enumerate}
    \item  look at remaining -1's and change them to +1 if they
           correspond to a point with multiple regions (that includes my region)
           as this region interface must be included in my new row map.
    \end{enumerate}
    That is, a point is not a region interface if not associated with multiple
    regions. If this point is also a ghost GID, then it must not be interior
    to a region that {\sf myRank} owns. Thus, this GID does not need to be
    included in {\sf myRank}'s new row map. Further, there is a chance that
    some region interface GIDs among {\sf myRank}'s ghost GIDs are not actually
    associated with {\sf myRank}'s regions as
           ghost GIDs might extend into a neighboring region.
\end{quote}
\indent $\bullet$ {\sf MultipleRegionsPerProc}
\begin{quote}
    b) case 2: regions do not cross procs but a proc owns more than one region
         - compute the maximum # of regions that any proc has
         - set numRounds = maxNumRegPerProc
         - for i=1:numRounds
              curRegion = lowestRegOwnedByProc
              rowMap(round) = anyone in my compositeColMap that belongs to curRegion
           end
\end{quote}
}

To build the col maps needed for extraction, we first note that
the col map is equal to the row map when in the {\sf MultipleRegionsPerProc}
case. This is because a region is entirely owned by a processor so that
no ghosting is necessary (or its column map equalls its row map). In the
{\sf RegionsSpanProcs} case, the new col map is first initialized to the
new row map. Additional entries are appended corresponding to
i's where {\sf myRegionalLID(i,0)} returns a minus one and there is a $j$ such that
that {\sf regionsPerGID[~j~][~i~]=myRegions[~0~]}. That is, {\sf myRank}
has a ghost GID that associated with the one region that it owns but
this ghost GID does not have a {\sf myRegionalLID()} because it is owned
by another processor (that also owns my one region).

\section{Matlab interaction}
To test Trilinos functionality, a combination of Matlab and a Trilinos
C++ driver was constructed. The basic idea is to use Matlab for ``hard''
things that do not ultimately affect Trilinos-like design decisions while
restricting the C++ code to aspects that do affect the Trilinos-like design.
The way this is implemented is that one first runs the Matlab program in the source folder.
Then, establish a symbolic link to the C++ executable, but execute it also in the source
folder, since it relies on files written to the source folder by Matlab.

The Matlab program creates a series of myData\_k files where $ 0 \le k < nProcs$.
The file should contain a basic command and optionally some data associated
with that command. After the Matlab program has created a set of these
myData\_k files it waits (loops with a sleep) until they are removed by
the C++ program before proceeding. One executes the C++ via mpirun across
multiple procs. The program first opens a myData\_k file. This very first
myData\_k file should contain three entries separated by a single space
corresponding to {\sf maxRegPerGID}, {\sf maxRegPerProc}, and {\sf whichCase}.
The last entry is a string that should be either {\sf RegionsSpanProcs} or
{\sf MultipleRegionsPerProc}. The myData\_k file is deleted (so that Matlab
knows
to proceed) and then the program enters a big infinite while loop. This loop
opens a myData\_k file and executes one command per loop iteration.
Specifically, each loop iteration waits (inner loop with a sleep) for the
new myData\_k file.  Once it sees this file, it reads the command header.
The body of the main loop basically has a bunch of `if statements'
corresponding to the
different commands and so {\sf myRank} reads the rest of the data and
performs the associated task. The C++ file never needs to communicate
any data back to the Matlab program, but it indicates that it is finished
with the file by deleting it (signaling Matlab to proceed). Not sure if there
is some chance that the C++ program starts reading a myData\_k file before
the Matlab program has finished writing to it. This hasn't happened in my
tests. Some of the myData\_k commands are
\vskip .1in

\optionbox{LoadCompositeMap}{load the composite GIDs and the non-ghosted portion of {\sf regionsPerGID}. Each line that follows the command line corresponds to one entry of the composite GID. Later communication will be employed in the C++ program so that myRank has ghosted version of this information.}

\optionbox{LoadAndCommRegAssignments}{load non-ghosted portion of {\sf regionsPerGID}. Each jth line that follows the command line corresponds to all the regions in  the jth row of {\sf regionsPerGID} separated by spaces. The C++ program performs communication so that it has the ghosted version of this information.}

\optionbox{ReadMatrix}{read the file Amat.mm that contains the composite matrix}

\optionbox{LoadRegions}{load the {\sf myRegions} list which appears
                    immediately after the command (one region per line).}

\optionbox{MakeGrpRegRowMaps}{directs C++ program to make the new row maps.}

\optionbox{MakeGrpRegColMaps}{directs C++ program to make the new col maps.}

\optionbox{MakeExtendedRegGrpMaps}{directs C++ program to make the extended form of the domain and column maps. This extended form includes new GID numbers to address the replication of shared nodes in multiple regions.}

\optionbox{MakeQuasiRegionMatrices}{directs C++ program to extract regional matrices from the composite matrix. Results in correct data, but wrong maps.}

\optionbox{MakeRegMatrices}{directs C++ program to call expertStaticFillComplete on the extended region matrices in order to 'insert' correct range/domain maps into region matrices.}

\optionbox{LoadAppDataForLIDregion()}{loads data associated with the minimum and maximum nodes that myRank will own for each region. Here, `will own' refers to nodes that will be owned by myRank in the regional form of the matrices. However, the min/max values correspond to composite GIDs  Specifically, the $k$th line following the command line provides two numbers. The first number is the minimum associated with {\sf myRegions[~k~]} while the second number is the maximum.}

\optionbox{ComputeMatVecs}{direct C++ program to perform matrix-vector-multiplication in composite and regional form and to compare the results.}

\optionbox{PrintGrpRegRowMaps}{direct C++ program to print new row maps.}

\optionbox{PrintGrpRegColMaps}{directs C++ program to print new col maps.}

\optionbox{PrintGrpRegDomMaps}{directs C++ program to print new extended domain maps.}

\optionbox{PrintRevisedColMaps}{directs C++ program to print new extended col maps.}

\optionbox{PrintQuasiRegionMatrices}{directs C++ program to print quasiRegional matrices.}

\optionbox{PrintRegionMatrices}{directs C++ program to print regional matrices.}

\optionbox{PrintRegionMatrixRowMap}{directs C++ programm to print row map of region matrices.}

\optionbox{PrintRegionMatrixColMap}{directs C++ programm to print col map of region matrices.}

\optionbox{PrintRegionMatrixRangeMap}{directs C++ programm to print range map of region matrices.}

\optionbox{PrintRegionMatrixDomainMap}{directs C++ programm to print domain map of region matrices.}

\optionbox{PrintCompositeMap}{directs C++ program to print composite map.}

\optionbox{PrintRegionAssignments}{directs C++ program to print {\sf regionsPerGID}.}

\optionbox{PrintCompositeVectorX}{directs C++ program to print the composite input vector.}

\optionbox{PrintCompositeVectorY}{directs C++ program to print the composite result vector.}

\optionbox{PrintQuasiRegVectorX}{directs C++ program to print the quasiRegion input vector.}

\optionbox{PrintQuasiRegVectorY}{directs C++ program to print the quasiRegion result vector.}

\optionbox{PrintRegVectorX}{directs C++ program to print the region input vector.}

\optionbox{PrintRegVectorY}{directs C++ program to print the region result vector.}

\optionbox{PrintRegVectorYComp}{directs C++ program to print the composite result vector that is reconstructed from the region result vector.}

\optionbox{Terminate}{C++ program exits.}

For some of the `Make*' commands, the Matlab program is also able to construct the same information and so this can be compared with the C++ program.
The original intention was that there would be some additional commands to
initialize vectors, convert from composite to regional views, and do matvecs ...but this is not done right now.
\REMOVE{Some of these commands appeared in an earlier
version (that was based on a different composite/region philosophy that
was deemed not scalable).
}

\section{Description Thoughts}
\subsection{Groups}
The notion of a group is introduced primarily to handle the case when
processors are assigned multiple regions (and so no region spans
across multiple processors). In particular, the number of groups is
equal to the maximum number of regions that can be assigned to
any processor. Only one region per processor is assigned to a group.
In this way, both cases ({\sf regionsSpanProcs} and
{\sf multipleRegionsPerProc}) correspond to a processor owning (perhaps only
partially) at most one region within a group.
Generally, this simplifies the implementation because the required
replication of any region interface node must occur across processors.
That is, each version of a replicated node will lie on different
processors within a group. This appears to be a key assumption to employ various
Trilinos {\sf Import()}/{\sf Export()} capabilities as these have
some `one-to-one' (or non-overlappng) restrictions that we
do not completely understand.
Specifically, the replication of matrix rows/columns more closely
resembles what occurs in overlapping Schwarz. Each processor
receives rows from neighbors associated with some of its ghost
unknowns. The main difference between the {\sf regionsSpanProcs} and
{\sf multipleRegionsPerProc} cases is in the regional column maps.
When each processor owns an entire region (as must always
be true for the {\sf multipleRegionsPerProc} case and is sometimes
true in the {\sf regionsSpanProcs} case), the regional column map is equal
to the regional row map as there is no communication across regions, implying
no communication between processors. When processors own a piece of
a region, then communication must occur within a region and so
the regional column map should include the ghost nodes that correspond
to the same region.

\subsection{quasiRegional matrices}
Employing Trilinos {\sf Import()}/{\sf Export()} capabilities is extremely convenient
in minimizing the coding effort. However, there are some tricky aspects
of working with overlapping maps. With an overlapping map, some GIDs
might appear more than once within the map (though any repeated GIDs
will appear on different processors). When performing regional
operations, however, we often need a replicated node to act as
a set of distinct degrees-of-freedom (e.g., different vector values within
different regions for the same node during most multigrid operations).
For this reason, we will need to introduce new GID numbers to handle
this case. To make this distinction clear, we introduce a notion of a
quasiRegional matrix and vector. Specifically, the quasiRegional form refers to matrices and vectors where the local representation of the data is correct for
regional computations, but the maps are not correct in terms of
representing shared nodes distinctly. That is, data is replicated properly
to represent a regional matrix, but the GIDs in the maps still refer to the composite form of the data, implying that the maps are not
correct. The conversion of vectors or matrices from the
composite representation to the regional representation can be viewed as
first as a conversion from composite to quasiRegional  followed by
a second conversion from quasiRegional to regional.
\begin{enumerate}
 \item {\bf composite to quasiRegional:} This conversion uses an {\sf Import()} operation
 to extract the regional data from composite matrix/vector objects, but uses quasi maps
 for the regional objects. These quasi maps have the same GIDs
 as the composite map. The quasi row map is similar to the composite
 map with the exception that some interface entries are replicated.
 \item {\bf quasiRegional to regional:} This conversion from quasiRegional to regional corresponds
 only to changing the maps and not making any changes to the data layout and the data itself.
 It keeps the data from the quasiRegional objects,
 but forms objects based on true regional maps.
 The true regional map, however, has new GIDs to represent replicated values.
\end{enumerate}
We also need to transform vectors from the regional layout back to the composite layout. Therefore, we just reverse the aforementioned process, i.e. we
\begin{enumerate}
 \item replace the vector's map with the quasiRegional map, but keep its data.
 \item perform an {\sf Export()} operation to the composite map layout using the {\sf CombineMode = Epetra\_AddLocalAlso}.
\end{enumerate}

\section{Future Direction Thoughts}
Basically, the tasks that have to happen next include
\begin{itemize}
\item Add the four main functions needed to perform a regional matvec:
     {\sf composite2Regional()}, {\sf regional2Composite()}, {\sf quasiRegional2Regional()},
     and {\sf scaleMatrixInterfaceEntries()}. One great thing about doing this
     first is that we can easily test code correctness by comparing regional
     matvecs with composite matvecs. {\sf quasiRegional2Regional()} would
     employ the {\sf expertStaticFillComplete()} with the proper revised
     row and column maps that are currently being computed.  I believe the
     {\sf composite2Regional()} should be a pretty trivial piece of code
     as it correspond to the vector version of the matrix conversion
     between composite and regional. Here, we employ an import with
     the quasi-regional maps to get the proper data but the regional
     maps are stuffed into the resulting vector. {\sf regional2Composite()}
     is probably similar, but might use {\sf Export()}  and might have some
     other minor differences. {\sf scaleMatrixInterfaceEntries()} should
     be pretty easy in the 1D case (basically dividing some entries
     by two). This could perhaps be generalized using the {\sf regionsPerGID}
     data. The main thing here is that the sum of the regional matrices
     must add up to the original composite matrix.
\item Make a 2D example and test/debug/update code for this case. Theoretically,
      most of the code should be the same, but there might be debugging
      as 2D will stress some code aspects.
\item Convert existing code from non-RCP/Epetra pointers to something
      more consistent with current needs (RCP/Tpetra).
\item Make a regional Jacobi and compare this to a composite form of Jacobi.
\item Apply separate {\sf MueLu} invocations for each group and perhaps
      for each region? on the 1D problem to make a 2 level solver. Not sure
      if we should try to use
      Luc's geometric or SA or if we should write our own simple 1D interpolator
      to test the idea. There might be issues using Luc's code with one
      invocation that contains multiple disconnected matrices? We should
      probably discuss this with him.
\item Try to do some simple two level MG with {\sf MueLu} where basically we are
      not using MueLu's V cycle but are instead doing our own. This avoids
      worrying about things like blocked operators at this point.
\end{itemize}

\section{Random Thoughts}
Overall, I'm leaning towards requiring that applications either supply
the regional form of the matrix ... or ... we are allowed to modify
their matrix to change entries to perform the simple splitting. There
is a chance that we could scale the matrix back after we are finished
so that it appears to the application as unmodified. It might also be
nice if we could optionally remove the application composite matrix once
we have formed the regional matrices (to save on space). Thus, we would
need to use the regional matvec in conjunction with {\sf region2Composite()}
and {\sf composite2Region()} when performing matvecs within the Krylov solver.







\end{document}



