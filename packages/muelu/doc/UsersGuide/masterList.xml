<masterlist>

  <general>

    <parameter>
      <name>problem: type</name>
      <type>string</type>
      <default>"unknown"</default>
      <description>Type of problem to be solved.  Possible values: see Table~\ref{t:problem_types}.</description>
    </parameter>

    <parameter>
      <name>verbosity</name>
      <type>string</type>
      <default>"high"</default>
      <description>Control of the amount of printed information. Possible values: "none", "low", "medium", "high", "extreme".</description>
    </parameter>

    <parameter>
      <name>number of equations</name>
      <type>int</type>
      <default>1</default>
      <default>1</default>
      <Poisson-2D>1</Poisson-2D>
      <Poisson-3D>1</Poisson-3D>
      <Elasticity-2D>2</Elasticity-2D>
      <Elasticity-3D>3</Elasticity-3D>
      <description>Number of PDE equations at each grid node. Only constant block size is considered.</description>
    </parameter>

    <parameter>
      <name>max levels</name>
      <type>int</type>
      <default>10</default>
      <description>Maximum number of levels in a hierarchy.</description>
    </parameter>

    <parameter>
      <name>cycle type</name>
      <type>string</type>
      <default>"V"</default>
      <description>Multigrid cycle type. Possible values: "V", "W".</description>
    </parameter>

    <parameter>
      <name>problem: symmetric</name>
      <type>bool</type>
      <default>true</default>
      <ConvectionDiffusion>false</ConvectionDiffusion>
      <description>Symmetry of a problem. This setting affects the construction of a restrictor. If set to true, the restrictor is set to be the transpose of a prolongator. If set to false, underlying multigrid algorithm makes the decision.</description>
    </parameter>

  </general>

  <smoothing_and_coarse>

    <parameter>
      <name>smoother: pre or post</name>
      <type>string</type>
      <default>"both"</default>
      <description>Pre- and post-smoother combination. Possible values: "pre" (only pre-smoother), "post" (only post-smoother), "both" (both pre-and post-smoothers), "none" (no smoothing).</description>
    </parameter>

    <parameter>
      <name>smoother: type</name>
      <type>string</type>
      <default>"RELAXATION"</default>
      <Poisson-2D>"CHEBYSHEV"</Poisson-2D>
      <Poisson-3D>"CHEBYSHEV"</Poisson-3D>
      <Elasticity-2D>"CHEBYSHEV"</Elasticity-2D>
      <Elasticity-3D>"CHEBYSHEV"</Elasticity-3D>
      <MHD>"SCHWARZ"</MHD>
      <ConvectionDiffusion>"RELAXATION"</ConvectionDiffusion>
      <description>Smoother type. Possible values: see Table~\ref{tab:smoothers}.</description>
    </parameter>

    <parameter>
      <name>smoother: pre type</name>
      <type>string</type>
      <default>"RELAXATION"</default>
      <description>Pre-smoother type. Possible values: see Table~\ref{tab:smoothers}.</description>
    </parameter>

    <parameter>
      <name>smoother: post type</name>
      <type>string</type>
      <default>"RELAXATION"</default>
      <description>Post-smoother type. Possible values: see Table~\ref{tab:smoothers}.</description>
    </parameter>

    <parameter>
      <name>smoother: params</name>
      <type>\parameterlist</type>
      <MHD>
        <parameter>
          <name>schwarz: overlap level</name>
          <type>int</type>
          <default>1</default>
        </parameter>
        <parameter>
          <name>schwarz: combine mode</name>
          <type>string</type>
          <default>"Zero"</default>
        </parameter>
        <parameter>
          <name>schwarz: use reordering</name>
          <type>bool</type>
          <default>false</default>
        </parameter>

        <parameter>
          <name>subdomain solver name</name>
          <type>string</type>
          <default>"RILUK"</default>/>
        </parameter>
        <parameter>
          <name>subdomain solver parameters</name>
          <type>\parameterlist</type>

            <parameter>
              <name>fact: iluk level-of-fill</name>
              <type>int</type>
              <default>0</default>
            </parameter>

            <parameter>
              <name>fact: absolute threshold</name>
              <type>double</type>
              <default>0.</default>
            </parameter>

            <parameter>
              <name>fact: relative threshold</name>
              <type>double</type>
              <default>1.</default>
            </parameter>

            <parameter>
              <name>fact: relax value</name>
              <type>double</type>
              <default>0.</default>
            </parameter>
        </parameter>
      </MHD>
      <ConvectionDiffusion>
        <parameter>
          <name>relaxation: type</name>
          <type>string</type>
          <default>"Gauss-Seidel"</default>
        </parameter>
      </ConvectionDiffusion>
      <description>Smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.</description>
    </parameter>

    <parameter>
      <name>smoother: pre params</name>
      <type>\parameterlist</type>
      <description>Pre-smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.</description>
    </parameter>

    <parameter>
      <name>smoother: post params</name>
      <type>\parameterlist</type>
      <description>Post-smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.</description>
    </parameter>

    <parameter>
      <name>smoother: overlap</name>
      <type>int</type>
      <default>0</default>
      <description>Smoother subdomain overlap.</description>
    </parameter>

    <parameter>
      <name>smoother: pre overlap</name>
      <type>int</type>
      <default>0</default>
      <description>Pre-smoother subdomain overlap.</description>
    </parameter>

    <parameter>
      <name>smoother: post overlap</name>
      <type>int</type>
      <default>0</default>
      <description>Post-smoother subdomain overlap.</description>
    </parameter>

    <parameter>
      <name>coarse: max size</name>
      <type>int</type>
      <default>2000</default>
      <description>Maximum dimension of a coarse grid. \muelu will stop coarsening once it is achieved.</description>
    </parameter>

    <parameter>
      <name>coarse: type</name>
      <type>string</type>
      <default>"SuperLU"</default>
      <description>Coarse solver. Possible values: see Table~\ref{tab:coarse_solvers}.</description>
    </parameter>

    <parameter>
      <name>coarse: params</name>
      <type>\parameterlist</type>
      <description>Coarse solver parameters. \muelu passes them directly to the appropriate package library.</description>
    </parameter>

    <parameter>
      <name>coarse: overlap</name>
      <type>int</type>
      <default>0</default>
      <description>Coarse solver subdomain overlap.</description>
    </parameter>

  </smoothing_and_coarse>

  <aggregation>

    <parameter>
      <name>aggregation: type</name>
      <type>string</type>
      <default>"uncoupled"</default>
      <description>Aggregation scheme. Possible values: see Table~\ref{t:aggregation}.</description>

    </parameter>

    <parameter>
      <name>aggregation: ordering</name>
      <type>string</type>
      <default>"natural"</default>
      <description>Node ordering strategy. Possible values: "natural" (local index order), "graph" (filtered graph breadth-first order), "random" (random local index order).</description>
    </parameter>

    <!--
    <parameter>
      <name>aggregation: symmetrize</name>
      <type>bool</type>
      <default>false</default>
      <description>Symmetrize connectivity graph for nonsymmetric matrices.</description>
    </parameter>
    -->

    <parameter>
      <name>aggregation: drop scheme</name>
      <type>string</type>
      <default>"classical"</default>
      <description>Connectivity dropping scheme for a graph used in aggregation. Possible values: "classical", "distance laplacian".</description>
    </parameter>

    <parameter>
      <name>aggregation: drop tol</name>
      <type>double</type>
      <default>0.0</default>
      <description>Connectivity dropping threshold for a graph used in aggregation.</description>
    </parameter>

    <parameter>
      <name>aggregation: min agg size</name>
      <type>int</type>
      <default>2</default>
      <description>Minimum size of an aggregate.</description>
      <visible>true</visible>
    </parameter>

    <parameter>
      <name>aggregation: max agg size</name>
      <type>int</type>
      <default>-1</default>
      <description>Maximum size of an aggregate (-1 means unlimited).</description>
      <visible>true</visible>
    </parameter>

    <parameter>
      <name>aggregation: max selected neighbors</name>
      <type>int</type>
      <default>0</default>
      <description>Maximum number of neighbour nodes that are already aggregated. If a new aggregate has some neighbours that are already aggregated, this node probably can be added to one of these aggregates. We don't need a new one.</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>aggregation: Dirichlet threshold</name>
      <type>double</type>
      <default>0.0</default>
      <description>Threshold for determining whether entries are zero during Dirichlet row detection.</description>
    </parameter>

    <parameter>
      <name>aggregation: enable phase 1</name>
      <type>bool</type>
      <default>true</default>
      <description>Turn on/off phase 1 of aggregation</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>aggregation: enable phase 2a</name>
      <type>bool</type>
      <default>true</default>
      <description>Turn on/off phase 2a of aggregation</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>aggregation: enable phase 2b</name>
      <type>bool</type>
      <default>true</default>
      <description>Turn on/off phase 2b of aggregation</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>aggregation: enable phase 3</name>
      <type>bool</type>
      <default>true</default>
      <description>Turn on/off phase 3 of aggregation</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>aggregation: preserve Dirichlet points</name>
      <type>bool</type>
      <default>false</default>
      <description>Turn on/off Dirichlet points preservation</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>aggregation: export visualization data</name>
      <type>bool</type>
      <default>false</default>
      <description>Export data for visualization post-processing.</description>
    </parameter>

    <parameter>
      <name>aggregation: mode</name>
      <type>string</type>
      <default>"old"</default>
      <MHD>"new"</MHD>
      <Poisson-2D>"new"</Poisson-2D>
      <Poisson-3D>"new"</Poisson-3D>
      <Elasticity-2D>"new"</Elasticity-2D>
      <Elasticity-3D>"new"</Elasticity-3D>
      <ConvectionDiffusion>"new"</ConvectionDiffusion>
      <description>old = Tobias, new = ML</description>
      <visible>false</visible>
    </parameter>

  </aggregation>

  <misc>

    <parameter>
      <name>export data</name>
      <type>\parameterlist</type>
      <description>Exporting a subset of the hierarchy data in a file. Currently, the list can contain any of three parameter names ("A", ``P'', ``R'') of type \texttt{string} and value ``\{levels separated by commas\}''. A matrix with a name ``X'' is saved in three MatrixMarket files: a) data is saved in \textit{X\_level.mm}; b) its row map is saved in \textit{rowmap\_X\_level.mm}; c) its column map is saved in \textit{colmap\_X\_level.mm}.</description>
    </parameter>

    <parameter>
      <name>print initial parameters</name>
      <type>bool</type>
      <default>true</default>
      <description>Print parameters provided for a hierarchy construction.</description>
    </parameter>

    <parameter>
      <name>print unused parameters</name>
      <type>bool</type>
      <default>true</default>
      <description>Print parameters unused during a hierarchy construction.</description>
    </parameter>

    <parameter>
      <name>transpose: use implicit</name>
      <type>bool</type>
      <default>false</default>
      <MHD>true</MHD>
      <description>Use implicit transpose for the restriction operator.</description>
    </parameter>

  </misc>

  <multigrid>

    <parameter>
      <name>multigrid algorithm</name>
      <type>string</type>
      <default>"sa"</default>
      <Poisson-2D>"sa"</Poisson-2D>
      <Poisson-3D>"sa"</Poisson-3D>
      <Elasticity-2D>"sa"</Elasticity-2D>
      <Elasticity-3D>"sa"</Elasticity-3D>
      <MHD>"unsmoothed"</MHD>
      <ConvectionDiffusion>"pg"</ConvectionDiffusion>
      <description>Multigrid method. Possible values: see Table~\ref{t:mgs}.</description>
    </parameter>

    <parameter>
      <name>semicoarsen: coarsen rate</name>
      <type>int</type>
      <default>3</default>
      <description>Rate at which to coarsen unknowns in the z direction.</description>
    </parameter>

    <parameter>
      <name>sa: damping factor</name>
      <type>double</type>
      <default>1.33</default>
      <description>Damping factor for smoothed aggregation.</description>
    </parameter>

    <parameter>
      <name>sa: use filtered matrix</name>
      <type>bool</type>
      <default>true</default>
      <ConvectionDiffusion>true</ConvectionDiffusion>
      <description>Matrix to use for smoothing the tentative prolongator. The two options are: to use the original matrix, and to use the filtered matrix with filtering based on filtered graph used for aggregation.</description>
    </parameter>

    <parameter>
      <name>sa: calculate eigenvalue estimate</name>
      <type>bool</type>
      <default>false</default>
      <description>Force calculation of eigenvalue estimate during prolongator smoothing.</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>sa: eigenvalue estimate num iterations</name>
      <type>int</type>
      <default>10</default>
      <description>Number of power iterations to use to estimate max eigenvalue. This has effect only if estimation occurs during prolongator smoothing.</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>filtered matrix: use lumping</name>
      <type>bool</type>
      <default>true</default>
      <description>Lump (add to diagonal) dropped entries during the construction of a filtered matrix. This allows user to preserve constant nullspace.</description>
    </parameter>

    <parameter>
      <name>filtered matrix: reuse eigenvalue</name>
      <type>bool</type>
      <default>true</default>
      <description>Skip eigenvalue calculation during the construction of a filtered matrix by reusing eigenvalue estimate from the original matrix. This allows us to skip heavy computation, but may lead to poorer convergence.</description>
    </parameter>

    <parameter>
      <name>filtered matrix: reuse graph</name>
      <type>bool</type>
      <default>true</default>
      <description>Set values to zero instead of constructing a new graph.</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>emin: iterative method</name>
      <type>string</type>
      <default>"cg"</default>
      <description>Iterative method to use for energy minimization of initial prolongator in energy-minimization. Possible values: "cg" (conjugate gradient), "sd" (steepest descent).</description>
    </parameter>

    <parameter>
      <name>emin: num iterations</name>
      <type>int</type>
      <default>2</default>
      <description>Number of iterations to minimize initial prolongator energy in energy-minimization.</description>
    </parameter>

    <parameter>
      <name>emin: num reuse iterations</name>
      <type>int</type>
      <default>1</default>
      <description>Number of iterations to minimize the reused prolongator energy in energy-minimization.</description>
    </parameter>

    <parameter>
      <name>emin: pattern</name>
      <type>string</type>
      <default>"AkPtent"</default>
      <description>Sparsity pattern to use for energy minimization. Possible values: "AkPtent".</description>
    </parameter>

    <parameter>
      <name>emin: pattern order</name>
      <type>int</type>
      <default>1</default>
      <description>Matrix order for the "AkPtent" pattern.</description>
    </parameter>

  </multigrid>

  <rebalancing>
    <parameter>
      <name>repartition: enable</name>
      <type>bool</type>
      <default>false</default>
      <description>Rebalancing on/off switch.</description>
    </parameter>

    <parameter>
      <name>repartition: partitioner</name>
      <type>string</type>
      <default>"zoltan2"</default>
      <description>Partitioning package to use. Possible values: "zoltan" (\zoltan{} library), "zoltan2" (\zoltantwo{} library).</description>
    </parameter>

    <parameter>
      <name>repartition: params</name>
      <type>\parameterlist</type>
      <description>Partitioner parameters. \muelu passes them directly to the appropriate package library.</description>
    </parameter>

    <parameter>
      <name>repartition: start level</name>
      <type>int</type>
      <default>2</default>
      <description>Minimum level to run partitioner. \muelu does not rebalance levels finer than this one.</description>
    </parameter>

    <parameter>
      <name>repartition: min rows per proc</name>
      <type>int</type>
      <default>800</default>
      <description>Minimum number of rows per processor. If the actual number if smaller, then rebalancing occurs.</description>
    </parameter>

    <parameter>
      <name>repartition: max imbalance</name>
      <type>double</type>
      <default>1.2</default>
      <description>Maximum nonzero imbalance ratio. If the actual number is larger, the rebalancing occurs.</description>
    </parameter>

    <parameter>
      <name>repartition: remap parts</name>
      <type>bool</type>
      <default>true</default>
      <description>Postprocessing for partitioning to reduce data migration.</description>
    </parameter>

    <parameter>
      <name>repartition: remap num values</name>
      <type>int</type>
      <default>4</default>
      <description>Number of maximum components from each processor used to construct partial bipartite graph.</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>repartition: print partition distribution</name>
      <type>bool</type>
      <default>false</default>
      <description>Partition distribution printout.</description>
      <visible>false</visible>
    </parameter>

    <parameter>
      <name>repartition: rebalance P and R</name>
      <type>bool</type>
      <default>true</default>
      <description>Explicit rebalancing of R and P during the setup. This speeds up the solve, but slows down the setup phases.</description>
    </parameter>

  </rebalancing>

</masterlist>
