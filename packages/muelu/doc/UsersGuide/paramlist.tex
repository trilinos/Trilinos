
\cbb{problem: type}{string}{"unknown"}{Type of problem to be solved. Possible values: see Table~\ref{t:problem_types}.}
          
\cbb{verbosity}{string}{"high"}{Control of the amount of printed information. Possible values: see Table~\ref{t:verbosity_types}.}
          
\cbb{output filename}{string}{""}{Write MueLu output to a file instead of std out. Empty value disables file output.}
          
\cbb{number of equations}{int}{1}{Number of PDE equations at each grid node. Only constant block size is considered.}
          
\cbb{max levels}{int}{10}{Maximum number of levels in a hierarchy.}
          
\cbb{cycle type}{string}{"V"}{Multigrid cycle type. Possible values: "V", "W".}
          
\cbb{W cycle start level}{int}{0}{Level at which to start multigrid W cycle.}
          
\cbb{number of vectors}{int}{1}{Number of columns in multivectors that are cached for Hierarchy apply phase.}
          
\cbb{problem: symmetric}{bool}{true}{Symmetry of a problem. This setting affects the construction of a restrictor. If set to true, the restrictor is set to be the transpose of a prolongator. If set to false, underlying multigrid algorithm makes the decision.}
          
\cbb{xml parameter file}{string}{""}{An XML file from which to read additional
      parameters.  In case of a conflict, parameters manually set on
      the list will override parameters in the file. If the string is
      empty a file will not be read.}
          
\cbb{hierarchy label}{string}{""}{Label for the hierarchy. Is applied to timer labels.}
          
\cbb{smoother: pre or post}{string}{"both"}{Pre- and post-smoother combination. Possible values: "pre" (only pre-smoother), "post" (only post-smoother), "both" (both pre-and post-smoothers), "none" (no smoothing).}
          
\cbb{smoother: type}{string}{"RELAXATION"}{Smoother type. Possible values: see Table~\ref{tab:smoothers}.}
          
\cbb{smoother: pre type}{string}{"RELAXATION"}{Pre-smoother type. Possible values: see Table~\ref{tab:smoothers}.}
          
\cbb{smoother: post type}{string}{"RELAXATION"}{Post-smoother type. Possible values: see Table~\ref{tab:smoothers}.}
          
\cba{smoother: params}{\parameterlist}{Smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.}
          
\cba{smoother: pre params}{\parameterlist}{Pre-smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.}
          
\cba{smoother: post params}{\parameterlist}{Post-smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.}
          
\cbb{smoother: overlap}{int}{0}{Smoother subdomain overlap.}
          
\cbb{smoother: pre overlap}{int}{0}{Pre-smoother subdomain overlap.}
          
\cbb{smoother: post overlap}{int}{0}{Post-smoother subdomain overlap.}
          
\cbb{coarse: max size}{int}{2000}{Maximum dimension of a coarse grid. \muelu will stop coarsening once it is achieved.}
          
\cbb{coarse: type}{string}{"SuperLU"}{Coarse solver. Possible values: see Table~\ref{tab:coarse_solvers}.}
          
\cba{coarse: params}{\parameterlist}{Coarse solver parameters. \muelu passes them directly to the appropriate package library.}
          
\cbb{coarse: overlap}{int}{0}{Coarse solver subdomain overlap.}
          
\cbb{aggregation: type}{string}{"uncoupled"}{Aggregation scheme. Possible values: see Table~\ref{t:aggregation}.}
          
\cbb{aggregation: mode}{string}{"uncoupled"}{Controls whether aggregates are allowed to cross processor boundaries. Possible values: "coupled" aggregates can cross processor boundaries, "uncoupled" aggregates cannot cross processor boundaries.}
          
\cbb{aggregation: ordering}{string}{"natural"}{Node ordering strategy. Possible values: "natural" (local index order), "graph" (filtered graph breadth-first order), "random" (random local index order).}
          
\cbb{aggregation: drop scheme}{string}{"classical"}{Connectivity dropping scheme for a graph used in aggregation. Possible values: "classical", "distance laplacian", "unsupported vector smoothing".}
          
\cbb{aggregation: drop tol}{double}{0.0}{Connectivity dropping threshold for a graph used in aggregation.}
          
\cbb{aggregation: min agg size}{int}{2}{Minimum size of an aggregate.}
          
\cbb{aggregation: max agg size}{int}{-1}{Maximum size of an aggregate (-1 means unlimited).}
          
\cbb{aggregation: compute aggregate qualities}{bool}{false}{Whether to compute aggregate quality estimates.}
          
\cbb{aggregation: brick x size}{int}{2}{Number of points for x axis in "brick" aggregation (limited to 3).}
          
\cbb{aggregation: brick y size}{int}{2}{Number of points for y axis in "brick" aggregation (limited to 3).}
          
\cbb{aggregation: brick z size}{int}{2}{Number of points for z axis in "brick" aggregation (limited to 3).}
          
\cbb{aggregation: brick x Dirichlet}{bool}{false}{Asserts that Dirichlet conditions are applied in
        the x-direction and the Dirichlet DOFs are not aggregated.}
          
\cbb{aggregation: brick y Dirichlet}{bool}{false}{Asserts that Dirichlet conditions are applied in
        the y-direction and the Dirichlet DOFs are not aggregated.}
          
\cbb{aggregation: brick z Dirichlet}{bool}{false}{Asserts that Dirichlet conditions are applied in
        the z-direction and the Dirichlet DOFs are not aggregated.}
          
\cbb{aggregation: Dirichlet threshold}{double}{0.0}{Threshold for determining whether entries are zero during Dirichlet row detection.}
          
\cbb{aggregation: deterministic}{bool}{false}{Boolean indicating whether or not aggregation will be run deterministically in the kokkos refactored path (only used in uncoupled aggregation).}
          
\cbb{aggregation: coloring algorithm}{string}{serial}{Choice of distance 2 coloring algorithm used by Uncoupled Aggregation. Currently set by defulat to COLORING_D2_SERIAL.}
          
\cbb{aggregation: export visualization data}{bool}{false}{Export data for visualization post-processing.}
          
\cbb{aggregation: output filename}{string}{""}{Filename to write VTK visualization data to.}
          
\cbb{aggregation: output file: time step}{int}{0}{Time step ID for non-linear problems.}
          
\cbb{aggregation: output file: iter}{int}{0}{Iteration for non-linear problems.}
          
\cbb{aggregation: output file: agg style}{string}{Point Cloud}{Style of aggregate visualization.}
          
\cbb{aggregation: output file: fine graph edges}{bool}{false}{Whether to draw all fine node connections along with the aggregates.}
          
\cbb{aggregation: output file: coarse graph edges}{bool}{false}{Whether to draw all coarse node connections along with the aggregates.}
          
\cbb{aggregation: output file: build colormap}{bool}{false}{Whether to output a random colormap in a separate XML file.}
          
\cbb{aggregation: mesh layout}{string}{Global Lexicographic}{Type of ordering for structured mesh aggregation. Possible values: "Global Lexicographic" and "Local Lexicographic".}
          
\cbb{aggregation: output type}{string}{Aggregates}{Type of object holding the aggregation data. Possible values: "Aggregates" or "CrsGraph".}
          
\cbb{aggregation: coarsening rate}{string}{{3}}{Coarsening rate per spatial dimensions, the string must be interpretable as an array by Teuchos.}
          
\cbb{aggregation: number of spatial dimensions}{int}{3}{The number of spatial dimensions in the problem.}
          
\cbb{aggregation: coarsening order}{int}{0}{The interpolation order used while constructing these aggregates, this value will be passed to the prolongator factory.}
          
\cbb{aggregate qualities: check symmetry}{bool}{false}{Whether to check symmetry and use nonsymmetric aggregate quality estimate if necessary.}
          
\cbb{aggregate qualities: good aggregate threshold}{double}{100.0}{Maximum quality where aggregate is considered acceptable.}
          
\cbb{aggregate qualities: file output}{bool}{false}{Whether to output files containing the aggregate qualities.}
          
\cbb{aggregate qualities: file base}{string}{agg_qualities}{Base of filename for aggregate quality output.}
          
\cbb{aggregate qualities: algorithm}{string}{forward}{Which aggregate qualtiy algorithm to use:
      ``forward'' or ``reverse.''  The forward algorithm uses the
      ``A'' matrix in the denominator of the generalized eigenvalue
      problem.  The reverse algorithm uses it in the numerator.}
          
\cbb{aggregate qualities: zero threshold}{double}{1e-12}{The zero threshold for the reverse algorithm.}
          
\cbb{aggregate qualities: percentiles}{Array(double)}{{}}{Percentiles of aggregate qualities to report (in a [0,1] range).}
          
\cba{export data}{\parameterlist}{Exporting a subset of the hierarchy data in a
      file. Currently, the list can contain any of the following parameter
      names (``A'', ``P'', ``R'', ``Nullspace'', ``Coordinates'') of type \texttt{string}
      and value ``\{levels separated by commas\}''. A
      matrix/multivector with a name ``X'' is saved in two or three
      three MatrixMarket files: a) data is saved in
      \textit{X\_level.mm}; b) its row map is saved in
      \textit{rowmap\_X\_level.mm}; c) its column map (for matrices) is saved in
      \textit{colmap\_X\_level.mm}.}
          
\cbb{print initial parameters}{bool}{true}{Print parameters provided for a hierarchy construction.}
          
\cbb{print unused parameters}{bool}{true}{Print parameters unused during a hierarchy construction.}
          
\cbb{transpose: use implicit}{bool}{false}{Use implicit transpose for the restriction operator.}
          
\cbb{use kokkos refactor}{bool}{false}{Switch on the new \kokkos based version for on-node parallelism.}
          
\cbb{rap: triple product}{bool}{false}{Use all-at-once triple matrix product kernel}
          
\cbb{multigrid algorithm}{string}{"sa"}{Multigrid method. Possible values: see Table~\ref{t:mgs}.}
          
\cbb{semicoarsen: coarsen rate}{int}{3}{Rate at which to coarsen unknowns in the z direction.}
          
\cbb{sa: damping factor}{double}{1.33}{Damping factor for smoothed aggregation.}
          
\cbb{sa: use filtered matrix}{bool}{true}{Matrix to use for smoothing the tentative prolongator. The two options are: to use the original matrix, and to use the filtered matrix with filtering based on filtered graph used for aggregation.}
          
\cbb{interp: interpolation order}{int}{1}{Interpolation order used to interpolate values from coarse points to fine points. Possible values are 0 for piece-wise constant interpolation and 1 for piece-wise linear interpolation. This parameter is set to 1 by default.}
          
\cbb{interp: build coarse coordinates}{bool}{true}{If false, skip the calculation of coarse coordinates.}
          
\cbb{filtered matrix: use lumping}{bool}{true}{Lump (add to diagonal) dropped entries during the construction of a filtered matrix. This allows user to preserve constant nullspace.}
          
\cbb{filtered matrix: reuse eigenvalue}{bool}{true}{Skip eigenvalue calculation during the construction of a filtered matrix by reusing eigenvalue estimate from the original matrix. This allows us to skip heavy computation, but may lead to poorer convergence.}
          
\cbb{emin: iterative method}{string}{"cg"}{Iterative method to use for energy minimization of initial prolongator in energy-minimization. Possible values: "cg" (conjugate gradient), "gmres" (generalized minimum residual), "sd" (steepest descent).}
          
\cbb{emin: num iterations}{int}{2}{Number of iterations to minimize initial prolongator energy in energy-minimization.}
          
\cbb{emin: num reuse iterations}{int}{1}{Number of iterations to minimize the reused prolongator energy in energy-minimization.}
          
\cbb{emin: pattern}{string}{"AkPtent"}{Sparsity pattern to use for energy minimization. Possible values: "AkPtent".}
          
\cbb{emin: pattern order}{int}{1}{Matrix order for the "AkPtent" pattern.}
          
\cbb{emin: use filtered matrix}{bool}{true}{Matrix to use for smoothing for energy minimization. The two options are: to use the original matrix, and to use the filtered matrix with filtering based on filtered graph used for aggregation.}
          
\cbb{repartition: enable}{bool}{false}{Rebalancing on/off switch.}
          
\cbb{repartition: partitioner}{string}{"zoltan2"}{Partitioning package to use. Possible values: "zoltan" (\zoltan{} library), "zoltan2" (\zoltantwo{} library).}
          
\cba{repartition: params}{\parameterlist}{Partitioner parameters. \muelu passes them directly to the appropriate package library. In particular, this allows to choose a partitioning algorithm from \zoltan{} or \zoltan2{} or from external packages such as \parmetis{}.}
          
\cbb{repartition: start level}{int}{2}{Minimum level to run partitioner. \muelu does not rebalance levels finer than this one.}
          
\cbb{repartition: min rows per proc}{int}{800}{Minimum number of rows per MPI process. If the actual number if smaller, then rebalancing occurs. The value is not used if "repartition: min rows per thread" is positive.}
          
\cbb{repartition: target rows per proc}{int}{0}{Target number of rows per MPI process after rebalancing. If the value is set to 0, it will use the value of "repartition: min rows per proc"}
          
\cbb{repartition: min rows per thread}{int}{0}{Minimum number of rows per thread. If the actual number if smaller, then rebalancing occurs. If the value is set to 0, no repartitioning based on thread count will occur.}
          
\cbb{repartition: target rows per thread}{int}{0}{Target number of rows per thread after rebalancing. If the value is set to 0, it will use the value of "repartition: min rows per thread".}
          
\cbb{repartition: max imbalance}{double}{1.2}{Maximum nonzero imbalance ratio. If the actual number is larger, the rebalancing occurs.}
          
\cbb{repartition: remap parts}{bool}{true}{Postprocessing for partitioning to reduce data migration.}
          
\cbb{repartition: rebalance P and R}{bool}{false}{Explicit rebalancing of R and P during the setup. This speeds up the solve, but slows down the setup phases.}
          
\cbb{reuse: type}{string}{"none"}{Reuse options for consecutive hierarchy construction. This speeds up the setup phase, but may lead to poorer convergence. Possible values: see Table~\ref{t:reuse_types}.}
          
\cbb{refmaxwell: mode}{string}{"additive"}{Specifying the order of solve of the block system. Allowed values are: "additive" (default), "121", "212", "1", "2"}
          
\cbb{refmaxwell: disable addon}{bool}{true}{Specifing whether the addon should be built for stabilization}
          
\cba{refmaxwell: 11list}{\parameterlist}{Specifies the multigrid solver for the 11 block}
          
\cba{refmaxwell: 22list}{\parameterlist}{Specifies the multigrid solver for the 22 block}
          
\cbb{refmaxwell: use as preconditioner}{bool}{false}{Assume zero initial guess}
          
\cbb{refmaxwell: dump matrices}{bool}{false}{Dump matrices to disk.}
          
\cbb{refmaxwell: subsolves on subcommunicators}{bool}{false}{Redistribute the two subsolves to disjoint sub-communicators (so that the additive solve can occur in parallel).}
          
\cbb{refmaxwell: ratio AH / A22 subcommunicators}{double}{1.0}{Ratio for the split into sub-communicators.}
          