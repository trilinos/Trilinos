
\cbb{problem: type}{string}{"unknown"}{Type of problem to be solved. Possible values: see Table~\ref{t:problem_types}.}
        
\cbb{verbosity}{string}{"high"}{Control of the amount of printed information. Possible values: see Table~\ref{t:verbosity_types}.}
        
\cbb{number of equations}{int}{1}{Number of PDE equations at each grid node. Only constant block size is considered.}
        
\cbb{max levels}{int}{10}{Maximum number of levels in a hierarchy.}
        
\cbb{cycle type}{string}{"V"}{Multigrid cycle type. Possible values: "V", "W".}
        
\cbb{coarse grid correction scaling factor}{double}{1.0}{Scaling factor to be applied to the coarse grid correction. This only affects the solve phase.}
        
\cbb{fuse prolongation and update}{bool}{false}{Fuse prolongation and update into one kernel call. Due to round-off error accumulation, this can in some cases result in slightly higher iteration counts. This only affects the solve phase.}
        
\cbb{problem: symmetric}{bool}{true}{Symmetry of a problem. This setting affects the construction of a restrictor. If set to true, the restrictor is set to be the transpose of a prolongator. If set to false, underlying multigrid algorithm makes the decision.}
        
\cbb{xml parameter file}{string}{""}{An XML file from which to read additional
      parameters.  In case of a conflict, parameters manually set on
      the list will override parameters in the file. If the string is
      empty a file will not be read.}
        
\cbb{parameterlist: syntax}{string}{muelu}{Syntax of ParameterList to use.  This should either be "muelu" or "ml." }
        
\cbb{hierarchy label}{string}{""}{Label for the hierarchy. Is applied to timer labels.}
        
\cba{matvec params}{\parameterlist}{Pass parameters to the underlying linear algebra}
        
\cbb{smoother: pre or post}{string}{"both"}{Pre- and post-smoother combination. Possible values: "pre" (only pre-smoother), "post" (only post-smoother), "both" (both pre-and post-smoothers), "none" (no smoothing).}
        
\cbb{smoother: type}{string}{"RELAXATION"}{Smoother type. Possible values: see Table~\ref{tab:smoothers}.}
        
\cbb{smoother: pre type}{string}{"RELAXATION"}{Pre-smoother type. Possible values: see Table~\ref{tab:smoothers}.}
        
\cbb{smoother: post type}{string}{"RELAXATION"}{Post-smoother type. Possible values: see Table~\ref{tab:smoothers}.}
        
\cba{smoother: params}{\parameterlist}{Smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.}
        
\cba{smoother: pre params}{\parameterlist}{Pre-smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.}
        
\cba{smoother: post params}{\parameterlist}{Post-smoother parameters. For standard smoothers, \muelu passes them directly to the appropriate package library.}
        
\cbb{smoother: overlap}{int}{0}{Smoother subdomain overlap.}
        
\cbb{smoother: pre overlap}{int}{0}{Pre-smoother subdomain overlap.}
        
\cbb{smoother: post overlap}{int}{0}{Post-smoother subdomain overlap.}
        
\cbb{coarse: max size}{int}{2000}{Maximum dimension of a coarse grid. \muelu will stop coarsening once it is achieved.}
        
\cbb{coarse: type}{string}{"SuperLU"}{Coarse solver. Possible values: see Table~\ref{tab:coarse_solvers}.}
        
\cba{coarse: params}{\parameterlist}{Coarse solver parameters. \muelu passes them directly to the appropriate package library.}
        
\cbb{coarse: overlap}{int}{0}{Coarse solver subdomain overlap.}
        
\cbb{aggregation: type}{string}{"uncoupled"}{Aggregation scheme. Possible values: see Table~\ref{t:aggregation}.}
        
\cbb{aggregation: mode}{string}{"uncoupled"}{Controls whether aggregates are allowed to cross processor boundaries. Possible values: "coupled" aggregates can cross processor boundaries, "uncoupled" aggregates cannot cross processor boundaries.}
        
\cbb{aggregation: ordering}{string}{"natural"}{Node ordering strategy. Possible values: "natural" (local index order), "graph" (filtered graph breadth-first order), "random" (random local index order).}
        
\cbb{aggregation: drop scheme}{string}{"classical"}{Connectivity dropping scheme for a graph used in aggregation. Possible values: "classical", "distance laplacian".}
        
\cbb{aggregation: distance laplacian algo}{string}{"default"}{Type of sub-algorithm for "distance laplacian" dropping. Possible values: "default", "unscaled cut", "scaled cut".}
        
\cbb{aggregation: drop tol}{double}{0.0}{Connectivity dropping threshold for a graph used in aggregation.}
        
\cbb{aggregation: min agg size}{int}{2}{Minimum size of an aggregate.}
        
\cbb{aggregation: max agg size}{int}{-1}{Maximum size of an aggregate (-1 means unlimited).}
        
\cbb{aggregation: compute aggregate qualities}{bool}{false}{Whether to compute aggregate quality estimates.}
        
\cbb{aggregation: brick x size}{int}{2}{Number of points for x axis in "brick" aggregation (limited to 3).}
        
\cbb{aggregation: brick y size}{int}{2}{Number of points for y axis in "brick" aggregation (limited to 3).}
        
\cbb{aggregation: brick z size}{int}{2}{Number of points for z axis in "brick" aggregation (limited to 3).}
        
\cbb{aggregation: max selected neighbors}{int}{0}{Maximum number of neighbor nodes that are already aggregated. If a new aggregate has some neighbors that are already aggregated, this node probably can be added to one of these aggregates. We don't need a new one.}
        
\cbb{aggregation: Dirichlet threshold}{double}{0.0}{Threshold for determining whether entries are zero during Dirichlet row detection.}
        
\cbb{aggregation: deterministic}{bool}{false}{Boolean indicating whether or not aggregation will be run deterministically in the kokkos refactored path (only used in uncoupled aggregation).}
        
\cbb{aggregation: coloring algorithm}{string}{serial}{Choice of distance 2 coloring algorithm used by Uncoupled Aggregation. Currently set by defulat to COLORING_D2_SERIAL.}
        
\cbb{aggregation: enable phase 1}{bool}{true}{Turn on/off phase 1 of aggregation}
        
\cbb{aggregation: enable phase 2a}{bool}{true}{Turn on/off phase 2a of aggregation}
        
\cbb{aggregation: enable phase 2b}{bool}{true}{Turn on/off phase 2b of aggregation}
        
\cbb{aggregation: enable phase 3}{bool}{true}{Turn on/off phase 3 of aggregation}
        
\cbb{aggregation: error on nodes with no on-rank neighbors}{bool}{false}{Causes phase 3 aggregation to throw an error for
      non-Dirichlet nodes that have no on-rank neighbors.  This only
      works for Uncoupled Aggregation.}
        
\cbb{aggregation: phase3 avoid singletons}{bool}{false}{Causes phase 3 aggregation to try and group any
      vertices that remain unaggregated with any other on-rank vertex
      (even if it is not a neighbor) to define an aggregate.  This only
      works for Uncoupled Aggregation.}
        
\cbb{aggregation: allow empty prolongator columns}{bool}{false}{Fix diagonal of coarse level operator A resulting from empty columns (rows) in the prolongation (restriction) operators caused by singleton aggregates and number of null space vectors larger than number of DOFs per node. This option might be helpful for elasticity problems with singleton aggregates.}
        
\cbb{aggregation: preserve Dirichlet points}{bool}{false}{Turn on/off Dirichlet points preservation}
        
\cbb{aggregation: allow user-specified singletons}{bool}{false}{Allow special nodes to be marked for one-to-one transfer to the coarsest level. (default = off)}
        
\cbb{aggregation: use interface aggregation}{bool}{false}{Allow an application to prescribe root nodes to uncoupled aggregation}
        
\cbb{aggregation: export visualization data}{bool}{false}{Export data for visualization post-processing.}
        
\cbb{aggregation: output filename}{string}{""}{Filename to write VTK visualization data to.}
        
\cbb{aggregation: output file: time step}{int}{0}{Time step ID for non-linear problems.}
        
\cbb{aggregation: output file: iter}{int}{0}{Iteration for non-linear problems.}
        
\cbb{aggregation: output file: agg style}{string}{Point Cloud}{Style of aggregate visualization.}
        
\cbb{aggregation: output file: fine graph edges}{bool}{false}{Whether to draw all fine node connections along with the aggregates.}
        
\cbb{aggregation: output file: coarse graph edges}{bool}{false}{Whether to draw all coarse node connections along with the aggregates.}
        
\cbb{aggregation: output file: build colormap}{bool}{false}{Whether to output a random colormap in a separate XML file.}
        
\cba{aggregation: params}{\parameterlist}{Sublist of options for use by aggregation.}
        
\cba{strength-of-connection: params}{\parameterlist}{Sublist of options for use by coalesce/drop.}
        
\cbb{aggregation: mesh layout}{string}{Global Lexicographic}{Type of ordering for structured mesh aggregation. Possible values: "Global Lexicographic" and "Local Lexicographic".}
        
\cbb{aggregation: output type}{string}{Aggregates}{Type of object holding the aggregation data. Possible values: "Aggregates" or "CrsGraph".}
        
\cbb{aggregation: coarsening rate}{string}{{3}}{Coarsening rate per spatial dimensions, the string must be interpretable as an array by Teuchos.}
        
\cbb{aggregation: number of spatial dimensions}{int}{3}{The number of spatial dimensions in the problem.}
        
\cbb{aggregation: coarsening order}{int}{0}{The interpolation order used while constructing these aggregates, this value will be passed to the prolongator factory.}
        
\cbb{aggregation: pairwise: size}{int}{8}{Target size for pairwise aggregation.  The number
      of pairwise steps used will be log base-2 of this number.}
        
\cbb{aggregate qualities: check symmetry}{bool}{false}{Whether to check symmetry and use nonsymmetric aggregate quality estimate if necessary.}
        
\cbb{aggregate qualities: good aggregate threshold}{double}{100.0}{Maximum quality where aggregate is considered acceptable.}
        
\cbb{aggregate qualities: file output}{bool}{false}{Whether to output files containing the aggregate qualities.}
        
\cbb{aggregate qualities: file base}{string}{agg_qualities}{Base of filename for aggregate quality output.}
        
\cba{export data}{\parameterlist}{Exporting a subset of the hierarchy data in a
      file. Currently, the list can contain any of the following parameter
      names (``A'', ``P'', ``R'', ``Nullspace'', ``Coordinates'') of type \texttt{string}
      and value ``\{levels separated by commas\}''. A
      matrix/multivector with a name ``X'' is saved in two or three
      three MatrixMarket files: a) data is saved in
      \textit{X\_level.mm}; b) its row map is saved in
      \textit{rowmap\_X\_level.mm}; c) its column map (for matrices) is saved in
      \textit{colmap\_X\_level.mm}.}
        
\cbb{print initial parameters}{bool}{true}{Print parameters provided for a hierarchy construction.}
        
\cbb{print unused parameters}{bool}{true}{Print parameters unused during a hierarchy construction.}
        
\cbb{transpose: use implicit}{bool}{false}{Use implicit transpose for the restriction operator.}
        
\cbb{restriction: scale nullspace}{bool}{false}{Block-diagonally scale (based on number of PDEs) the nullspace for the restriction only.}
        
\cbb{use kokkos refactor}{bool}{false}{Switch on the new \kokkos based version for on-node parallelism.}
        
\cbb{synchronize factory timers}{bool}{false}{Add barriers before and after Factory Build() calls.}
        
\cbb{rap: triple product}{bool}{false}{Use all-at-once triple matrix product kernel}
        
\cbb{multigrid algorithm}{string}{"sa"}{Multigrid method. Possible values: see Table~\ref{t:mgs}.}
        
\cbb{toggle: mode}{string}{semicoarsen}{Toggling strategy for transfer operators (default=semicoarsen)}
        
\cbb{semicoarsen: coarsen rate}{int}{3}{Rate at which to coarsen unknowns in the z direction.}
        
\cbb{semicoarsen: number of levels}{int}{3}{Determines the maximum number of times that semicoarsening is applied.}
        
\cbb{linedetection: orientation}{string}{vertical}{Line orientation: can be either 'vertical', 'horizontal' or 'coordinates'.}
        
\cbb{linedetection: num layers}{int}{-1}{Line detection: number of layers on finest level. Alternatively, set the number of layers on the finest level as \"NumZLayers\" in the finest level container class.}
        
\cbb{sa: damping factor}{double}{1.33}{Damping factor for smoothed aggregation.}
        
\cbb{sa: use filtered matrix}{bool}{true}{Matrix to use for smoothing the tentative prolongator. The two options are: to use the original matrix, and to use the filtered matrix with filtering based on filtered graph used for aggregation.}
        
\cbb{sa: calculate eigenvalue estimate}{bool}{false}{Force calculation of eigenvalue estimate during prolongator smoothing.}
        
\cbb{sa: eigenvalue estimate num iterations}{int}{10}{Number of power iterations to use to estimate max eigenvalue. This has effect only if estimation occurs during prolongator smoothing.}
        
\cbb{interp: interpolation order}{int}{1}{Interpolation order used to interpolate values from coarse points to fine points. Possible values are 0 for piece-wise constant interpolation and 1 for piece-wise linear interpolation. This parameter is set to 1 by default.}
        
\cbb{interp: build coarse coordinates}{bool}{true}{If false, skip the calculation of coarse coordinates.}
        
\cba{transfer: params}{\parameterlist}{Sublist of options for use by transfer.}
        
\cbb{pcoarsen: element}{string}{""}{Element class for IntrepidPCoarsening}
        
\cbb{pcoarsen: schedule}{string}{""}{Coarsening schedule for IntrepidPCoarsening}
        
\cbb{pcoarsen: hi basis}{string}{""}{Higher order basis for IntrepidPCoarsening}
        
\cbb{pcoarsen: lo basis}{string}{""}{Lower order basis for IntrepidPCoarsening}
        
\cbb{smoother: neighborhood type}{string}{""}{Valid options: node, edge, face, cell}
        
\cbb{filtered matrix: use lumping}{bool}{true}{Lump (add to diagonal) dropped entries during the construction of a filtered matrix. This allows user to preserve constant nullspace.}
        
\cbb{filtered matrix: reuse eigenvalue}{bool}{true}{Skip eigenvalue calculation during the construction of a filtered matrix by reusing eigenvalue estimate from the original matrix. This allows us to skip heavy computation, but may lead to poorer convergence.}
        
\cbb{filtered matrix: reuse graph}{bool}{true}{Set values to zero instead of constructing a new graph.}
        
\cbb{emin: iterative method}{string}{"cg"}{Iterative method to use for energy minimization of initial prolongator in energy-minimization. Possible values: "cg" (conjugate gradient), "gmres" (generalized minimum residual), "sd" (steepest descent).}
        
\cbb{emin: num iterations}{int}{2}{Number of iterations to minimize initial prolongator energy in energy-minimization.}
        
\cbb{emin: num reuse iterations}{int}{1}{Number of iterations to minimize the reused prolongator energy in energy-minimization.}
        
\cbb{emin: pattern}{string}{"AkPtent"}{Sparsity pattern to use for energy minimization. Possible values: "AkPtent".}
        
\cbb{emin: pattern order}{int}{1}{Matrix order for the "AkPtent" pattern.}
        
\cbb{tentative: calculate qr}{bool}{true}{If false, skip local QR decomposition phase of smoothed aggregation.}
        
\cbb{tentative: constant column sums}{bool}{false}{If true, scale the column sums to one (before applying nullspace).}
        
\cbb{tentative: build coarse coordinates}{bool}{true}{If false, skip the calculation of coarse coordinates.}
        
\cbb{repartition: enable}{bool}{false}{Rebalancing on/off switch.}
        
\cbb{repartition: partitioner}{string}{"zoltan2"}{Partitioning package to use. Possible values: "zoltan" (\zoltan{} library), "zoltan2" (\zoltantwo{} library).}
        
\cba{repartition: params}{\parameterlist}{Partitioner parameters. \muelu passes them directly to the appropriate package library. In particular, this allows to choose a partitioning algorithm from \zoltan{} or \zoltan2{} or from external packages such as \parmetis{}.}
        
\cbb{repartition: start level}{int}{2}{Minimum level to run partitioner. \muelu does not rebalance levels finer than this one.}
        
\cbb{repartition: node repartition level}{int}{-1}{Level on which to run node-level repartitioning (negative means don't).}
        
\cbb{repartition: node id}{int}{-1}{Id of the current node (only used for node-level repartitioning).}
        
\cbb{repartition: min rows per proc}{int}{800}{Minimum number of rows per MPI process. If the actual number if smaller, then rebalancing occurs. The value is not used if "repartition: min rows per thread" is positive.}
        
\cbb{repartition: target rows per proc}{int}{0}{Target number of rows per MPI process after rebalancing. If the value is set to 0, it will use the value of "repartition: min rows per proc"}
        
\cbb{repartition: min rows per thread}{int}{0}{Minimum number of rows per thread. If the actual number if smaller, then rebalancing occurs. If the value is set to 0, no repartitioning based on thread count will occur.}
        
\cbb{repartition: target rows per thread}{int}{0}{Target number of rows per thread after rebalancing. If the value is set to 0, it will use the value of "repartition: min rows per thread".}
        
\cbb{repartition: max imbalance}{double}{1.2}{Maximum nonzero imbalance ratio. If the actual number is larger, the rebalancing occurs.}
        
\cbb{repartition: remap parts}{bool}{true}{Postprocessing for partitioning to reduce data migration.}
        
\cbb{repartition: remap num values}{int}{4}{Number of maximum components from each processor used to construct partial bipartite graph.}
        
\cbb{repartition: remap accept partition}{bool}{true}{Whether the local rank should accept a partition.}
        
\cbb{repartition: print partition distribution}{bool}{false}{Partition distribution printout.}
        
\cbb{repartition: rebalance P and R}{bool}{false}{Explicit rebalancing of R and P during the setup. This speeds up the solve, but slows down the setup phases.}
        
\cbb{repartition: rebalance Nullspace}{bool}{true}{Rebalancing of Nullspace during the setup.}
        
\cbb{repartition: use subcommunicators}{bool}{true}{Use subcommunicators on coarser levels.}
        
\cbb{rap: relative diagonal floor}{Array(double)}{{}}{Will boost diagonals on A matrices to the given floor.}
        
\cbb{rap: fix zero diagonals}{bool}{false}{Set zero diagonals on coarse grids to one.}
        
\cbb{rap: fix zero diagonals threshold}{double}{0.}{Threshold at which diagonal entry is considered zero.}
        
\cbb{rap: shift}{double}{0.0}{Shift to use in the RAPShiftFactory}
        
\cbb{rap: shift diagonal M}{bool}{false}{Shift for the RAPShiftFactory is stored as a
      vector (representing the matrix diagonal)}
        
\cbb{rap: shift low storage}{bool}{false}{Use the low-storage version of the rap: shift}
        
\cbb{rap: shift array}{Array(double)}{{}}{Effective shift at each level to use in the RAPShiftFactory (the string must be interpretable as an array by Teuchos).}
        
\cbb{rap: cfl array}{Array(double)}{{}}{Effective CFl at each level to use in the RAPShiftFactory (the string must be interpretable as an array by Teuchos).  }
        
\cbb{rap: algorithm}{string}{galerkin}{Whether to use the Galerkin RAP or the Shift version}
        
\cba{matrixmatrix: kernel params}{\parameterlist}{Controls the kernel algorithms for matrix-matrix operations}
        
\cbb{matrixmatrix: kernel params:MM_TAFC_OptimizationCoreCount }{int}{3000 }{Core Count above which the
optimized neighbor discovery is used for Importer construction, for some matrix
multiplication operations.}
        
\cbb{isMatrixMatrix_TransferAndFillComplete }{bool}{false}{Try to use the
optimized neighbor discovery for Importer construction.}
        
\cbb{reuse: type}{string}{"none"}{Reuse options for consecutive hierarchy construction. This speeds up the setup phase, but may lead to poorer convergence. Possible values: see Table~\ref{t:reuse_types}.}
        
\cbb{use external multigrid package}{string}{"none"}{Option to utilize external multigrid package for computations, for example allows for use of AMGX}
        
\cba{amgx:params}{\parameterlist}{Sublist for listing AMGX configuration parameters}
        
\cbb{debug: graph level}{int}{-1}{Output dependency graph.}
        
\cbb{refmaxwell: mode}{string}{"additive"}{Specifying the order of solve of the block system. Allowed values are: "additive" (default), "121", "212", "1", "2"}
        
\cbb{refmaxwell: disable addon}{bool}{true}{Specifing whether the addon should be built for stabilization}
        
\cba{refmaxwell: 11list}{\parameterlist}{Specifies the multigrid solver for the 11 block}
        
\cba{refmaxwell: 22list}{\parameterlist}{Specifies the multigrid solver for the 22 block}
        
\cbb{refmaxwell: use as preconditioner}{bool}{false}{Assume zero initial guess}
        
\cbb{refmaxwell: dump matrices}{bool}{false}{Dump matrices to disk.}
        
\cbb{refmaxwell: subsolves on subcommunicators}{bool}{false}{Redistribute the two subsolves to disjoint sub-communicators (so that the additive solve can occur in parallel).}
        
\cbb{refmaxwell: ratio AH / A22 subcommunicators}{double}{1.0}{Ratio for the split into sub-communicators.}
        