/*! \mainpage Amesos: An Interface to Serial and Parallel Direct Sparse Solver Packages.

\image html ../AmesosLogo.jpeg

\image latex AmesosLogo.eps

\section toc Table of Contents

The main page of the Doxygen documentation is organized as follows:
- \ref developers
- \ref intro
- \ref copyright
- \ref comparison
- \ref matrix
- \ref install
- \ref install
- \ref final

\section developers Developers

Amesos is a Trilinos package, developed by M. Sala, K. Stanley,
R. Hoekstra, T. Davis, and M. Heroux.

\section intro Introduction 
Amesos provides an object-oriented interface
to several direct sparse solvers, both sequential and parallel.

Amesos supports the following classes:

- \c Amesos_Lapack - Interface to LAPACK's DGETRF. Amesos_Lapack is the 
     only dense solver supported by Amesos.
- \c Amesos_Klu - Interface to Tim Davis serial solver KLU (distributed within Amesos). 
- \c Amesos_Umfpack - Interface to Tim Davis's UMFPACK (version 4.3 or later)
- \c Amesos_Superlu - Interface to Xiaoye Li's SuperLU serial memory code with serial input interface.
- \c Amesos_Superludist - Interface to Xiaoye Li's SuperLU Distributed memory code with serial input interface (version 2.0 or later).
- \c Amesos_Dscpack - Interface to Padma Raghavan's DSCPACK
- \c Amesos_Mumps - Interface to CERFACS' MUMPS (version 4.3.1 or later)

We refer to the Sandia report SAND-2004-2188 for a detailed overview of
Amesos. A PDF version of this report can be found the
\c Trilinos/packages/amesos/doc/AmesosReferenceGuide/AmesosReferenceGuide.pdf.

\section copyright  Copyright and licensing of the third party codes

<p>Most of the Amesos classes are based on a third party code (that is,
not distributed within Trilinos).  Each
third party code comes with its own copyright and/or licensing
requirements. It is responsibility of the user to fulfill the 
requirements of each supported package' copyright.

<p>Most of these third party codes are intended to be made available at
no cost to users.  Much of the copyright and licensing restrictions
concern rights to modify, redistribute the code and generally include a 
request that credit be given in any papers which make use of their code.
Please refer to the web page for the package that you are interested in 
for details.  

\section comparison  Quick comparison of the Amesos classes

The following table reports an overview of the Amesos classes.

<table>
<tr>
<td>Features</td>
<td>Amesos_Lapack</td>
<td>Amesos_Klu</td>
<td>Amesos_Umfpack</td>
<td>Amesos_Superlu</td>
<td>Amesos_Superludist</td>
<td>Amesos_Mumps</td>
<td>Amesos_Dscpack</td>
</tr>
<tr>
<td>Default behavior</td>
<td>Enabled</td>
<td>Enabled//td>
<td>Disabled</td>
<td>Disabled</td>
<td>Disabled</td>
<td>Disabled</td>
<td>Disabled</td>
</tr>
<tr>
<td>Package is written in</td>
<td>FORTRAN77</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>C</td>
<td>FORTRAN90</td>
<td>C</td>
</tr>
<tr>
<td>Communicator</td>
<td>none</td>
<td>none</td>
<td>none</td>
<td>none</td>
<td>MPI</td>
<td>FORTRAN MPI</td>
<td>MPI</td>
</tr>
<tr>
<td>Processes used for Factorization/Solve</td>
<td>Process 0</td>
<td>Process 0</td>
<td>Process 0</td>
<td>Process 0</td>
<td>Any</td>
<td>Any (*)</td>
<td>Any (**)</td>
</tr>
<tr>
<td>Distributed input matrix</td>
<td>Yes </td>
<td>Yes </td>
<td>Yes </td>
<td>Yes </td>
<td>Yes </td>
<td>Yes </td>
<td>Yes </td>
</tr>
<tr>
<td>Unsymmetric matrices</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Requires BLAS</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Requires LAPACK</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Requires BLACS</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Requires ScaLAPACK</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
</table> 

<P> (*) MUMPS required FORTRAN communicators. Some architectures (e.g., SGI)
does not allow portable conversions from C/C++ communicator and FORTRAN. On these
architectures, therefore, \c MPI_COMM_WORLD will be used by MUMPS. Instead, if
C/C++ communicators can be converted to FORTRAN ones, then any number of
prosesses can be used by Amesos_Mumps.

<P> (**) DSCPACK requires a number of processes that is a power of 2.

\section matrix Supported Matrix Formats.

The following table details the supported matrix formats for each class.

<table>
<tr>
<td> </td>
<td>Amesos_Lapack</td>
<td>Amesos_Klu</td>
<td>Amesos_Umfpack</td>
<td>Amesos_Superlu</td>
<td>Amesos_Superludist</td>
<td>Amesos_Mumps</td>
<td>Amesos_Dscpack</td>
</tr>
<tr>
<td>Epetra_RowMatrix</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>Epetra_CrsMatrix</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>Epetra_VbrMatrix</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
</table>

\section install  Installing Amesos 

Each of the Amesos classes provides an interface to a third
party direct sparse solver code.  In order to install a particular
class, you must first install the underlying direct sparse solver
code. 

<P>Amesos is distributed through the Trilinos project, and can be
downloaded from the web site
http://software.sandia.gov/trilinos/packages/amesos.

<P>As all other Trilinos packages,
Amesos is configured and built using the GNU autoconf
and automake tools. To configure Amesos from the
Trilinos top directory, a possible procedure is as follows.  Let
\c TRILINOS_HOME be a shell variable representing the location
of the Trilinos source directory, and \verb!%! the shell prompt sign.
Let us suppose that we want to configure Amesos on a
LINUX machine with MPI, with support
for KLU and UMFPACK. Header files for UMFPACK are located
in directory \c /usr/local/umfpack/include, while the library,
called \c libumfpack.a is located in \c /usr/local/umfpack/lib.
The configure like will look like:

\code
% cd $TRILINOS_HOME
% mkdir LINUX_MPI
% cd LINUX_MPI
% ../configure \
  --with-mpi-compilers \
  --prefix=$TRILINOS_HOME/LINUX_MPI \
  --enable-amesos \
  --enable-amesos-klu \
  --enable-amesos-umfpack \
  --with-incdirs="-I/usr/local/umfpack/include" \
  --with-ldflags="-L/usr/local/umfpack/lib" \
  --with-libs="-lumfpack"
% make
% make install
\endcode

Other flags may be required depending on the location of
 MPI, BLAS and LAPACK. The table below reports the 
architectures and compilers tested with Amesos.

<table>
<tr>
<td>architecture</td>
<td>Amesos_Lapack</td>
<td>Amesos_Klu</td>
<td>Amesos_Umfpack</td>
<td>Amesos_Superlu</td>
<td>Amesos_Superludist</td>
<td>Amesos_Mumps</td>
<td>Amesos_Dscpack</td>
</tr>
<tr>
<td>LINUX (GNU), SERIAL</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>LINUX (Intel), MPI</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>LINUX (GNU), MPI</td>
<td>yes </td>
<td>yes </td>
<td>yes </td>
<td>yes </td>
<td>yes </td>
<td>no </td>
<td>yes </td>
</tr>
<tr>
<td>SGI 64, MPI</td>
<td>yes </td>
<td>yes </td>
<td>yes </td>
<td>no </td>
<td>no</td>
<td>yes </td>
<td>no </td>
</tr>
<tr>
<td>DEC/Alpha MPI</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>MAC OSX, SERIAL</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Sandia Cplant, MPI</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>Sandia ASCI Red, MPI</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>

</table>

\section example Example of Use of Amesos Classes

A simple fragment of code using Amesos can read as follows. First,
  we need to include the header files for Amesos:

\code
#include "Amesos.h"
#include "Amesos_BaseSolver.h"
\endcode

Note that these header files will \e not include the header files
for the supported libraries (which are of course needed to compile the
Amesos library itself). Now, let define the linear system matrix, the
vector that will contain the solution, and the right-hand side as:

\code
Epetra_LinearProblem Problem;
Epetra_RowMatrix* A;            // linear system matrix
Epetra_MultiVector* LHS;        // vector that will contain the solution
Epetra_MultiVector* RHS;        // right-hand side
\endcode

All Amesos object (derived from pure virtual class
Amesos_BaseSolver)
can be created using the function class \c Amesos, as follows:

\code
Amesos_BaseSolver * Solver;
Amesos Factory;
char* SolverType = "Amesos_Klu";
Solver = Factory.Create(SolverType, *Problem);
\endcode

\note It is important to note that all available solvers can be selected
simply by changing an input parameter. Some solvers are serial, other
parallel; generally, each solver has its own matrix format. However, the
user will still have the \e same interface to all of them.

<P>The \c Factory object will create an Amesos_Klu object (if Amesos
has been configure to support this solver). \c Factory.Create()
returns 0 if the requested solver is not available. Parameter names
are case-sensitive; misspelled parameters
will not be recognized. Method
\c Factory.Query() can be used to query the factory about the
availability of a given solver:
\code
char* SolverType = "Amesos_Klu";
bool IsAvailable = Factory.Query(SolverType);
\endcode

Here, we simply recall that the parameters list can be created as
\code
Teuchos::ParameterList List;
\endcode

and parameters can be set as

\code
List.set(ParameterName,ParameterValue);
\endcode

Here, \c ParameterName is a string containing the parameter name,
and \c ParameterValue is any valid C++ object that specifies the
parameter value (for instance, an integer, a pointer to an array or to
an object). Please consult the Amesos Reference Guide for more details.
The Doxygen documentation of each class can also be of help.

<P>Note that \c Problem is still empty. After setting the pointer to
the linear system matrix, we can perform the symbolic factorization
of the linear system matrix:

\code
AMESOS_CHK_ERR(Solver->SymbolicFactorization());
\endcode

(\c AMESOS_CHK_ERR is a macro, that checks the return error and, if not
null, prints out a message and returns.)
This phase does not require the numerical values of \c A, that can
therefore be changed after the call to \c SymbolicFactorization().
However,  the nonzero pattern of \c A \e cannot be
changed.

The numeric factorization is performed by

\code
AMESOS_CHK_ERR(Solver->NumericFactorization());
\endcode

The values of \c RHS must be set before solving the linear system, which
simply reads

\code
Problem.SetLHS(LHS);
Problem.SetRHS(RHS);
AMESOS_CHK_ERR(Solver->Solve());
\endcode

Should the user need to re-factorize the matrix, he or she must call
\c NumericFactorization(). If the structure of the matrix is changed,
he or she must call \c SymbolicFactorization(). However, it is supposed
that the linear system matrix and the solution and right-hand side vectors
are still defined with the same \c Epetra_Map.

\section final Final Remarks

<p>This page last updated 18-Sep-2004.

*/
