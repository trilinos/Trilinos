<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="Mozilla/4.76 [en] (X11; U; Linux 2.4.2-2smp i686) [Netscape]">
  <meta name="sandia.approved" content="SAND99-1377">
  <meta name="author" content="karen devine, kddevin@sandia.gov">
  <title>Zoltan User's Guide: Hypergraph Partitioning</title>
<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000,2001,2002, Sandia National Laboratories.                !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
--><!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->
</head>
<body bgcolor="#ffffff">
<div align="right"><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_alg_oct.html">Next</a>&nbsp; |&nbsp; <a
 href="ug_alg_jostle.html">Previous</a></i></b></div>
<h2>
<a name="Hypergraph Partitioning"></a>Hypergraph Partitioning</h2>
Hypergraph partitioning is a useful partitioning and
load balancing method when connectivity data is available. It can be
viewed as a more sophisticated alternative to
the traditional graph partitioning.
<p>A hypergraph consists of vertices and hyperedges. A hyperedge
connects
one or more vertices. 
A graph can be cast as a hypergraph in one of two ways: either every
pair of neighboring vertices form a hyperedge, or a vertex and all
its neighbors form a hyperedge.
The hypergraph model is well
suited to parallel computing, where vertices correspond to data objects
and hyperedges represent the communication requirements. The basic
partitioning problem is to partition the vertices into <i>k</i>
approximately equal sets such that the number of cut hyperedges is
minimized. Most partitioners (including Zoltan-PHG) allows a more
general
model where both vertices and hyperedges can be assigned weights.
It has been
shown that the hypergraph model gives a more accurate representation
of communication cost (volume) than the graph model. In particular,
for sparse matrix-vector multiplication, the hypergraph model
<strong>exactly</strong> represents communication volume. Sparse
matrices can be partitioned either along rows or columns;
in the row-net model the columns are vertices and each row corresponds
to an hyperedge, while in the column-net model the roles of vertices
and hyperedges are reversed. </p>
<p>Zoltan contains a native parallel hypergraph partitioner, called PHG
(Parallel HyperGraph partitioner). In addition, Zoltan provides
access to <a href="http://bmi.osu.edu/%7Eumit/software.htm">PaToH</a>,
a serial hypergraph partitioner.
Note that PaToH is not part of Zoltan and should be obtained
separately from the <a href="http://bmi.osu.edu/%7Eumit/software.htm">
PaToH web site</a>.
Zoltan-PHG is a fully parallel multilevel hypergraph partitioner. For
further technical description, see <a
 href="ug_refs.html#hypergraph-ipdps06">[Devine et al, 2006]</a>.<br>
</p>
<p>Planned future features (currently not supported):<br>
</p>
<ul>
  <li>Fixed vertices</li>
  <li>Repartitioning (to reduce migration cost)</li>
  <li>Multiconstraint partitioning </li>
  <li>2-dimensional (sparse matrix) partitioning </li>
</ul>
<p>
For applications that already use Zoltan to do graph partitioning, it
is
fairly easy to upgrade to hypergraph partitioning. See the section
<a href="ug_graph_vs_hg.html">graph vs. hypergraph</a> partitioning. </p>
<table nosave="" width="100%">
  <tbody>
    <tr>
      <td valign="top"><b>Method String:</b></td>
      <td><b>HYPERGRAPH</b></td>
    </tr>
    <tr>
      <td><b>Parameters:</b></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">HYPERGRAPH_PACKAGE</span><br>
      </td>
      <td style="vertical-align: top;">PHG (parallel) or PaToH (serial)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><span style="font-style: italic;">&nbsp;&nbsp;&nbsp;
PHG_OUTPUT_LEVEL</span><br>
      </td>
      <td style="vertical-align: top;">Level of verbosity; 0 is silent.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">CHECK_HYPERGRAPH</span><br>
      </td>
      <td style="vertical-align: top;">Check that the query functions
return valid input data; 0 or 1. (This slows performance; intended for<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">(CHECK_GRAPH)</span><br>
      </td>
      <td style="vertical-align: top;">debugging.)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">PHG_FROM_GRAPH_METHOD</span><br>
      </td>
      <td style="vertical-align: top;">Method for converting a graph to a hypergraph:<br>
      <span style="font-style: italic;">neighbors</span> - a vertex and all it's graph neighbors form a hyperedge<br>
      <span style="font-style: italic;">pairs</span> - every pair of neighboring vertices form a hyperedge<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><i>&nbsp;&nbsp;&nbsp; PHG_COARSENING_METHOD</i></td>
      <td>The method to use in the matching/coarsening phase:<br>
      <span style="font-style: italic;">ipm</span> - inner product
matching (a.k.a. heavy connectivity matching); gives best quality.<br>
      <span style="font-style: italic;">l-ipm </span>-&nbsp; local ipm
on each processor. Faster but usually gives poorer quality. <br>
      <span style="font-style: italic;">a-ipm</span> - alternate
between ipm and l-ipm. (A compromise between speed and quality.)<br>
      <span style="font-style: italic;">none -&nbsp; </span>no
coarsening<i><br>
      </i></td>
    </tr>
    <tr>
      <td valign="top">&nbsp;&nbsp;&nbsp; <i>PHG_COARSEPARTITION_METHOD</i></td>
      <td>Method to partition the coarsest (smallest) hypergraph;
typically done in serial:<br>
      <span style="font-style: italic;">random</span> - random<br>
      <span style="font-style: italic;">linear</span> - linear
assignment of the vertices (ordered by the user query function)<br>
      <span style="font-style: italic;">greedy</span> - greedy method
based on minimizing cuts<br>
      <span style="font-style: italic;">auto</span> -&nbsp;
automatically select from the above methods (in parallel, the processes
will do different methods)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp;&nbsp; <span
 style="font-style: italic;">PHG_REFINEMENT_METHOD</span><br>
      </td>
      <td style="vertical-align: top;">Refinement algorithm:<br>
      <span style="font-style: italic;">fm</span> - approximate
Fiduccia-Mattheyses (FM)<br>
      <span style="font-style: italic;">no</span> - no refinement<br>
      </td>
    </tr>
    <tr>
      <td>&nbsp;&nbsp;&nbsp; <i>PHG_REFINEMENT_QUALITY</i></td>
      <td>Knob to control the trade-off between run time and quality. 1
is the recommended (default) setting, &gt;1 gives more refinement
(higher quality partitions but longer run time), while &lt;1 gives less
refinement (and
poorer quality).<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp; <span
 style="font-style: italic;">PHG_RANDOMIZE_INPUT</span><br>
      </td>
      <td style="vertical-align: top;">Randomize layout of vertices and
hyperedges in internal parallel 2D layout? <br>
Setting this parameter to 1 often reduces Zoltan-PHG execution time.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp; <a
 name="PHG_EDGE_WEIGHT_OPERATION"></a><span style="font-style: italic;">PHG_EDGE_WEIGHT_OPERATION</span>
      </td>
      <td style="vertical-align: top;">Operation to be applied to edge
weights supplied by different processes for the same hyperedge:<br>
      <i>add</i> - the hyperedge weight will be the sum of the supplied
weights<br>
      <i>max</i> - the hyperedge weight will be the maximum of the
supplied weights<br>
      <i>error</i> - if the hyperedge weights are not equal, Zoltan
will flag an error, otherwise the hyperedge weight will be the value
returned by the processes<br>
      </td>
    </tr>
    <tr nosave="" valign="top">
      <td>&nbsp;&nbsp; <span style="font-style: italic;">PHG_EDGE_SIZE_THRESHOLD</span><br>
      </td>
      <td nosave="">Ignore hyperedges greater than this fraction times
number of vertices.<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">&nbsp;&nbsp; <span
 style="font-style: italic;">ADD_OBJ_WEIGHT</span><br>
      </td>
      <td style="vertical-align: top;">Add implicit vertex (object)
weight. This will be in addition to the user-defined weights. (Note:
Multi-weight partitioning is not yet supported, so currently only use
this option with <a href="ug_param.html#General_Parameters">
obj_weight_dim</a>=0.)
Valid values:<br>
"none"<br>
"unit" or "vertices"<br>
"pins" or "nonzeros" or "vertex degree"<br>
      </td>
    </tr>
    <tr>
      <td valign="top"><b>Default values:</b></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><i>HYPERGRAPH_PACKAGE = PHG<br>
      </i></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">CHECK_HYPERGRAPH=0</span><br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_OUTPUT_LEVEL=0</span></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><i>PHG_FROM_GRAPH_METHOD=neighbors</i></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><i>PHG_COARSENING_METHOD=ipm</i></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><i>PHG_COARSEPARTITION_METHOD=auto</i></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">PHG_REFINEMENT_METHOD=fm</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><i>PHG_REFINEMENT_QUALITY=1</i></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">PHG_RANDOMIZE_INPUT=0</span></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><span style="font-style: italic;">PHG_EDGE_WEIGHT_OPERATION=max</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">PHG_EDGE_SIZE_THRESHOLD=0.25</span></td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><span style="font-style: italic;">ADD_OBJ_WEIGHT=none</span></td>
    </tr>
    <tr>
      <td valign="top"><b>Required Query Functions:</b></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><b><a href="ug_query_lb.html#ZOLTAN_NUM_OBJ_FN">ZOLTAN_NUM_OBJ_FN</a></b></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><b><a href="ug_query_lb.html#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>
or <b><a href="ug_query_lb.html#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>/<b><a
 href="ug_query_lb.html#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b>
pair</td>
    </tr>
    <tr nosave="" valign="top">
      <td><br>
      </td>
      <td nosave=""> <b><a href="ug_query_lb.html#ZOLTAN_HG_SIZE_CS_FN">ZOLTAN_HG_SIZE_CS_FN</a></b>
      <br>
      <b><a href="ug_query_lb.html#ZOLTAN_HG_CS_FN">ZOLTAN_HG_CS_FN</a></b>
      </td>
    </tr>
    <tr>
      <td valign="top"><b>Optional Query Functions:</b></td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><b><a href="ug_query_lb.html#ZOLTAN_HG_SIZE_EDGE_WEIGHTS_FN">ZOLTAN_HG_SIZE_EDGE_WEIGHTS_FN</a></b></td>
    </tr>
    <tr>
      <td><br>
      </td>
      <td><b><a href="ug_query_lb.html#ZOLTAN_HG_EDGE_WEIGHTS_FN">ZOLTAN_HG_EDGE_WEIGHTS_FN</a></b></td>
    </tr>
  </tbody>
</table>
<p>
It is possible to provide the graph query functions instead of the
hypergraph queries, though this is not recommended. If only graph query
functions are registered, Zoltan will automatically create a hypergraph
from the graph, but this is not equivalent to graph partitioning.
In particular, the edge weights will not be accurate.
</p>
<hr width="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a
 href="ug_alg_oct.html">Next:&nbsp;
Octree</a>&nbsp; |&nbsp; <a href="ug_alg_jostle.html">Previous:&nbsp;
Jostle</a>]
</body>
</html>
