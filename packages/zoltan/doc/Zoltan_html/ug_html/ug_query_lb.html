<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  General Zoltan Query Functions</title>
<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000,2001,2002, Sandia National Laboratories.                !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->

</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_query_mig.html">Next</a>&nbsp; |&nbsp; <a href="ug_query.html">Previous</a></i></b></div>

<h2>
<a NAME="Load-Balancing Query Functions"></a>General Zoltan Query Functions</h2>
The following registered functions are used by various Zoltan algorithms
in the Zoltan library. No single algorithm uses all the query functions;
the <a href="ug_alg.html">algorithm descriptions</a> indicate which query
functions are required by individual algorithms.
<blockquote><a href="#General Functions">Object ID Functions</a>
<blockquote><b><a href="#ZOLTAN_NUM_OBJ_FN">ZOLTAN_NUM_OBJ_FN</a></b>
<br><b><a href="#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>
<br><b><a href="#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>
<br><b><a href="#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b>
</blockquote>
<a href="#Border Functions">Border Object Functions (currently unused)</a>
<blockquote>
<b><a href="#ZOLTAN_NUM_BORDER_OBJ_FN">ZOLTAN_NUM_BORDER_OBJ_FN</a></b>
<br><b><a href="#ZOLTAN_BORDER_OBJ_LIST_FN">ZOLTAN_BORDER_OBJ_LIST_FN</a></b>
<br><b><a href="#ZOLTAN_FIRST_BORDER_OBJ_FN">ZOLTAN_FIRST_BORDER_OBJ_FN</a></b>
<br><b><a href="#ZOLTAN_NEXT_BORDER_OBJ_FN">ZOLTAN_NEXT_BORDER_OBJ_FN</a></b></blockquote>
<a href="#Geometry-based Functions">Geometry-Based Functions</a>
<blockquote><b><a href="#ZOLTAN_NUM_GEOM_FN">ZOLTAN_NUM_GEOM_FN</a></b>
<br><b><a href="#ZOLTAN_GEOM_FN">ZOLTAN_GEOM_FN</a></b></blockquote>
<a href="#Graph-based Functions">Graph-Based Functions</a>
<blockquote><b><a href="#ZOLTAN_NUM_EDGES">ZOLTAN_NUM_EDGES_FN</a></b>
<br><b><a href="#ZOLTAN_EDGE_LIST_FN">ZOLTAN_EDGE_LIST_FN</a></b></blockquote>
<a href="#Tree-based Functions">Tree-Based Functions</a>
<blockquote><b><a href="#ZOLTAN_NUM_COARSE_OBJ_FN">ZOLTAN_NUM_COARSE_OBJ_FN</a></b>
<br><b><a href="#ZOLTAN_COARSE_OBJ_LIST_FN">ZOLTAN_COARSE_OBJ_LIST_FN</a></b>
<br><b><a href="#ZOLTAN_FIRST_COARSE_OBJ_FN">ZOLTAN_FIRST_COARSE_OBJ_FN</a></b>
<br><b><a href="#ZOLTAN_NEXT_COARSE_OBJ_FN">ZOLTAN_NEXT_COARSE_OBJ_FN</a></b>
<br><b><a href="#ZOLTAN_NUM_CHILD_FN">ZOLTAN_NUM_CHILD_FN</a></b>
<br><b><a href="#ZOLTAN_CHILD_LIST_FN">ZOLTAN_CHILD_LIST_FN</a></b>
<br><b><a href="#ZOLTAN_CHILD_WEIGHT_FN">ZOLTAN_CHILD_WEIGHT_FN</a></b></blockquote>
</blockquote>

<hr><hr>

<!------------------------------------------------------------------------->
<h2>
<a NAME="General Functions"></a>Object ID Functions</h2>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NUM_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NUM_OBJ_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;*<i>ierr</i>);</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Num_Obj</i></b>(<i>data, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Num_Obj&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NUM_OBJ_FN</b> query function returns the number
of objects that are currently assigned to the processor.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NUM_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td>The number of objects that are assigned to the processor.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_OBJ_LIST_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef void<b> ZOLTAN_OBJ_LIST_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_ids</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_ids</i>,
int&nbsp;<i>wgt_dim</i>,
float&nbsp;*<i>obj_wgts</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>SUBROUTINE <b><i>Get_Obj_List</i></b>(<i>data, num_gid_entries, num_lid_entries, global_ids, local_ids,
wgt_dim, obj_wgts, ierr</i>)&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: global_ids&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: local_ids&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: wgt_dim&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(*) :: obj_wgts&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_OBJ_LIST_FN</b> query function fills two (three
if weights are used) arrays with information about the objects currently
assigned to the processor. Both arrays are allocated (and subsequently
freed) by Zoltan; their size is determined by a call to a <b><a href="#ZOLTAN_NUM_OBJ_FN">ZOLTAN_NUM_OBJ_FN</a></b>
query function to get the array size. For many algorithms, either a <b>ZOLTAN_OBJ_LIST_FN</b>
query function or a <b><a href="#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>/<b><a href="#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b>
query-function pair must be registered;
however, both query options need not
be provided.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_OBJ_LIST_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_ids</i></td>

<td>Upon return, an array of unique global IDs for all objects assigned to the processor.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_ids</i></td>

<td>Upon return, an array of local IDs, the meaning of which can be determined by the
application, for all objects assigned to the processor.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>wgt_dim</i></td>

<td>The number of weights associated with an object (typically 1), or 0
if weights are not requested.  This value is set through the parameter
<a href="ug_param.html#OBJ_WEIGHT_DIM">OBJ_WEIGHT_DIM</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>obj_wgts</i></td>

<td>Upon return, an array of object weights. Weights for object <i>i</i> are stored in <i>obj_wgts[(i-1)*wgt_dim:i*wgt_dim-1]</i>.&nbsp;
If <i>wgt_dim</i>=0, the return value of <i>obj_wgts</i> is undefined and
may be NULL.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_FIRST_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_FIRST_OBJ_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>first_global_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>first_local_id</i>,
int&nbsp;<i>wgt_dim</i>,
float&nbsp;*<i>first_obj_wgt</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_First_Obj</i></b>(<i>data, num_gid_entries, num_lid_entries, first_global_id, first_local_id,
wgt_dim, first_obj_wgt, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_First_Obj&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: first_global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: first_local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: wgt_dim&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(*) :: first_obj_wgt&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_FIRST_OBJ_FN</b> query function initializes an
iteration over objects assigned to the processor. It returns the global
and local IDs of the first object on the processor. Subsequent calls to
a <b><a href="#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b> query function iterate
over and return other objects assigned to the processor. This query-function
pair frees the application from having to build an array of objects (as
in <b><a href="#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>) and allows 
Zoltan's routines to obtain only as much information about objects
as they need. For many algorithms, either a <b><a href="#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>
query function or a <b>ZOLTAN_FIRST_OBJ_FN</b><i>/</i><b><a href="#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b>
query-function pair must be registered;
however, both query options need not
be provided.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_FIRST_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; first_global_id</i></td>

<td>The returned value of the global ID for the first object; the value
is ignored if there are no objects.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; first_local_id</i></td>

<td>The returned value of the local ID for the first object; the value
is ignored if there are no objects.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>wgt_dim</i></td>

<td>The number of weights associated with an object (typically 1), or 0
if weights are not requested.  This value is set through the parameter
<a href="ug_param.html#OBJ_WEIGHT_DIM">OBJ_WEIGHT_DIM</a>.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>first_obj_wgt</i></td>

<td>Upon return, the first object's weights; an array of length <i>wgt_dim. </i>Undefined if <i>wgt_dim=0.</i></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 1</td>

<td>If <i>first_global_id</i> and <i>first_local_id</i> contain valid IDs
of the first object.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 0</td>

<td>If no objects are available.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NEXT_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NEXT_OBJ_FN</b>
(void&nbsp;*<i>&nbsp;data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>next_global_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>next_local_id</i>,
int&nbsp;<i>wgt_dim,</i>
float&nbsp;*<i>next_obj_wgt</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Next_Obj</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id, next_global_id,
next_local_id, wgt_dim, next_obj_wgt, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Next_Obj&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: next_global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: next_local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: wgt_dim&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(*) :: next_obj_wgt&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NEXT_OBJ_FN</b> query function is an iterator
function which, when given an object assigned to the processor, returns
the next object assigned to the processor. The first object of the iteration
is provided by a <b><a href="#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>
query function. This query-function pair frees the application from having
to build an array of objects (as in <b><a href="#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>)
and allows Zoltan's routines to obtain only as much information
about objects as they need. For many algorithms, either a <b><a href="#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>
query function or a <b><a href="#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>/<b>ZOLTAN_NEXT_OBJ_FN</b>
query-function pair must be registered;
however, both query options need not
be provided.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NEXT_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_id</i></td>

<td>The global ID of the previous object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_id</i></td>

<td>The local ID of the previous object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; next_global_id</i></td>

<td>The returned value of the global ID for the next object; the value
is ignored if there are no more objects.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; next_local_id</i></td>

<td>The returned value of the local ID for the next object; the value is
ignored if there are no more objects.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>wgt_dim</i></td>

<td>The number of weights associated with an object (typically 1), or 0
if weights are not requested.  This value is set through the parameter
<a href="ug_param.html#OBJ_WEIGHT_DIM">OBJ_WEIGHT_DIM</a>.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>next_obj_wgt</i></td>

<td>Upon return, the next object's weights; an array of length <i>wgt_dim. </i>Undefined if <i>wgt_dim=0.</i></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 1</td>

<td>If <i>next_global_id</i> and <i>next_local_id</i> contain valid IDs
of the next object.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 0</td>

<td>If no more objects are available.</td>
</tr>
</table>

<p>
<hr><hr>

<!------------------------------------------------------------------------->
<h2>
<a NAME="Border Functions"></a>Border Object Functions (currently not used)</h2>


<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NUM_BORDER_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NUM_BORDER_OBJ_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>nbor_proc</i>, 
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Num_Border_Obj</i></b>(<i>data, nbor_proc, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Num_Border_Obj
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: nbor_proc&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NUM_BORDER_OBJ_FN</b> query function returns
the number of objects sharing a processor subdomain border (in the communication
graph of the application) with a given processor.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NUM_BORDER_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td VALIGN=TOP><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; nbor_proc</i></td>

<td>The processor ID of the processor for which the number of border objects
should be returned.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td>The number of objects sharing a processor subdomain border with processor
<i>nbor_proc</i>.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_BORDER_OBJ_LIST_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef void <b>ZOLTAN_BORDER_OBJ_LIST_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
int&nbsp;<i>nbor_proc</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_ids</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_ids</i>,
int&nbsp;<i>wgt_dim</i>,
float&nbsp;*<i>obj_wgts</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>SUBROUTINE <b><i>Get_Border_Obj_List</i></b>(<i>data, num_gid_entries, num_lid_entries, nbor_proc, global_ids,
local_ids, wgt_dim, obj_wgts, ierr</i>)&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: nbor_proc&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: global_ids&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: local_ids&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: wgt_dim&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(*) :: obj_wgts&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_BORDER_OBJ_LIST_FN</b> query function fills two
arrays with information about the objects currently assigned to the processor
that share a processor subdomain border (in the communication graph of
the application) with a given processor. Both arrays are allocated (and
subsequently freed) by Zoltan; their size is determined by a call to a <b><a href="#ZOLTAN_NUM_BORDER_OBJ_FN">ZOLTAN_NUM_BORDER_OBJ_FN</a></b>
query function to get the array size. For certain Zoltan algorithms,
either a <b>ZOLTAN_BORDER_OBJ_LIST_FN</b> query function or a <b><a href="#ZOLTAN_FIRST_BORDER_OBJ_FN">ZOLTAN_FIRST_BORDER_OBJ_FN</a></b>/<b><a href="#ZOLTAN_NEXT_BORDER_OBJ_FN">ZOLTAN_NEXT_BORDER_OBJ_FN</a></b>
query-function pair must be registered; however, both query options need not
be provided.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_BORDER_OBJ_LIST_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>


<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>nbor_proc</i></td>

<td>The processor ID of the processor for which border objects should be
returned.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_ids</i></td>

<td>Upon return, an array of unique global IDs for all objects assigned to the processor
that share a subdomain border with <i>nbor_proc</i>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_ids</i></td>

<td>Upon return, an array of local IDs, the meaning of which can be determined by the
application, for all objects assigned to the processor that share a subdomain
border with <i>nbor_proc</i>.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>wgt_dim</i></td>

<td>The number of weights associated with an object (typically 1), or 0
if weights are not requested.  This value is set through the parameter
<a href="ug_param.html#OBJ_WEIGHT_DIM">OBJ_WEIGHT_DIM</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>obj_wgts</i></td>

<td>Upon return, an array of object weights. Weights for object <i>i</i> are stored in <i>obj_wgts[(i-1)*wgt_dim:i*wgt_dim-1]</i>.&nbsp;
If <i>wgt_dim=0,</i> <i>obj_wgts</i> is undefined and may be NULL.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_FIRST_BORDER_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_FIRST_BORDER_OBJ_FN</b>
(void&nbsp;*<i>data</i>, 
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
int&nbsp;<i>nbor_proc</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>first_global_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>first_local_id</i>,
int&nbsp;<i>wgt_dim</i>,
float&nbsp;*<i>first_obj_wgt</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_First_Border_Obj</i></b>(<i>data, num_gid_entries, num_lid_entries, nbor_proc, first_global_id,
first_local_id, wgt_dim, first_obj_wgt, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_First_Border_Obj
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: nbor_proc&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: first_global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: first_local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: wgt_dim&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(*) :: first_obj_wgt&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_FIRST_BORDER_OBJ_FN</b> query function initializes
an iteration over objects assigned to the processor that share a processor
subdomain border with a given processor. It returns the global and local
IDs of the first object on the processor along the specified subdomain
border. Subsequent calls to a <b><a href="#ZOLTAN_NEXT_BORDER_OBJ_FN">ZOLTAN_NEXT_BORDER_OBJ_FN</a></b>
query function iterate over and return other objects along the requested
subdomain border. This query-function pair frees the application from having
to build an array of objects (as in <b><a href="#ZOLTAN_BORDER_OBJ_LIST_FN">ZOLTAN_BORDER_OBJ_LIST_FN</a></b>)
and allows Zoltan to obtain only as much information
about objects as it needs. For some algorithms, either
a <b><a href="#ZOLTAN_BORDER_OBJ_LIST_FN">ZOLTAN_BORDER_OBJ_LIST_FN</a></b> query
function or a <b>ZOLTAN_FIRST_BORDER_OBJ_FN</b>/<b><a href="#ZOLTAN_NEXT_BORDER_OBJ_FN">ZOLTAN_NEXT_BORDER_OBJ_FN</a></b>
query-function pair must be registered; however, both query options need not
be provided.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_FIRST_BORDER_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>nbor_proc</i></td>

<td>The processor ID of the processor for which border objects should be
returned.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; first_global_id</i></td>

<td>The returned value of the global ID for the first object; the value
is ignored if there are no objects along the border.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; first_local_id</i></td>

<td>The returned value of the local ID for the first object; the value
is ignored if there are no objects along the border.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>wgt_dim</i></td>

<td>The number of weights associated with an object (typically 1), or 0
if weights are not requested.  This value is set through the parameter
<a href="ug_param.html#OBJ_WEIGHT_DIM">OBJ_WEIGHT_DIM</a>.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>first_obj_wgt</i></td>

<td>Upon return, the first object's weights; an array of size <i>wgt_dim</i>. Undefined if&nbsp; <i>wgt_dim=</i>0.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 1</td>

<td>If <i>first_global_id</i> and <i>first_local_id</i> contain valid IDs
of the first object along the processor border.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 0</td>

<td>If no objects are available along this processor border.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NEXT_BORDER_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NEXT_BORDER_OBJ_FN</b>
(void&nbsp;*<i>data</i>, 
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>,
int&nbsp;<i>nbor_proc</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>next_global_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>next_local_id</i>,
int&nbsp;<i>wgt_dim</i>,
float&nbsp;*<i>next_obj_wgt</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Next_Border_Obj</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id,
nbor_proc, next_global_id, next_local_id, wgt_dim, next_obj_wgt, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Next_Border_Obj&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: nbor_proc&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: next_global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: next_local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: wgt_dim&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(*) :: next_obj_wgt&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NEXT_BORDER_OBJ_FN</b> query function is an iterator
function which, when given an object assigned to the processor and a neighboring
processor ID, returns the next object assigned to the processor that shares
a subdomain border with the neighboring processor. The first object of
the iteration is provided by a <b><a href="#ZOLTAN_FIRST_BORDER_OBJ_FN">ZOLTAN_FIRST_BORDER_OBJ_FN</a></b>
query function. This query-function pair frees the application from having
to build an array of objects (as in <b><a href="#ZOLTAN_BORDER_OBJ_LIST_FN">ZOLTAN_BORDER_OBJ_LIST_FN</a></b>)
and allows Zoltan to obtain only as much information
about objects as it needs. For some algorithms, either
a <b><a href="#ZOLTAN_BORDER_OBJ_LIST_FN">ZOLTAN_BORDER_OBJ_LIST_FN</a></b> query
function or a <b><a href="#ZOLTAN_FIRST_BORDER_OBJ_FN">ZOLTAN_FIRST_BORDER_OBJ_FN</a></b>/<b>ZOLTAN_NEXT_BORDER_OBJ_FN</b>
query-function pair must be registered;
however, both query options need not
be provided.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NEXT_BORDER_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_id</i></td>

<td>The global ID of the previous object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_id</i></td>

<td>The local ID of the previous object.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>nbor_proc</i></td>

<td>The processor ID of the processor for which border objects should be
returned.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; next_global_id</i></td>

<td>The returned value of the global ID for the next object; the value
is ignored if there are no more objects along the border.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; next_local_id</i></td>

<td>The returned value of the local ID for the next object; the value is
ignored if there are no more objects along the border.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>wgt_dim</i></td>

<td>The number of weights associated with an object (typically 1), or 0
if weights are not requested.  This value is set through the parameter
<a href="ug_param.html#OBJ_WEIGHT_DIM">OBJ_WEIGHT_DIM</a>.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>next_obj_wgt</i></td>

<td>Upon return, the weights for the next object; an array of size <i>wgt_dim</i>.  Undefined if <i>wgt_dim</i>=0.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 1</td>

<td>If <i>next_global_id</i> and <i>next_local_id</i> contain valid IDs
of the next object along the processor border.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 0</td>

<td>If no more objects are available along this processor border.</td>
</tr>
</table>

<hr><hr>

<!------------------------------------------------------------------------->
<h2>
<a NAME="Geometry-based Functions"></a>Geometry-based Functions</h2>


<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NUM_GEOM_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NUM_GEOM_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Num_Geom</i></b>(<i>data, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Num_Geom&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NUM_GEOM_FN</b> query function returns the number
of values needed to express the geometry of an object. For example, for
a two-dimensional mesh-based application, (<i>x</i>,<i>y</i>) coordinates
are needed to describe an object's geometry; thus the <b>ZOLTAN_NUM_GEOM_FN</b>
query function should return the value of two. For a similar three-dimensional
application, the return value should be three.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NUM_GEOM_FN_TYPE</b></td>
</tr>

<tr>
<td VALIGN=TOP><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td>The number of values needed to express the geometry of an object.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_GEOM_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef void <b>ZOLTAN_GEOM_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>,
double&nbsp;*<i>geom_vec</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>SUBROUTINE <b><i>Get_Geom</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id, geom_vec,
ierr</i>)&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: local_id&nbsp;
<br>REAL(Zoltan_DOUBLE), INTENT(OUT), DIMENSION(*) :: geom_vec&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_GEOM_FN</b> query function returns a vector of
geometry values for a given object. The geometry vector is allocated by
Zoltan to be of the size returned by a <b><a href="#ZOLTAN_NUM_GEOM_FN">ZOLTAN_NUM_GEOM_FN</a></b>
query function.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_GEOM_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_id</i></td>

<td>The global ID of the object whose geometry values should be returned.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_id</i></td>

<td>The local ID of the object whose geometry values should be returned.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>geom_vec</i></td>

<td>Upon return, an array containing geometry values.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>
</table>

<br>&nbsp;
<hr><hr>

<!------------------------------------------------------------------------->
<h2>
<a NAME="Graph-based Functions"></a>Graph-based Functions</h2>


<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NUM_EDGES"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NUM_EDGES_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Num_Edges</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id,
ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Num_Edges&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NUM_EDGES_FN</b> query function returns the number
of edges for a given object in the communication graph of the application
(i.e., the number of objects with which the given object must share information).
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NUM_EDGES_FN_TYPE</b></td>
</tr>

<tr>
<td VALIGN=TOP><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>global_id</i></td>

<td>The global ID of the object for which the number of edges should be
returned.</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>local_id</i></td>

<td>The local ID of the object for which the number of edges should be
returned.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td>The number of edges for the object identified by <i>global_id</i> and
<i>local_id</i>.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_EDGE_LIST_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef void <b>ZOLTAN_EDGE_LIST_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>nbor_global_id</i>,
int&nbsp;*<i>nbor_procs</i>,
int&nbsp;<i>wgt_dim</i>,
float&nbsp;*<i>ewgts</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>SUBROUTINE <b><i>Get_Edge_List</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id,
nbor_global_id, nbor_procs, wgt_dim, ewgts, ierr</i>)&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: nbor_global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: nbor_procs&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: wgt_dim&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(*) :: ewgts&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_EDGE_LIST_FN</b> query function returns lists
of global IDs, processor IDs, and optionally edge weights for objects sharing
an edge with a given object (i.e., objects that must share information
with the given object). The arrays for the returned neighbor lists are
allocated by Zoltan; their size is determined by a
call to a <b><a href="#ZOLTAN_NUM_EDGES">ZOLTAN_NUM_EDGES_FN</a></b> query function.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_EDGE_LIST_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_id</i></td>

<td>The global ID of the object for which an edge list should be returned.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_id</i></td>

<td>The local ID of the object for which an edge list should be returned.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>nbor_global_id</i></td>

<td>Upon return, an array of global IDs of objects sharing edges with the
given object.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>nbor_procs</i></td>

<td>Upon return, an array of processor IDs that identifies where the neighboring
objects reside.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>wgt_dim</i></td>

<td>The number of weights associated with an edge (typically 1), or 0 if
edge weights are not requested.  This value is set through the parameter
<a href="ug_param.html#EDGE_WEIGHT_DIM">EDGE_WEIGHT_DIM</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>ewgts</i></td>

<td>Upon return, an array of edge weights, where <i>ewgts[i*wgt_dim:(i+1)*wgt_dim-1]</i>
<br>corresponds to the weights for the <i>i</i>th edge. If <i>wgt_dim=0</i>, the
return value of <i>ewgts </i>is undefined and may be NULL.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>
</table>

<br>&nbsp;
<hr><hr>
<h2>

<!------------------------------------------------------------------------->
<a NAME="Tree-based Functions"></a>Tree-based Functions</h2>


<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NUM_COARSE_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NUM_COARSE_OBJ_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Num_Coarse_Obj</i></b>(<i>data, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Num_Coarse_Obj&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NUM_COARSE_OBJ_FN</b> query function returns
the number of objects (elements) in the initial coarse grid.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NUM_COARSE_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td VALIGN=TOP><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td>The number of objects in the coarse grid.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_COARSE_OBJ_LIST_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef void <b>ZOLTAN_COARSE_OBJ_LIST_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_ids</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_ids</i>,
int&nbsp;*<i>assigned</i>,
int&nbsp;*<i>num_vert</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>vertices</i>, 
int&nbsp;*<i>in_order</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>in_vertex</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>out_vertex</i>, 
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>SUBROUTINE <b><i>Get_Coarse_Obj_List</i></b>(<i>data, num_gid_entries, num_lid_entries, global_ids, local_ids,
assigned, num_vert, vertices, in_order, in_vertex, out_vertex, ierr</i>)&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: global_ids&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: local_ids&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: assigned, num_vert, vertices,
in_vertex, out_vertex&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: in_order, ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_COARSE_OBJ_LIST_FN</b> query function returns
lists of global IDs, local IDs, vertices, and order information for all
objects (elements) of the initial coarse grid. The vertices are designated
by a global ID such that if two elements share a vertex then the same ID
designates that vertex in both elements and on all processors.
The user may choose to provide the order in which the elements should be
traversed or have Zoltan determine the order. If the user provides the
order, then entry and exit vertices for a path through the elements may
also be provided. The arrays for the returned values are allocated by 
Zoltan; their size is determined by a call to a <b><a href="#ZOLTAN_NUM_COARSE_OBJ_FN">ZOLTAN_NUM_COARSE_OBJ_FN</a></b>
query function.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_COARSE_OBJ_LIST_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_ids</i></td>

<td>Upon return, an array of global IDs of all objects in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_ids</i></td>

<td>Upon return, an array of local IDs of all objects in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>assigned</i></td>

<td>Upon return, an array of integers indicating whether or not each object
is currently assigned to this processor. A value of 1 indicates it is assigned
to this processor; a value of 0 indicates it is assigned to some other
processor. For elements that have been refined, it is ignored unless weights
are assigned to interior nodes of the tree.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; num_vert</i></td>

<td>Upon return, an array containing the number of vertices for each object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; vertices</i></td>

<td>Upon return, an array of global IDs of the vertices of each object. If the
number of vertices for objects 0 through <i>i</i>-1 is <i>N</i>, then the
vertices for object <i>i</i> are in <i>vertices</i>[<i>N*num_gid_entries:
(N+num_vert</i>[<i>i</i>]<i>)*num_gid_entries</i>]</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; in_order</i></td>

<td>Upon return, 1 if the user is providing the objects in the order in
which they should be traversed, or 0 if Zoltan should determine the order.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; in_vertex</i></td>

<td>Upon return, an array of global IDs of the vertices through which to enter
each element in the user provided traversal. It is required only if the
user is providing the order for the coarse grid objects (i.e., <i>in_order</i>==1)
and allowing Zoltan to select the order of the children in at least one
invocation of
<b><a href="#ZOLTAN_CHILD_LIST_FN">ZOLTAN_CHILD_LIST_FN</a></b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; out_vertex</i></td>

<td>Upon return, an array of global IDs of the vertex through which to exit each
element in the user provided traversal. The same provisions hold as for
<i>in_vertex</i>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_FIRST_COARSE_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_FIRST_COARSE_OBJ_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>, 
int&nbsp;*<i>assigned</i>,
int&nbsp;*<i>num_vert</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>vertices</i>, 
int&nbsp;*<i>in_order</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>in_vertex</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>out_vertex</i>, 
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_First_Coarse_Obj</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id,
assigned, num_vert, vertices, in_order, in_vertex, out_vertex, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_First_Coarse_Obj&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: assigned, num_vert, in_order, ierr&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: vertices, in_vertex, out_vertex&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_FIRST_COARSE_OBJ_FN</b> query function initializes
an iteration over the objects of the initial coarse grid. It returns the
global ID, local ID, vertices, and order information for the first object
(element) of the initial coarse grid. Subsequent calls to a <b><a href="#ZOLTAN_NEXT_COARSE_OBJ_FN">ZOLTAN_NEXT_COARSE_OBJ_FN</a></b>
iterate over and return other objects from the coarse grid. The vertices
are designated by a global ID such that if two elements share a vertex then
the same ID designates that vertex in both elements and on all processors.
The user may choose to provide the order in which the elements
should be traversed, or have Zoltan determine the order. If the user provides
the order, then entry and exit vertices for a path through the elements
may also be provided.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_FIRST_COARSE_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_ids</i></td>

<td>Upon return, the global ID of the first object in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_ids</i></td>

<td>Upon return, the local ID of the first object in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>assigned</i></td>

<td>Upon return, an integer indicating whether or not this object is currently
assigned to this processor. A value of 1 indicates it is assigned to this
processor; a value of 0 indicates it is assigned to some other processor.
For elements that have been refined, it is ignored unless weights are assigned
to interior nodes of the tree.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; num_vert</i></td>

<td>Upon return, the number of vertices for this object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; vertices</i></td>

<td>Upon return, an array of global IDs of the vertices of this object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; in_order</i></td>

<td>Upon return, 1 if the user is providing the objects in the order in
which they should be traversed, or 0 if Zoltan should determine the order.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; in_vertex</i></td>

<td>Upon return, the vertex through which to enter this element in the
user provided traversal. It is required only if the user is providing the
order for the coarse grid objects (i.e., <i>in_order</i>==1) and allowing
Zoltan to select the order of the children in at least one invocation of
<b><a href="#ZOLTAN_CHILD_LIST_FN">ZOLTAN_CHILD_LIST_FN</a></b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; out_vertex</i></td>

<td>Upon return, the vertex through which to exit this element in the user
provided traversal. The same provisions hold as for
<i>in_vertex</i>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 1</td>

<td>If <i>global_id</i> and <i>local_id</i> contain valid IDs of the first
object in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 0</td>

<td>If no coarse grid is available.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NEXT_COARSE_OBJ_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NEXT_COARSE_OBJ_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>next_global_id</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>next_local_id</i>, 
int&nbsp;*<i>assigned</i>,
int&nbsp;*<i>num_vert</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>vertices</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>in_vertex</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>out_vertex</i>, 
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Next_Coarse_Obj</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id,
next_global_id, next_local_id,
assigned, num_vert, vertices, in_vertex, out_vertex, ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Next_Coarse_Obj&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: next_global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: next_local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: assigned, num_vertex, ierr&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: vertices, in_vertex, out_vertex&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NEXT_COARSE_OBJ_FN</b> query function is an iterator
function that returns the next object in the initial coarse grid. 
The first object
of the iteration is provided by a <b><a href="#ZOLTAN_FIRST_COARSE_OBJ_FN">ZOLTAN_FIRST_COARSE_OBJ_FN</a></b>
query function.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NEXT_COARSE_OBJ_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_id</i></td>

<td>The global ID of the previous object in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_id</i></td>

<td>The local ID of the previous object in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; next_global_id</i></td>

<td>Upon return, the global ID of the next object in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; next_local_id</i></td>

<td>Upon return, the local ID of the next object in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>assigned</i></td>

<td>Upon return, an integer indicating whether or not this object is currently
assigned to this processor. A value of 1 indicates it is assigned to this
processor; a value of 0 indicates it is assigned to some other processor.
For elements that have been refined, it is ignored unless weights are assigned
to interior nodes of the tree.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; num_vert</i></td>

<td>Upon return, the number of vertices for this object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; vertices</i></td>

<td>Upon return, an array of global IDs of the vertices of this object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; in_vertex</i></td>

<td>Upon return, the vertex through which to enter this element in the
user provided traversal. It is required only if the user is providing the
order for the coarse grid objects (i.e., <i>in_order</i>==1) and allowing
Zoltan to select the order of the children in at least one invocation of
<b><a href="#ZOLTAN_CHILD_LIST_FN">ZOLTAN_CHILD_LIST_FN</a></b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; out_vertex</i></td>

<td>Upon return, the vertex through which to exit this element in the user
provided traversal. The same provisions hold as for
<i>in_vertex</i>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 1</td>

<td>If <i>global_id</i> and <i>local_id</i> contain valid IDs of the next
object in the coarse grid.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; 0</td>

<td>If no more objects are available.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_NUM_CHILD_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef int <b>ZOLTAN_NUM_CHILD_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b><i>Get_Num_Child</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id,
ierr</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Get_Num_Child&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_NUM_CHILD_FN</b> query function returns the number
of children of the element with the given global and local IDs. If the
element has not been refined, the number of children is 0.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_NUM_CHILD_FN_TYPE</b></td>
</tr>

<tr>
<td VALIGN=TOP><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_id</i></td>

<td>The global ID of the object for which the number of children is requested.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_id</i></td>

<td>The local ID of the object for which the number of children is requested.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>

<tr>
<td VALIGN=TOP><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td>The number of children.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_CHILD_LIST_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef void <b>ZOLTAN_CHILD_LIST_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>parent_gid</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>parent_lid</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>child_gids</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>child_lids</i>,
int&nbsp;*<i>assigned</i>,
int&nbsp;*<i>num_vert</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>vertices</i>,
<b>ZOLTAN_REF_TYPE</b>&nbsp;*<i>ref_type</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>in_vertex</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>out_vertex</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>SUBROUTINE <b><i>Get_Child_List</i></b>(<i>data, parent_gid, parent_lid,
child_gids, child_lids, assigned, num_vert, vertices, ref_type, in_vertex,
out_vertex, ierr</i>)&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: parent_gid&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: parent_lid&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: child_gids&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: child_lids&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), DIMENSION(*) :: assigned, num_vert, vertices,
in_vertex, out_vertex&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ref_type, ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_CHILD_LIST_FN</b> query function returns lists
of global IDs, local IDs, vertices, and order information for all children
of a refined element. The vertices are designated by a global ID
such that if two elements share a vertex then the same ID designates that
vertex in both elements and on all processors. The user may choose to
provide the order in which the children should be traversed, or have Zoltan
determine the order based on the type of element refinement used to create
the children. If the user provides the order, then entry and exit vertices
for a path through the elements may also be provided. The arrays for the
returned values are allocated by Zoltan; their size
is determined by a call to a <b><a href="#ZOLTAN_NUM_CHILD_FN">ZOLTAN_NUM_CHILD_FN</a></b>
query function.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_CHILD_LIST_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; parent_gid</i></td>

<td>The global ID of the object whose children are requested.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; parent_lid</i></td>

<td>The local ID of the object whose children are requested.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; child_gids</i></td>

<td>Upon return, an array of global IDs of all children of this object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; child_lids</i></td>

<td>Upon return, an array of local IDs of all children of this object.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>assigned</i></td>

<td>Upon return, an array of integers indicating whether or not each child
is currently assigned to this processor. A value of 1 indicates it is assigned
to this processor; a value of 0 indicates it is assigned to some other
processor. For children that have been further refined, it is ignored unless
weights are assigned to interior nodes of the tree.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; num_vert</i></td>

<td>Upon return, an array containing the number of vertices for each object.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; vertices</i></td>

<td>Upon return, an array of global IDs of the vertices of each object. If the
number of vertices for objects 0 through <i>i</i>-1 is <i>N</i>, then the
vertices for object <i>i</i> are in <i>vertices</i>[<i>N*num_gid_entries:
(N+num_vert</i>[<i>i</i>]<i>)*num_gid_entries</i>]</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ref_type</i></td>

<td>Upon return, a value indicating what type of refinement was used to
create the children. This determines how the children will be ordered.
The values currently supported are:</td>
</tr>

<tr>
<td></td>

<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>ZOLTAN_TRI_BISECT</i> Bisection of triangles.</td>
</tr>

<tr>
<td></td>

<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>ZOLTAN_QUAD_QUAD</i> Quadrasection of quadrilaterals.</td>
</tr>

<tr>
<td></td>

<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>ZOLTAN_OTHER_REF</i> All other forms of
refinement.</td>
</tr>

<tr>
<td></td>

<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>ZOLTAN_IN_ORDER</i> Traverse the children
in the order in which they are provided.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; in_vertex</i></td>

<td>Upon return, an array of global IDs of the vertex through which to enter
each element in the user provided traversal. It is required only if the
user is providing the order for the children of this element (i.e.,
<i>ref_type</i>==<i>ZOLTAN_IN_ORDER</i>)
but does not provide the order for the children of at least one of those
children.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; out_vertex</i></td>

<td>Upon return, an array of global IDs of the vertex through which to exit each
element in the user provided traversal. The same provisions hold as for
<i>in_vertex</i>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>
</table>

<p>

<!------------------------------------------------------------------------->
<hr WIDTH="100%">
<a NAME="ZOLTAN_CHILD_WEIGHT_FN"></a>
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%">
typedef void<b> ZOLTAN_CHILD_WEIGHT_FN</b>
(void&nbsp;*<i>data</i>,
int&nbsp;<i>num_gid_entries</i>,
int&nbsp;<i>num_lid_entries</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>global_id</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;<i>local_id</i>,
int&nbsp;<i>wgt_dim</i>,
float&nbsp;*<i>obj_wgt</i>,
int&nbsp;*<i>ierr</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>SUBROUTINE <b><i>Get_Child_Weight</i></b>(<i>data, num_gid_entries, num_lid_entries, global_id, local_id,
wgt_dim, obj_wgt, ierr</i>)&nbsp;
<br>&lt;<i>type-data</i>>, INTENT(IN) :: data&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: num_gid_entries, num_lid_entries&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: global_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN), DIMENSION(*) :: local_id&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(IN) :: wgt_dim&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(*) :: obj_wgt&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: ierr&nbsp;
<p>&lt;<i>type-data</i>> can be any of INTEGER(Zoltan_INT), DIMENSION(*) or
REAL(Zoltan_FLOAT), DIMENSION(*) or REAL(Zoltan_DOUBLE), DIMENSION(*) or TYPE(Zoltan_User_Data_<i>x</i>)
where <i>x</i> is 1, 2, 3 or 4. See the section on
<a href="ug_fortran_api.html#fortran ug api query">Fortran
query functions</a> for an explanation.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">A <b>ZOLTAN_CHILD_WEIGHT_FN</b> query function returns the
weight of an object. Interior nodes of the refinement tree as well as the
leaves are allowed to have weights.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Function Type:</b></td>

<td WIDTH="80%"><b>ZOLTAN_CHILD_WEIGHT_FN_TYPE</b></td>
</tr>

<tr>
<td><b>Arguments:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; data</i></td>

<td>Pointer to user-defined data.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>The number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>The number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_param.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; global_id</i></td>

<td>The global ID of the object whose weight is requested.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; local_id</i></td>

<td>The local ID of the object whose weight is requested.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>wgt_dim</i></td>

<td>The number of weights associated with an object (typically 1), or 0
if weights are not requested.  This value is set through the parameter
<a href="ug_param.html#OBJ_WEIGHT_DIM">OBJ_WEIGHT_DIM</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>obj_wgt</i></td>

<td>Upon return, an array containing the object's weights. If <i>wgt_dim</i>=0, the return
value of <i>obj_wgts</i> is undefined and may be NULL.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; ierr</i></td>

<td>Error code to be set by function.</td>
</tr>
</table>

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | 
<a href="ug_query_mig.html">Next:&nbsp;
Migration Query Functions</a>&nbsp; |&nbsp; <a href="ug_query.html">Previous:&nbsp;
Application-Registered Query Functions</a>]
</body>
</html>
