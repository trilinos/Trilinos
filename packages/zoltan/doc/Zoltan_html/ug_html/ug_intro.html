<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  Introduction</title>
<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->

</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_usage.html">Next</a>&nbsp; |&nbsp; <a href="ug.html">Previous</a></i></b></div>

<h2>
<a NAME="Introduction"></a>Introduction</h2>

<blockquote>
<a href="#Motivation">Project Motivation</a>
<br><a href="#Terms">Terminology Example</a>
<br><a href="#Load-Balancing Tools">Load-Balancing Tools</a>
<br><a href="#Migration Tools">Migration Tools</a>
<br><a href="#Component Libraries">Component Libraries</a>
</blockquote>
<a NAME="Motivation"></a>Over the past decade, the use of parallel computing
to solve large-scale scientific problems has grown immensely. Many traditional
numerical methods, such as finite difference and finite element methods,
have been shown to be effective and efficient in parallel computing environments;
see [<a href="ug_refs.html#attaway">Attaway et al.</a>] and [<a href="ug_refs.html#mpsalsa-gordonbell">Devine
et al.</a>] for two examples. They have typically been implemented in an
MIMD fashion, with portions of the problem domain being assigned uniquely
to individual processors. This static decomposition of the domain is done
as a pre-processing step to the actual computation either by the application
itself or by some static partitioning tool such as 
<a href="http://www.cs.sandia.gov/CRF/chac.html">Chaco</a>,
<a href="http://www-users.cs.umn.edu/~karypis/metis/">METIS</a>
or <a href="http://www.gre.ac.uk/jostle/">Jostle</a>.
<p>As the desire for simulations with greater complexity and resolution
arises, new numerical schemes have been developed, such as adaptive numerical
methods, multiphysics simulations, and adaptive physics models. In these
applications, the amount of work per processor can vary over time. For
example, in adaptive finite element methods, the number of degrees of freedom
within a processor can increase or decrease as the method requires greater
or lower accuracy in a region of the problem domain. The changing processor
work-loads make a static decomposition of the domain insufficient; a dynamic
load-balancing strategy is needed to readjust work-loads as the computation
proceeds.
<p>Several important differences exist between static and dynamic load-balancing
strategies. Dynamic strategies are complicated by the fact that they must
be implemented in parallel without interfering with the scalability of
the application. Thus, they must use little memory and execute quickly.
Also because they run side-by-side with an application, dynamic strategies
must use a subroutine interface, rather than the file-based interface used
by most static partitioners. Additionally, dynamic load-balancing algorithms
should be "incremental"; that is, small changes in the processor work loads
should produce only small changes in the decomposition so that little data
movement is required to establish the new decomposition. Most static decomposition
strategies do not explicitly enforce this incremental property; good dynamic
strategies must either implicitly or explicitly enforce it.
<p>In the past, most dynamic load-balancing strategies have been implemented
on a case-by-case basis within application programs. Typically, a single
strategy was implemented in an application, relying heavily upon the data
structures of the particular application. This approach has two disadvantages.
First, because its implementation relies heavily upon a single application,
the load-balancing algorithm is not easily re-used by other applications.
Second, because the application developer is usually interested more in
the physics of the simulation than in the performance of dynamic load-balancing
algorithms, only one algorithm is implemented and comparisons to other
load-balancing methods are not performed to find, perhaps, a more effective
strategy.&nbsp; See [<a href="ug_refs.html#hendrickson-devine">Hendrickson
and Devine</a>] for a more thorough discussion of these issues.
<p>The goal of the Zoltan Library project is to
provide application developers a general-purpose dynamic load-balancing
tool that can be easily used by a variety of applications. The library
consists of several different dynamic load-balancing algorithms and is
designed so that new algorithms can easily be added to the library. An
object-oriented library interface separates the data structures of the
load-balancing routines from those of the application. The library's routines
gather information (such as lists of objects to be balanced, their weights,
and their coordinates) from the application through a series of query functions.
(Note that "objects" in Zoltan are the entities that should be load-balanced or migrated). 
These simple query functions must be provided by the application and "registered"
with the library. In this manner, the library never directly accesses the
application's data structures. Use of the library in a different application
requires only that the new application supply its own set of query functions
to Zoltan. Once the appropriate query functions are
registered with Zoltan, the application can easily
select from a number of load-balancing algorithms and invoke load balancing
at the appropriate places in its computation. While some extra memory and
function-call overhead is required by this call-back protocol, the generality
and ease of use of the library obtained by it is well justified.
<p>The Zoltan library consists of two parts: dynamic load-balancing tools
that compute new decompositions based on current processor work loads,
and migration tools that perform the communication needed to move
data to establish a new decomposition. Each set of tools is described below.

<p>Also included with the Zoltan package is a sample application, 
<i>zdrive</i>.
The <i>zdrive</i> program reads graph and/or coordinate information from
either NemesisI or 
<a href="http://www.cs.sandia.gov/CRF/chac.html">Chaco</a>
input files, runs Zoltan using this input, and 
writes simple output files containing information about the resulting
decomposition.  It allows algorithm developers 
to test changes to Zoltan without having to run Zoltan in 
a large application code.  Application developers can use the <i>zdrive</i>
code to see examples of function calls to Zoltan and the implementation of 
geometric and graph-based query functions.
For information
on how to build and use <i>zdrive</i>, see the <a href="../dev_html/dev_driver.html">Test
Driver</a> section of the <a href="../dev_html/dev.html">Zoltan Developer's
Guide</a>.

<h2>
<a NAME="Terms"></a>Terminology Example</h2>
We use a simple example to illustrate the terminology that will be used in this
documentation.  In the figure 
<a href="#Terms Figure">below</a>, a simple finite element mesh is presented.
<p>
<center><a NAME="Terms Figure"></a><img SRC="figures/Z.gif"></center>
<p>
The blue and yellow shading indicates the mesh is partitioned for two
processors.  To repartition this mesh using Zoltan, an application must
provide information about the current partition to Zoltan.  In this example,
the application wants to distribute the elements equally over two processors,
so when Zoltan asks for <i>object</i> information, the application must 
provide information about the elements.  
<p>
Zoltan requires that each object have a unique identifier (ID).
In this example, the elements have unique numbers
assigned to them, as shown by the numbers in the elements.  These unique
numbers can be used as <i>global IDs</i> in Zoltan.  In addition, on each
processor, local numbering information may be available.
For instance, the elements owned by a processor may be stored in arrays
in the processor's memory.  An element's local array index may be provided to Zoltan
as a <i>local ID</i> to improve the efficiency of functions that provide
information about the element to Zoltan.
<p>
For geometric partitioning methods, the application must provide coordinate
information to Zoltan.  In this example, the coordinates of the mid-point of 
an element are used.
<p>
For graph-based partitioning methods, information about the connectivity of
the objects must be provided to Zoltan.  In this example, the application may
consider elements connected if they share a face.  The connections between
elements, or <i>edges</i> of the connectivity graph, are shown in red.
Connectivity information is passed to Zoltan by specifying a neighbor list for
an object.  The neighbor list consists of the global IDs of neighboring objects
and the processor(s) currently owning those objects.
<p>
The table below summarizes the information provided to Zoltan by an
application for this finite element mesh.  Information about the objects
includes their global and local IDs, geometry data, and graph data.
<p>
<table Border="2" Width="100%">
<tr>
<td></td> 
<td COLSPAN="2"><center>Object IDs</center></td>
<td><center>Geometry Data</center></td> 
<td COLSPAN="2"><center>Graph Data</center></td>
</tr>
<tr>
<td><center>Processor</center></td> 
<td><center>Global</center></td> 
<td><center>Local</center></td> 
<td><center>(coordinates)</center></td>
<td><center>Neighbor Global ID List</center></td> 
<td><center>Neighbor Processor List</center></td>
</tr>
<tr>
<td><center>Blue</center></td> 
<td><center>1</center></td>
<td><center>0</center></td>
<td><center>(0.8,2.9)</center></td>
<td><center>2</center></td>
<td><center>Blue</center></td>
</tr>
<tr>
<td><center></center></td> 
<td><center>2</center></td>
<td><center>1</center></td>
<td><center>(1.7,2.9)</center></td>
<td><center>1,3</center></td>
<td><center>Blue,Blue</center></td>
</tr>
<tr>
<td><center></center></td> 
<td><center>3</center></td>
<td><center>2</center></td>
<td><center>(2.5,2.9)</center></td>
<td><center>2,4</center></td>
<td><center>Blue,Yellow</center></td>
</tr>
<tr>
<td><center>Yellow</center></td> 
<td><center>4</center></td>
<td><center>0</center></td>
<td><center>(2.0,2.1)</center></td>
<td><center>3,5</center></td>
<td><center>Blue,Yellow</center></td>
</tr>
<tr>
<td><center></center></td> 
<td><center>5</center></td>
<td><center>1</center></td>
<td><center>(1.1,1.0)</center></td>
<td><center>4,6</center></td>
<td><center>Yellow,Yellow</center></td>
</tr>
<tr>
<td><center></center></td> 
<td><center>6</center></td>
<td><center>2</center></td>
<td><center>(0.5,0.2)</center></td>
<td><center>5,7</center></td>
<td><center>Yellow,Yellow</center></td>
</tr>
<tr>
<td><center></center></td> 
<td><center>7</center></td>
<td><center>3</center></td>
<td><center>(1.3,0.2)</center></td>
<td><center>6,8</center></td>
<td><center>Yellow,Yellow</center></td>
</tr>
<tr>
<td><center></center></td> 
<td><center>8</center></td>
<td><center>4</center></td>
<td><center>(2.1,0.2)</center></td>
<td><center>7</center></td>
<td><center>Yellow</center></td>
</tr>
</table>


<h2>
<a NAME="Load-Balancing Tools"></a>Load-Balancing Tools</h2>
Within the Zoltan library, many algorithms for dynamically determining
new processor decompositions can be implemented. Information needed by
the algorithms is obtained through queries to the application's data structures
using application defined and registered query routines. Zoltan's query routines
include geometric queries (supplying information such as coordinates
for objects), graph-based queries (supplying such information as edge lists
for objects in the communication graph of the computation), and tree-based
queries (supplying information about the parent-child relationships in
the refinement tree generated by an adaptive
mesh-refinement application).
<p>A typical interaction between an application and the dynamic load-balancing
tools is shown in the <a href="#lb_interaction.gif">figure</a> below. Through
a call to <b><a href="ug_interface_init.html#Zoltan_Create">Zoltan_Create</a></b>,
the application creates a data structure, which is storage
space to hold pointers to registered functions and data.
This structure is passed to a number of Zoltan functions. The application
then selects a load-balancing method to be used (Recursive Coordination
Bisection, "RCB," in the example) through a call to <b><a href="ug_interface_lb.html#Zoltan_LB_Set_Method">Zoltan_LB_Set_Method</a></b>.
Several query functions needed by the RCB algorithm are registered through
calls to <b><a href="ug_interface_init.html#Zoltan_Set_Fn">Zoltan_Set_Fn</a></b>.
These query functions include application-defined functions to return the
number of objects on the processor (<i>user_return_num_elems_fn</i>), a
list of the objects (<i>user_return_elem_list_fn</i>), and the coordinates
for a given object (<i>user_return_coords_fn</i>). When the application 
needs load balancing, 
it calls <b><a href="ug_interface_lb.html#Zoltan_LB_Balance">Zoltan_LB_Balance</a></b>
to compute a new decomposition on the processors.
<p>Zoltan then follows pointers to the registered query
functions to build the data structures needed for the RCB algorithm. An
array of data is built, with one entry for each object owned by the processor.
The number of objects is determined by following the <i>Get_Num_Obj</i>
pointer to the <i>user_return_num_elems_fn</i>. Storage is allocated for
the objects, and lists of the objects' identification numbers are obtained
by following the <i>Get_Obj_List</i> function pointer to the <i>user_return_elem_list_fn</i>.
Then, for each object, the object's coordinates are obtained through calls
through the <i>Get_Geom</i> function pointer to the registered function
<i>user_return_coords_fn</i>.
Once the data structures are built, Zoltan can perform
the RCB decomposition and return arrays of information describing the new
decomposition to the application.
<br>&nbsp;
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td NOSAVE><a NAME="lb_interaction.gif"></a>Application&nbsp;
<table BORDER=2 WIDTH="80%" NOSAVE >
<tr>
<td>.<tt>..</tt>
<br><tt>/* <i>Register method and application query functions</i> */</tt>
<br><tt>zz = Zoltan_Create(MPI_COMM_WORLD);</tt>
<br><tt>Zoltan_LB_Set_Method(zz, "RCB");</tt>
<br><tt>Zoltan_Set_Fn(zz,ZOLTAN_GEOM_FN_TYPE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void (*)())user_return_coords_fn,NULL);</tt>
<br><tt>Zoltan_Set_Fn(zz,ZOLTAN_NUM_OBJ_FN_TYPE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void (*)())user_return_num_elems_fn,NULL);</tt>
<br><tt>Zoltan_Set_Fn(zz,ZOLTAN_OBJ_LIST_FN_TYPE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void (*)())user_return_elem_list_fn,NULL);</tt>
<br><tt>...</tt>
<br><tt>/* <i>Call the load balancer</i> */</tt>
<br><tt>Zoltan_LB_Balance(zz,&amp;new,&amp;num_gid,&amp;num_lid,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;num_imp,&amp;imp_glob_ids,&amp;imp_loc_ids,&amp;imp_procs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;num_exp,&amp;exp_glob_ids,&amp;exp_loc_ids,&amp;exp_procs);</tt></td>
</tr>
</table>
&nbsp;</td>
</tr>

<tr>
<td>
<center><img SRC="figures/arrow.gif" height=48 width=112></center>
</td>
</tr>

<tr>
<td>
<div align=right>Dynamic Load Balancer</div>
&nbsp;
<div ALIGN=right><table BORDER=2 WIDTH="80%" NOSAVE >
<tr>
<td><tt>...</tt>
<br><tt>/* <i>call registered functions to build </i> */</tt>
<br><tt>/* <i>Zoltan data structures</i> */</tt>
<br><tt>num_objs = zz->Get_Num_Obj(zz->Get_Num_Obj_Data, </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&amp;ierr);&nbsp;</tt>
<br><tt>/* <i>allocate memory for global and local IDs </i>*/</tt>
<br><tt>...</tt>
<br><tt>/* <i>call query functions to obtain object data</i>*/</tt>
<br><tt>zz->Get_Obj_List(zz->Get_Obj_List_Data,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_gid, num_lid,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; global_ids, local_ids,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, NULL, &amp;ierr);&nbsp;</tt>
<br><tt>for (i = 0; i &lt; num_objs; i++) {</tt>
<br><tt>&nbsp;&nbsp; ZOLTAN_SET_GID(zz, zz->Data[i].Global_Tag, &amp;global_ids[i]);</tt>
<br><tt>&nbsp;&nbsp; ZOLTAN_SET_LID(zz, zz->Data[i].Local_Tag, &amp;local_ids[i]);</tt>
<br><tt>&nbsp;&nbsp; zz->Get_Geom(zz->Get_Geom_Data, num_gid, num_lid,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;global_ids[i], &amp;local_ids[i],&nbsp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zz->Data[i].Coords, &amp;ierr);</tt>
<br><tt>}</tt>
<br><tt>/* <i>perform balancing on zz->Data</i> */</tt>
<br><tt>...</tt></td>
</tr>
</table></div>
&nbsp;</td>
</tr>

<caption ALIGN=BOTTOM><i>Example of interaction between the application
and the load balancer.</i></caption>
</table>

<h2>
<a NAME="Migration Tools"></a>Migration Tools</h2>
Data migration is, unfortunately, an extremely application-dependent part
of establishing new decompositions. It involves gathering objects from
the data structures on one processor, sending those objects to a new processor,
inserting the objects into the new processor's data structures, and removing
the objects from the original processor. In addition, auxiliary data may
have to be sent to the new processor to support the objects migrated there.
For example, in a finite element application, the "objects" used in load
balancing may be elements. But when elements are migrated to new processors,
the nodes associated with those elements must also be sent to the new processors,
increasing the dependence of data migration on the application.
<p>A general-purpose library can not perform all the operations
required for data migration in all applications. However, it can assist
an application with the communication required for data migration. As a
result of the load-balancing algorithm, the library knows where data must
be sent to establish the new decomposition and can perform all needed communication
using communication tools within the library. The application, then, must
specify how to gather data associated with migrating objects and how to
insert that data into the new processor's data structures. Following the
registered query-function design of the dynamic load-balancing tools, migration
tools can then be provided to the application. An example of the interaction
between the application and the migration tools is shown in the <a href="#mig_interaction.gif">figure</a>
below. The application registers three additional query functions: a function
that returns the size (in bytes) of the data buffer needed to gather all
of <i>one object's</i> data (<i>user_elem_size_fn</i>), a function that packs
<i>one object's</i> data into a buffer (<i>user_pack_one_elem_fn</i>), 
and a function
that unpacks <i>one object's</i> data and inserts it into the new processor's
data structure (<i>user_unpack_one_elem_fn</i>).
<p>The migration tools then use these registered functions with the
results of the load-balancing algorithm to move data between processors.
The migration tools follow the <i>Get_Obj_Data_Size</i> function pointer
to <i>user_elem_size_fn</i> to obtain the size of the data buffer needed
for an object's data. They allocate appropriately sized import and export
buffers. Through repeated calls to the <i>Pack_Object</i> function (<i>user_pack_one_elem_fn</i>),
the migration tools fill the export buffer with data for each object
to be exported. The migration tools then send the export buffer data
to other processors and receive import data from other processors. Then,
for each object imported, the migration help tools call the registered
<i>Unpack_Object</i>
function (<i>user_unpack_one_elem_fn</i>) to unpack the data from the import
buffer and insert it in the processor's data structure. Under this model,
the application developer does not have to implement additional communication
routines to perform data migration; the migration tools handle all
communication required for data movement.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td NOSAVE><a NAME="mig_interaction.gif"></a>Application&nbsp;
<table BORDER=2 WIDTH="80%" NOSAVE >
<tr>
<td><tt>...</tt>
<br><tt>/* <i>Register packing and unpacking functions</i> */</tt>
<br><tt>Zoltan_Set_Fn(zz, ZOLTAN_OBJ_SIZE_FN_TYPE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void (*)())user_elem_size_fn,NULL);</tt>
<br><tt>Zoltan_Set_Fn(zz, ZOLTAN_PACK_OBJ_FN_TYPE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void (*)())user_pack_one_elem_fn,NULL);</tt>
<br><tt>Zoltan_Set_Fn(zz, ZOLTAN_UNPACK_OBJ_FN_TYPE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void (*)())user_unpack_one_elem_fn, NULL);</tt>
<br><tt>...</tt></td>
</tr>
</table>
&nbsp;</td>
</tr>

<tr>
<td>
<center><img SRC="figures/arrow.gif" height=48 width=112></center>
</td>
</tr>

<tr>
<td>
<div align=right>Migration Tools</div>
&nbsp;
<div ALIGN=right><table BORDER=2 COLS=1 WIDTH="80%" NOSAVE >
<tr NOSAVE>
<td NOSAVE><tt>...</tt>
<br><tt>total_size = 0;</tt>
<br><tt>for each object i being exported {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size[i] = zz->Get_Obj_Size(zz->Get_Obj_Size_Data,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_gid, num_lid,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;exp_global_id[i],</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;exp_local_id[i],</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;ierr);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; total_size += size[i];</tt>
<br><tt>}</tt>
<br>
<br><tt>/* <i>allocate export buffer with size total_size</i> */</tt>
<br><tt>...</tt>
<br>
<br><tt>/* <i>pack all objects for export</i> */</tt>
<br><tt>for each object i being exported</tt>
<br><tt>&nbsp;&nbsp;&nbsp; zz->Pack_Obj(zz->Pack_Obj_Data,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_gid, num_lid,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;exp_global_id[i],</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;exp_local_id[i], exp_procs[i], </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
size[i], export_buf[i], &amp;ierr);&nbsp;</tt>
<p><tt>/* <i>perform communication using map</i> */</tt>
<br><tt>communicate(zz, export_buf, &amp;import_buf);</tt>
<p><tt>/* <i>unpack all imported objects</i> */</tt>
<br><tt>for each object i received</tt>
<br><tt>&nbsp;&nbsp;&nbsp; zz->Unpack_Obj(zz->Unpack_Obj_Data, </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
num_gid, &amp;imp_global_id[i],</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
size[i], import_buf[i], &amp;ierr);</tt>
<br><tt>...</tt></td>
</tr>
</table></div>
&nbsp;</td>
</tr>

<caption ALIGN=BOTTOM><i>Example of interaction between the application
and the migration tools.</i></caption>
</table>

<p>The migration tools are separate modules from the dynamic load-balancing
tools. Thus, an application does not have to use the migration tools
even though it uses the dynamic load-balancing tools to compute a new decomposition.
If the application has its own migration routines, it can use them in conjunction
with the load-balancing routines in Zoltan.
<br>&nbsp;

<h2>
<a NAME="Component Libraries"></a>Component Libraries</h2>

Zoltan is built upon several lower level libraries.  First among these
is MPI.  Although our development efforts have primarily used MPICH,
we have tested the code with other MPI implementations on a variety
of platforms.  We have every expectation that Zoltan will work fine
with any MPI library (version 1.1 or later).
<p>
Zoltan also uses three other low level 
<a href="../dev_html/dev_util.html">utility libraries</a>.
Although these were developed in conjunction with Zoltan, we
chose to separate them since they provide functionality which may be
of value outside of Zoltan.  The first of these is a
<a href="../dev_html/dev_util_mem.html">memory management library</a>.
Basically, this is a wrapper around the standard C malloc and free
calls which facilitates the debugging of memory problems.
The second library provides support for 
<a href="../dev_html/dev_util_comm.html">unstructured communication</a>.
Specifically, it helps with the determination of communication patterns
for complex sets of messages, and performs the data transfers
efficiently.  Most of the non-trivial communication operations within
Zoltan are performed by this library.  The third library contains a 
<a href="../dev_html/dev_util_dd.html">distributed data directory</a>
that provides efficient, distributed methods for locating off-processor
data.

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a href="ug_usage.html">Next:&nbsp;
Using the Library</a>&nbsp; | <a href="ug.html">Previous:&nbsp; Table of
Contents</a>]
</body>
</html>
