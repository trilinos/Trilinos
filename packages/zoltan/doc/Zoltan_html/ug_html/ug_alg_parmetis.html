<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.6 sun4m) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  ParMETIS Interface</title>
<!-----------------------------------------------------------------------------
 ! Zoltan Dynamic Load-Balancing Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->

</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_alg_jostle.html">Next</a>&nbsp; |&nbsp; <a href="ug_alg_rib.html">Previous</a></i></b></div>

<h2>
<a NAME="ParMETIS"></a>ParMETIS</h2>
<a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
is a parallel library for graph partitioning (for static load balancing)
and repartitioning (for dynamic load balancing) developed at the University
of Minnesota by Karypis, Schloegel and Kumar [<a href="ug_refs.html#parmetis">Karypis
and Kumar</a>]. ParMETIS is therefore strictly speaking not a method but
rather a collection of methods. In the Zoltan context, ParMETIS is a method
with many sub-methods. Zoltan provides an interface to all the ParMETIS
(sub-)methods.&nbsp; The user selects which ParMETIS method to use through
the parameter PARMETIS_METHOD. Most of the ParMETIS methods are based on
either multilevel Kernighan-Lin partitioning or a diffusion algorithm.
The names of the ParMETIS methods used by Zoltan are identical to those
in the ParMETIS library. For further information about the various <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
methods and parameters, please consult the <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
User's Guide.
<p>Graph partitioning is a useful abstraction for load balancing. The main
idea is to represent the computational application as a weighted graph.
The nodes or vertices in the graph correspond to objects in Zoltan.&nbsp;
Each object may have a weight that normally represents the amount of computation.
The edges or arcs in the graph usually correspond to communication costs.
In graph partitioning, the problem is to find a partitioning of the graph
(that is,&nbsp; each vertex is assigned to one out of <i>k</i> possible
sets called partitions) that minimizes the cut size (weight) subject to
the partitions having approximately equal size (weight). In repartitioning,
it is assumed that a partitioning already exists. The problem is to find
a good partitioning that is also "similar" in some sense to the existing
partitioning. This keeps the migration cost low. All the problems described
above are NP-hard so no efficient exact algorithm is known. We remark that
in Zoltan 1.*, the number of partitions is always the same as the number of
MPI processes (which is normally equal to the number of processors).
<p>We give only a brief summary of the various ParMETIS methods here; for
more details see the <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS</a>
documentation. The methods fall into three categories:
<ol>
<li>
Part* - Perform graph partitioning without consideration of the initial
distribution.</li>

<li>
Repart* - Incremental algorithms with small migration cost.</li>

<li>
Refine* - Refines a given partitioning (balance).&nbsp; Can be applied
multiple times to reduce the communication cost (cut weight) if desired.</li>
</ol>
As a rule of thumb, use one of the Part* methods if you have a poor initial
balance and you are willing to spend some time doing migration. One such
case is static load balancing; that is, you need to balance only once.
Use the Repart* methods when you have a reasonably good load balance that
you wish to update incrementally. These methods are well suited&nbsp; for
dynamic load balancing (for example,&nbsp; adaptive mesh refinement). A
reasonable strategy is to call PartKway once to obtain a good initial balance
and&nbsp; later update this balance using one of the Repart* methods.

<p>The graph given to Zoltan/ParMETIS must be symmetric.
Any self edges (loops) will be ignored. Multiple edges between
a pair of vertices is not allowed. All weights must
be non-negative. The graph does not have to be connected.

<p>Zoltan is currently compatible with ParMETIS version 2.0.&nbsp;
There is no guarantee that Zoltan will work correctly if you have a different
version of ParMETIS on your computer. Source and documentation for ParMETIS
can be obtained from the <a href="http://www-users.cs.umn.edu/~karypis/metis/parmetis/">ParMETIS
home page</a>. As a courtesy service,&nbsp; a compatible version of the
ParMETIS&nbsp; source code is distributed with Zoltan. However, ParMETIS
is a completely separate library. If you do not wish to install ParMETIS,
it is possible to compile Zoltan without any references to ParMETIS&nbsp;
(when you 'make' Zoltan, comment out the PARMETIS_LIBPATH variable in the
configuration file <i><a href="ug_usage.html#Building the Library">Utilities/Config/Config.&lt;platform></a></i>).

<p>The current version of Zoltan ignores the imbalance tolerance parameter
IMBALANCE_TOL when ParMETIS is used, as ParMETIS 2.0 fixes the corresponding
imbalance parameter at 1.05. We expect that future versions of ParMETIS
will allow the user to select the tolerance for load imbalance. When this
feature becomes available in ParMETIS, it will also be supported through
IMBALANCE_TOL in Zoltan.

<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP><b>Method String:</b></td>

<td><b>PARMETIS</b></td>
</tr>

<tr>
<td><b>Parameters:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; PARMETIS_METHOD</i></td>

<td>The ParMETIS method to be used; currently eight are available.&nbsp;
<br><i>PartKway</i> - multilevel Kernighan-Lin partitioning&nbsp;
<br><i>PartGeom</i> - space filling curves (coordinate based)&nbsp;
<br><i>PartGeomKway</i> - hybrid method based on PartKway and PartGeom
(needs both&nbsp; graph data and coordinates)&nbsp;
<br><i>RepartLDiffusion</i> - diffusion algorithm (local)&nbsp;
<br><i>RepartGDiffusion</i> - diffusion algorithm (global)&nbsp;
<br><i>RepartRemap</i> - multilevel partioning with remap seeking to minimize
migration cost&nbsp;
<br><i>RepartMLRemap</i> - similar to RepartRemap but with additional multilevel
refinement&nbsp;
<br><i>RefineKway</i> - refine the current partitioning (balance)</td>
</tr>

<tr>
<td></td>

<td>The method names are case insensitive.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>PARMETIS_OUTPUT_LEVEL</i></td>

<td>Amount of output the load-balancing algorithm should produce.&nbsp;
<br>0 = no output, 1 = print timing info. Turning on more bits displays
more information (for example, 3=1+2, 5=1+4, 7=1+2+4).</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>PARMETIS_COARSE_ALG</i></td>

<td>Coarse algorithm for PartKway. 1 = serial, 2 = parallel.</td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp; <i>PARMETIS_FOLD</i></td>

<td>Folding parameter for PartKway (for expert ParMETIS users only).</td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>&nbsp;&nbsp;&nbsp; <i>CHECK_GRAPH</i></td>

<td NOSAVE>Level of error checking for graph input: 0 = no checking, 1
= on-processor checking, 2 = full checking.  (CHECK_GRAPH==2 is very slow and should
be used only during debugging).</td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>&nbsp;&nbsp;&nbsp; <i>SCATTER_GRAPH</i></td>

<td NOSAVE>Scatter graph data by distributing contiguous chunks of objects
(vertices) of roughly equal size to each processor before calling
the partitioner. 0 = don't scatter; 1 = scatter only if all objects are
on a single processor; 2 = scatter if at least one processor owns no objects
(recommended to avoid a bug in ParMETIS 2.0.0); 3 = always scatter.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP><b>Default values:</b></td>

<td></td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_METHOD</i> = RepartGDiffusion</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_OUTPUT_LEVEL</i> = 0</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_COARSE_ALG </i>= 2</td>
</tr>

<tr>
<td></td>

<td><i>PARMETIS_FOLD </i>= 0</td>
</tr>

<tr>
<td></td>

<td><i>CHECK_GRAPH</i> = 1</td>
</tr>

<tr>
<td></td>

<td><i>SCATTER_GRAPH </i>= 1</td>
</tr>

<tr>
<td VALIGN=TOP><b>Required Query Functions:</b></td>

<td></td>
</tr>

<tr>
<td>For all submethods:</td>

<td><b><a href="ug_query_lb.html#ZOLTAN_NUM_OBJ_FN">ZOLTAN_NUM_OBJ_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a></b>
or <b><a href="ug_query_lb.html#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a></b>/<b><a href="ug_query_lb.html#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></b>
pair</td>
</tr>

<tr>
<td>Only PartGeom &amp; PartGeomKway:</td>

<td><b><a href="ug_query_lb.html#ZOLTAN_NUM_GEOM_FN">ZOLTAN_NUM_GEOM_FN</a></b></td>
</tr>

<tr>
<td></td>

<td><b><a href="ug_query_lb.html#ZOLTAN_GEOM_FN">ZOLTAN_GEOM_FN</a></b></td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>All but PartGeom:</td>

<td NOSAVE><b><a href="ug_query_lb.html#Graph-based Functions">ZOLTAN_NUM_EDGES_FN</a></b>
<br><b><a href="ug_query_lb.html#Graph-based Functions">ZOLTAN_EDGE_LIST_FN</a></b></td>
</tr>
</table>

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a href="ug_alg_jostle.html">Next:&nbsp;
Jostle</a>&nbsp; |&nbsp; <a href="ug_alg_rib.html">Previous:&nbsp; 
Recursive Inertial Bisection (RIB)</a>]
</body>
</html>
