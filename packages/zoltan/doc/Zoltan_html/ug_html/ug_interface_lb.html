<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; U; SunOS 5.7 sun4u) [Netscape]">
   <meta name="sandia.approved" content="SAND99-1377">
   <meta name="author" content="karen devine, kddevin@sandia.gov">
   <title>Zoltan User's Guide:  Load-Balancing Interface</title>
<!-----------------------------------------------------------------------------
 ! Zoltan Library for Parallel Applications            !
 ! Copyright (c) 2000, Sandia National Laboratories.                          !
 ! This document is released under the GNU Lesser General Public License.     !
 ! For more info, see the README file in the top-level Zoltan directory.      !
 !----------------------------------------------------------------------------!
-->
<!-- CVS File Information
     $RCSfile$
     $Author$
     $Date$
     $Revision$
-->

</head>
<body bgcolor="#FFFFFF">

<div align=right><b><i><a href="ug.html">Zoltan User's Guide</a>&nbsp;
|&nbsp; <a href="ug_interface_augment.html">Next</a>&nbsp; |&nbsp; <a href="ug_interface_init.html">Previous</a></i></b></div>

<h2>
<a NAME="Load-Balancing Functions"></a>Load-Balancing Functions</h2>
The following functions are the load-balancing interface functions in the
Zoltan library; their descriptions are included below.
<blockquote><b><a href="#Zoltan_LB_Set_Method">Zoltan_LB_Set_Method</a></b>
<br><b><a href="#Zoltan_Set_Param">Zoltan_Set_Param</a></b>
<br><b><a href="#Zoltan_LB_Balance">Zoltan_LB_Balance</a></b>
<br><b><a href="#Zoltan_LB_Eval">Zoltan_LB_Eval</a></b>
<br><b><a href="#Zoltan_LB_Free_Data">Zoltan_LB_Free_Data</a></b>
<br><b><a href="#Zoltan_Destroy">Zoltan_Destroy</a></b></blockquote>

<hr WIDTH="100%">
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%"><a NAME="Zoltan_LB_Set_Method"></a>int <b>Zoltan_LB_Set_Method</b>
(struct&nbsp;<b>Zoltan_Struct</b>&nbsp;*<i>zz</i>,
char&nbsp;*<i>string</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>Zoltan_LB_Set_Method</b>(<i>zz</i>, <i>string</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Zoltan_LB_Set_Method&nbsp;
<br>TYPE(Zoltan_Struct), INTENT(IN) :: zz&nbsp;
<br>CHARACTER(LEN=*), INTENT(IN) :: string&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%"><b>Zoltan_LB_Set_Method</b> is used to specify which load-balancing
algorithm should be used by the application.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Arguments:</b></td>
<td WIDTH="80%"></td>
</tr>

<tr>
<td><i>&nbsp;&nbsp;&nbsp; zz</i></td>

<td>Pointer to the Zoltan structure created by <b><a href="ug_interface_init.html#Zoltan_Create">Zoltan_Create</a></b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; string</i></td>

<td>A string containing the name of the desired load-balancing technique.
Valid values for <i>string</i> are&nbsp;
<blockquote>"RCB" (for <a href="ug_alg_rcb.html#RCB">recursive coordinate
bisection</a>),&nbsp;
<br>"RIB" (for <a href="ug_alg_rib.html">recursive inertial bisection</a>),
<br>"HSFC" (for <a href="ug_alg_rib.html">Hilbert space-filling curve partitioning</a>),
<br>"PARMETIS" (for any of the methods in the <a href="ug_alg_parmetis.html">ParMETIS</a>
library),&nbsp;
<br>"JOSTLE" (for any of the methods in the <a href="ug_alg_jostle.html">Jostle</a>
library),&nbsp;
<br>"OCTPART" (for <a href="ug_alg_oct.html#Octree">octree partitioning</a>),&nbsp;
<br>"REFTREE" (for <a href="ug_alg_reftree.html">refinement tree based
partitioning</a>), and&nbsp;
<br>"NONE" (for no load-balancing).</blockquote>
</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td><a href="ug_interface.html#Error Codes">Error code</a>.</td>
</tr>

<tr>
<td><b>Default:</b></td>

<td></td>
</tr>

<tr>
<td></td>

<td>If <b>Zoltan_LB_Set_Method</b> is not called, <a href="ug_alg_rcb.html#RCB">RCB</a>
is used.</td>
</tr>
</table>

<hr WIDTH="100%">
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%"><a NAME="Zoltan_Set_Param"></a>int <b>Zoltan_Set_Param</b>
(struct&nbsp;<b>Zoltan_Struct</b>&nbsp;*<i>zz</i>,
char&nbsp;*<i>param_name</i>,
char&nbsp;*<i>new_val</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>Zoltan_Set_Param</b>(<i>zz, param_name, new_val</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Zoltan_Set_Param&nbsp;
<br>TYPE(Zoltan_Struct), INTENT(IN) :: zz&nbsp;
<br>CHARACTER(LEN=*), INTENT(IN) :: param_name, new_value&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%"><b>Zoltan_Set_Param</b> is used to alter the value of one
of the parameters used by Zoltan.&nbsp; All Zoltan parameters have reasonable
default values, but this routine allows a user to provide alternative values
if desired.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Arguments:</b></td>
<td WIDTH="80%"></td>
</tr>

<tr>
<td><i>&nbsp;&nbsp;&nbsp; zz</i></td>

<td>Pointer to the Zoltan structure created by <b><a href="ug_interface_init.html#Zoltan_Create">Zoltan_Create</a></b>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp; param_name</i></td>

<td>A string containing the name of the parameter to be altered.&nbsp;
Note that the string is case-insensitive.&nbsp; Also, different Zoltan
structures can have different parameter values.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp; new_val</i></td>

<td>A string containing the new value for the parameter.&nbsp; Example
strings include "3.154", "True", "7" or anything appropriate for the parameter
being set. As above, the string is case-insensitive.&nbsp;</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td><a href="ug_interface.html#Error Codes">Error code</a>.</td>
</tr>

<tr>
<td></td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>
</tr>
</table>

<hr WIDTH="100%">
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%"><a NAME="Zoltan_LB_Balance"></a>int <b>Zoltan_LB_Balance</b>
(struct&nbsp;<b>Zoltan_Struct</b>&nbsp;*<i>zz</i>,
int&nbsp;*<i>changes</i>,
int&nbsp;*<i>num_gid_entries</i>,
int&nbsp;*<i>num_lid_entries</i>,
int&nbsp;*<i>num_import</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;*<i>import_global_ids</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;*<i>import_local_ids</i>,
int&nbsp;**<i>import_procs</i>,
int&nbsp;*<i>num_export</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;*<i>export_global_ids</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;*<i>export_local_ids</i>,
int&nbsp;**<i>export_procs</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>Zoltan_LB_Balance</b>(<i>zz, changes, num_gid_entries, num_lid_entries,
num_import, import_global_ids, import_local_ids, import_procs, num_export,
export_global_ids, export_local_ids, export_procs</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Zoltan_LB_Balance&nbsp;
<br>TYPE(Zoltan_Struct), INTENT(IN) :: zz&nbsp;
<br>LOGICAL, INTENT(OUT) :: changes&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: num_gid_entries, num_lid_entries
<br>INTEGER(Zoltan_INT), INTENT(OUT) :: num_import, num_export&nbsp;
<br>INTEGER(Zoltan_INT), POINTER, DIMENSION(:) :: import_global_ids, export_global_ids&nbsp;
<br>INTEGER(Zoltan_INT), POINTER, DIMENSION(:) :: import_local_ids, export_local_ids&nbsp;
<br>INTEGER(Zoltan_INT), POINTER, DIMENSION(:) :: import_procs, export_procs&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%"><b>Zoltan_LB_Balance</b> invokes the load-balancing routine specified
by <b><a href="#Zoltan_LB_Set_Method">Zoltan_LB_Set_Method</a></b>.  Results of the 
partitioning are returned in lists of objects to be imported and exported.
These arrays are allocated in Zoltan; applications should not allocate these
arrays before calling <b>Zoltan_LB_Balance</b>.  The arrays are later freed through
calls to <a href="#Zoltan_LB_Free_Data"><b>Zoltan_LB_Free_Data</b></a>.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Arguments:</b></td>
<td WIDTH="80%"></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; zz</i></td>

<td>Pointer to the Zoltan structure, created by <b><a href="ug_interface_init.html#Zoltan_Create">Zoltan_Create</a></b>,
to be used in this invocation of the load-balancing routine.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; changes</i></td>

<td>Set to 1 or .TRUE. if the decomposition was changed by the load-balancing
method; 0 or .FALSE. otherwise.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_gid_entries</i></td>

<td>Upon return, the number of array entries used to describe a single
global ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_alg.html#NUM_GID_ENTRIES">NUM_GID_ENTRIES</a>.</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP NOSAVE>&nbsp;&nbsp;&nbsp; <i>num_lid_entries</i></td>

<td>Upon return, the number of array entries used to describe a single
local ID.&nbsp; This value is the maximum value over all processors of
the parameter <a href="ug_alg.html#NUM_LID_ENTRIES">NUM_LID_ENTRIES</a>.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; num_import&nbsp;</i></td>

<td>Upon return, the number of objects that are now assigned to this processor
that were assigned to other processors in the old decomposition (i.e.,
the number of objects to be imported to this processor).
If the value returned is -1, no import information has been returned and all 
import arrays below are NULL (see the
<a href="ug_alg.html#RETURN_LISTS">RETURN_LISTS</a> parameter for more
information).
</td>
</tr>

<tr>
<td VALIGN=TOp><I>&nbsp;&nbsp;&nbsp; import_global_ids</i></td>

<td>Upon return, an array of <i>num_import</i> global IDs of objects to
be imported to this processor.
<br>(size = <i>num_import</i> * <i>num_gid_entries</i>)</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; import_local_ids</i></td>

<td>Upon return, an array of&nbsp; <i>num_import</i> local IDs of objects
to be imported to this processor.
<br>(size = <i>num_import</i> * <i>num_lid_entries</i>)</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; import_procs</i></td>

<td>Upon return, an array of size <i>num_import</i> listing the processor
IDs of the processors that owned the imported objects in the previous decomposition
(i.e., the source processors).</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; num_export</i></td>

<td>Upon return, the number of objects that were assigned to this processor
in the previous decomposition that are now assigned to other processors
(i.e., the number of objects that must be exported from this processor
to other processors).
If the value returned is -1, no export information has been returned and all
export arrays below are NULL (see the
<a href="ug_alg.html#RETURN_LISTS">RETURN_LISTS</a> parameter for more
information).
</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; export_global_ids</i></td>

<td>Upon return, an array of <i>num_export</i> global IDs of objects to
be exported from this processor.&nbsp;
<br>(size = <i>num_export</i> * <i>num_gid_entries</i>)</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; export_local_ids</i></td>

<td>Upon return, an array of <i>num_export</i> local IDs of objects to
be exported from this processor.
<br>(size = <i>num_export</i> * <i>num_lid_entries</i>)</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; export_procs</i></td>

<td>Upon return, an array of size <i>num_export </i>listing the processor
IDs of processors that will own the exported objects in the new decomposition
(i.e., the destination processors).</td>
</tr>

<tr>
<td><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td><a href="ug_interface.html#Error Codes">Error code</a>.</td>
</tr>
</table>

<p>
<hr WIDTH="100%">
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%"><a NAME="Zoltan_LB_Eval"></a>int <b>Zoltan_LB_Eval</b>
(struct&nbsp;<b>Zoltan_Struct</b>&nbsp;*<i>zz</i>,
int&nbsp;<i>print_stats</i>,
int&nbsp;*<i>nobj</i>,
float&nbsp;*o<i>bj_wgt</i>,
int&nbsp;*<i>ncuts</i>,
float&nbsp;*<i>cut_wgt</i>,
int&nbsp;*<i>nboundary</i>,
int&nbsp;*<i>nadj</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>Zoltan_LB_Eval</b>(<i>zz, print_stats,&nbsp; nobj, obj_wgt, ncuts,
cut_wgt, nboundary, nadj</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Zoltan_LB_Eval
<br>TYPE(Zoltan_Struct), INTENT(IN) :: zz&nbsp;
<br>LOGICAL, INTENT(IN) :: print_stats&nbsp;
<br>INTEGER(Zoltan_INT), INTENT(OUT), OPTIONAL :: nobj, ncuts, nboundary, nadj
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(vwgt_dim), OPTIONAL :: obj_wgt&nbsp;
<br>REAL(Zoltan_FLOAT), INTENT(OUT), DIMENSION(ewgt_dim), OPTIONAL :: cut_wgt&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%"><b>Zoltan_LB_Eval </b>evaluates the quality of a decomposition.
Some quality metrics
are available only if the graph query functions have been registered. <b>Zoltan_LB_Eval
</b>may
either print a summary of the results to <i>stdout</i> or return the results
in the output parameters.
<br>&nbsp;
<table WIDTH="100%" NOSAVE >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Arguments:</b></td>
<td WIDTH="80%"></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; zz</i></td>

<td>Pointer to the Zoltan structure.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; print_stats</i></td>

<td>If <i>print_stats</i>>0 (.TRUE. in Fortran), print a summary (max,
min,&nbsp; and sum) of the quality metrics to <i>stdout.</i></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; nobj</i></td>

<td>Upon return, the number of objects on this processor.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; obj_wgt</i></td>

<td>Upon return, an array (of dimension <a href="ug_alg.html#OBJ_WEIGHT_DIM">OBJ_WEIGHT_DIM</a>) 
containing the sum of object weights on this processor.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>ncuts</i></td>

<td>Upon return,&nbsp; the number of (communication) edge cuts&nbsp; for
this processor.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>cut_wgt</i></td>

<td>Upon return, an array (of dimension <a href="ug_alg.html#EDGE_WEIGHT_DIM">EDGE_WEIGHT_DIM</a>) 
of cut weights for this processor.&nbsp;</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>nboundary</i></td>

<td>Upon return,&nbsp; the number of boundary objects on this processor.</td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; <i>nadj</i></td>

<td>Upon return,&nbsp; the number of adjacent processors as defined by
the communication graph.</td>
</tr>

<tr>
<td></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td><a href="ug_interface.html#Error Codes">Error code.</a></td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td><b>Query functions:</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp; Required:</td>

<td NOSAVE>
<br><a href="ug_query_lb.html#ZOLTAN_NUM_OBJ_FN">ZOLTAN_NUM_OBJ_FN</a>
<br><a href="ug_query_lb.html#ZOLTAN_OBJ_LIST_FN">ZOLTAN_OBJ_LIST_FN</a> or <a href="ug_query_lb.html#ZOLTAN_FIRST_OBJ_FN">ZOLTAN_FIRST_OBJ_FN</a>/<a href="ug_query_lb.html#ZOLTAN_NEXT_OBJ_FN">ZOLTAN_NEXT_OBJ_FN</a></td>
</tr>

<tr VALIGN=TOP NOSAVE>
<td>&nbsp;&nbsp;&nbsp;&nbsp; Optional:</td>

<td NOSAVE><a href="ug_query_lb.html#ZOLTAN_NUM_EDGES">ZOLTAN_NUM_EDGES_FN</a>
<br><a href="ug_query_lb.html#ZOLTAN_EDGE_LIST_FN">ZOLTAN_EDGE_LIST_FN</a></td>
</tr>
</table>
An output parameter is returned only if the input value of that parameter
was not NULL. The rationale for this feature is that if one wishes just
to print the evaluation results, one can simply set all (or some of) the
output parameters to NULL in the function call. From Fortran, one may omit
one or more of the optional output parameters.
<p>Note that the sum of <i>ncuts</i> over all processors is actually twice
the number of edges cut in the graph (because each edge is counted twice).
The same principle holds for <i>cut_wgt.</i>
<p>
<hr WIDTH="100%">
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%"><a NAME="Zoltan_LB_Free_Data"></a>int <b>Zoltan_LB_Free_Data</b>
(<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;*<i>import_global_ids</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;*<i>import_local_ids</i>,
int&nbsp;**<i>import_procs</i>, 
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;*<i>export_global_ids</i>,
<a href="ug_usage.html#Data Types for Object IDs"><b>ZOLTAN_ID_PTR</b></a>&nbsp;*<i>export_local_ids</i>,
int&nbsp;**<i>export_procs</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>FUNCTION <b>Zoltan_LB_Free_Data</b>(<i>import_global_ids, import_local_ids,
import_procs, export_global_ids, export_local_ids, export_procs</i>)&nbsp;
<br>INTEGER(Zoltan_INT) :: Zoltan_LB_Free_Data&nbsp;
<br>INTEGER(Zoltan_INT), POINTER, DIMENSION(:) :: import_global_ids, export_global_ids&nbsp;
<br>INTEGER(Zoltan_INT), POINTER, DIMENSION(:) :: import_local_ids, export_local_ids&nbsp;
<br>INTEGER(Zoltan_INT), POINTER, DIMENSION(:) :: import_procs, export_procs&nbsp;
</td>
</tr>
</table>

<hr WIDTH="100%"><b>Zoltan_LB_Free_Data</b> frees the memory allocated by the
Zoltan to return the results of <b><a href="#Zoltan_LB_Balance">Zoltan_LB_Balance</a></b> or
<b><a href="ug_interface_mig.html#Zoltan_Compute_Destinations">Zoltan_Compute_Destinations</a></b>.
Memory pointed to by the arguments is freed and the arguments are set to
NULL in C or nullified in Fortran. NULL arguments may be passed to 
<b>Zoltan_LB_Free_Data</b>.  Note that this function does not destroy the
Zoltan data structure itself; it is deallocated through a call to <b><a href="#Zoltan_Destroy">Zoltan_Destroy</a></b>.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Arguments:</b></td>
<td WIDTH="80%"></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; import_global_ids</i></td>

<td>The array containing the global IDs of objects imported to this processor.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; import_local_ids</i></td>

<td>The array containing the local IDs of objects imported to this processor.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; import_procs</i></td>

<td>The array containing the processor IDs of the processors that owned
the imported objects in the previous decomposition (i.e., the source processors).</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; export_global_ids&nbsp;</i></td>

<td>The array containing the global IDs of objects exported from this processor.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; export_local_ids</i></td>

<td>The array containing the local IDs of objects exported from this processor.</td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; export_procs</i></td>

<td>The array containing the processor IDs of processors that own the exported
objects in the new decomposition (i.e., the destination processors).</td>
</tr>

<tr>
<td VALIGN=TOP><b>Returned Value:</b></td>

<td></td>
</tr>

<tr>
<td VALIGN=TOP>&nbsp;&nbsp;&nbsp; int</td>

<td><a href="ug_interface.html#Error Codes">Error code</a>.&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%">
<hr WIDTH="100%">
<table WIDTH="100%" NOSAVE >
<tr NOSAVE>
<td VALIGN=TOP NOSAVE>C:</td>

<td WIDTH="85%"><a NAME="Zoltan_Destroy"></a>void <b>Zoltan_Destroy</b>
(struct&nbsp;<b>Zoltan_Struct</b>&nbsp;**<i>zz</i>);&nbsp;</td>
</tr>

<tr NOSAVE>
<td VALIGN=TOP WIDTH="15%" NOSAVE>FORTRAN:</td>

<td>SUBROUTINE <b>Zoltan_Destroy</b>(<i>zz</i>)&nbsp;
<br>TYPE(Zoltan_Struct), POINTER :: zz&nbsp;</td>
</tr>
</table>

<hr WIDTH="100%"><b>Zoltan_Destroy</b> frees the memory associated with a Zoltan
structure and sets the structure to NULL in C or nullifies the structure
in Fortran. Note that <b>Zoltan_Destroy</b> does not deallocate the import
and export arrays returned from <b><a href="#Zoltan_LB_Balance">Zoltan_LB_Balance</a></b>;
these arrays can be deallocated through a separate call to <b><a href="#Zoltan_LB_Free_Data">Zoltan_LB_Free_Data</a></b>.
<br>&nbsp;
<table WIDTH="100%" >
<tr>
<td VALIGN=TOP WIDTH="20%"><b>Arguments:</b></td>
<td WIDTH="80%"></td>
</tr>

<tr>
<td VALIGN=TOP><i>&nbsp;&nbsp;&nbsp; zz</i></td>

<td>A pointer to the address of the Zoltan structure, created by
<b><a href="ug_interface_init.html#Zoltan_Create">Zoltan_Create</a></b>,
to be destroyed.&nbsp;</td>
</tr>
</table>

<p>
<hr WIDTH="100%">[<a href="ug.html">Table of Contents</a>&nbsp; | <a href="ug_interface_augment.html">Next:&nbsp;
Functions for Augmenting a Decomposition</a>&nbsp; |&nbsp; <a href="ug_interface_init.html">Previous:&nbsp;
Initialization Functions</a>]
</body>
</html>
