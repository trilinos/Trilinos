#!/bin/csh
##############################################################################
# Zoltan Library for Parallel Applications                                   #
# Copyright (c) 2000,2001,2002, Sandia National Laboratories.                #
# For more info, see the README file in the top-level Zoltan directory.      # 
##############################################################################
##############################################################################
# CVS File Information
#    $RCSfile$
#    $Author$
#    $Date$
#    $Revision$
##############################################################################
#
# This C-shell script runs all the test examples 
# and compares the results against pre-computed results.
#
# Usage: test_zoltan [-arch arch-type] [-cmd command] 
#
# where arch-type is one of {generic, solaris, gcc, gcc64, linux, tflop, cplant,
# dec, sgi32, sgi64}.
# Alternatively, give a run command with the -cmd option.
#

# Chaco problems to run
set ch_name  = (simple nograph vwgt ewgt bug onedbug grid20x19 film hammond)
set ch_nproc = (4 4 3 4 3 3 5 6 8) # no. of procs
# Nemesis problems to run  
set nem_name = (box_064 ti_300 ti_4k)
set nem_nproc = (5 6 9) # no. of procs
set nem_pdisk = (1 2 2) # parallel disk info

# Hypergraph problems to run, and methods to use
set hg_name = (ibm01 ibm02 ibm03 ibm04 ibm05 ibm06 ibm07 ibm08 ibm09 ibm10 \
               ibm11 ibm12 ibm13 ibm14 ibm15 ibm16 ibm17 ibm18)
set hg_methods = (mxm rrm rem rhm grm lhm pgm gm2 rm2 gm3 gm4 mxp rep rhp grp \
                  lhp rrp pgp mxg reg rhg grg rrg ipm)

# Set default options
set out_tag = out
set logfile = test_zoltan.log
set answers = answers
set outdir = output
unset run
unset arch

# Check for environment variables.
# They all start with ZOLTAN_ to avoid namespace pollution in the shell.
if ($?ZOLTAN_ARCH) then
   set arch = $ZOLTAN_ARCH
endif

set no_hg = $?ZOLTAN_NO_HG
set no_chaco = $?ZOLTAN_NO_CHACO
set no_nemesis = $?ZOLTAN_NO_NEMESIS
set no_rcb = $?ZOLTAN_NO_RCB
set no_rib = $?ZOLTAN_NO_RIB
set no_hsfc = $?ZOLTAN_NO_HSFC
set no_oct = $?ZOLTAN_NO_OCT
set no_parmetis = $?ZOLTAN_NO_PARMETIS
set no_order = $?ZOLTAN_NO_ORDER
set no_reftree = $?ZOLTAN_NO_REFTREE
set yes_jostle = $?ZOLTAN_YES_JOSTLE
set yes_fortran = $?ZOLTAN_YES_FORTRAN
set yes_serial = $?ZOLTAN_YES_SERIAL
set old_interface = $?ZOLTAN_OLD_INTERFACE

# Parse command-line options. 
# These options will override the environment variables.

while ( $#argv )

  if ( ("$1" == "-h") || ("$1" == "-help") ) then
     goto usage
  else if ( "$1" == "-no_hg" ) then
     @ no_hg = 1
  else if ( "$1" == "-no_nemesis" ) then
     @ no_nemesis = 1
  else if ( "$1" == "-no_chaco" ) then
     @ no_chaco = 1
  else if ( "$1" == "-no_rcb" ) then
     @ no_rcb = 1
  else if ( "$1" == "-no_rib" ) then
     @ no_rib = 1
  else if ( "$1" == "-no_hsfc" ) then
     @ no_hsfc = 1
  else if ( "$1" == "-no_oct" ) then
     @ no_oct = 1
  else if ( "$1" == "-no_parmetis" ) then
     @ no_parmetis = 1
  else if ( "$1" == "-no_reftree" ) then
     @ no_reftree = 1
  else if ( "$1" == "-no_order" ) then
     @ no_order = 1
  else if ( "$1" == "-yes_jostle" ) then
     @ yes_jostle = 1
  else if ( "$1" == "-yes_fortran" ) then
     @ yes_fortran = 1
  else if ( "$1" == "-yes_serial" ) then
     @ yes_serial = 1
     @ no_nemesis = 1   # Nemesis input files require multiple processors
  else if ( "$1" == "-old_interface" ) then
     @ old_interface = 1
  else if ( "$1" == "-logfile" || "$1" == "-log" ) then
  
    if ( $#argv < 2 ) then
      echo "Error: No argument for $1"
      goto usage
    endif
    
    shift argv
    set logfile = "$1"
    
  else if ( "$1" == "-arch" ) then
  
    if ( $#argv < 2 ) then
      echo "Error: No argument for -arch"
      goto usage
    endif
    
    shift argv
    set arch = "$1"
    
  else if ( "$1" == "-cmd" ) then
    if ( $#argv < 2 ) then
      echo "Error: No argument for -cmd"
      goto usage
    endif
    
    shift argv
    set run = "$1"
  
  else if ( "$1" == "-exe" ) then
    if ( $#argv < 2 ) then
      echo "Error: No argument for -exe"
      goto usage
    endif
    
    shift argv
    set zdrive = "$1"
  
  endif
  
  shift argv

end # while ( $#argv )

# Chaco problems to run
set ch_name = (simple nograph vwgt ewgt bug onedbug grid20x19 film hammond)
if ( $yes_serial ) then
  set ch_nproc = (1 1 1 1 1 1 1 1 1) # no. of procs
else
  set ch_nproc = (4 4 3 4 3 3 5 6 8) # no. of procs
endif

# Nemesis problems to run  
set nem_name = (box_064 ti_300 ti_4k)
set nem_nproc = (5 6 9) # no. of procs
set nem_pdisk = (1 2 2) # parallel disk info


# Determine what command to use to launch a parallel program based on $arch
if (! $?run ) then
  if ( $?arch ) then
    switch ( $arch )
    case generic:
    case gcc:
    case gccP3:
    case g++:
    case linux:
    case purecov:
    case solaris:
    case sun:
    case sgi32:
    case sgi64:
      set run = "mpirun -np"
      breaksw
    case bandito:
      set run = "/opt/mpich-intel/bin/mpirun -np"
      breaksw
    case siMPIgcc:
      set run = "/home/u/kddevin/code/siMPI/current/mpirun -np "
      breaksw
    case mpi125:
      set run = "/Net/local/proj/zoltan/arch/solaris-mpi125/mpich-1.2.5/bin/mpirun -np"
      breaksw
    case gcc64:
      set no_nemesis = 1
      set run = "mpirun -np"
      breaksw
    case tflop:
      set run = "yod -proc 3 -sz"
      breaksw
    case cplant:
      set run = "yod -sz"
      breaksw
    case stratus:
    case stratus_siMPI:
      set run = "prun -n"
      breaksw
    case dec:
      set run = "dmpirun -np"
      breaksw
    default:
      echo "Unknown arch type. Please use -cmd to specify the run command."
      exit -2
      breaksw
    endsw
  else # !$?run and !$?arch
    echo "Error: No run command. Either -arch or -cmd must be specified."
    goto usage
  endif
endif
  
# Fortran?
if ( $yes_fortran ) then
   set no_nemesis = 1
   set out_tag = fout
endif

# Old interface?
if ( $old_interface) then
   set no_reftree = 1
endif
  

# Find the right zdrive to run
@ found = 0
if ( $yes_fortran ) then
# Using F90 
  if (! $?zdrive ) then
    set zdrive = zfdrive
  endif
  if ( $?arch ) then
    set zdrives = ( $zdrive ../Obj_${arch}/zfdrive )
  else
    set zdrives = $zdrive
  endif
  foreach zdrive ($zdrives)
    if ( -x $zdrive ) then
      echo "Found zdrive = $zdrive "
      @ found = 1
      break
    endif
  end
else
# Using C
  if (! $?zdrive ) then
    set zdrive = zdrive
  endif
  if ( $?arch ) then
    set zdrives = ( $zdrive ../Obj_${arch}/zdrive )
  else
    set zdrives = $zdrive
  endif
  foreach zdrive ($zdrives)
    if ( -x $zdrive ) then
      echo "Found zdrive = $zdrive "
      @ found = 1
      break
    endif
  end
endif

if (! $found) then
  echo "Error: Could not find zdrive executable"
  exit -3
endif

set ch_methods = ( )
set nem_methods = ( )

# Determine ParMETIS version, if any
if ( $no_parmetis ) then
  @ pmversion = 0
else
  # Scan ParMETIS header file for version info
  set pmfile = `sed -n 's/^.* \([^ ]*parmetis\.h\).*/\1/p' ../Obj_${arch}/parmetis_jostle.d`
  set majorversion = `grep MAJOR_VERSION $pmfile[1]`
  if ( $status ) then
    @ pmversion = 2
  else
    @ pmversion = $majorversion[3]
  endif
endif 

echo "ParMETIS version is $pmversion"

# Check for Jostle
if ( $yes_jostle ) then
  set ch_methods = ( $ch_methods jostle jostle-diffusion )
endif

# Methods to try
if ( $yes_fortran ) then
# Using F90
  if (! $no_rcb) then
    set ch_methods = ( $ch_methods rcb rcb-ts )
    if (! $old_interface) then
      set ch_methods = ( $ch_methods rcb-partless rcb-partless-ts )
      set ch_methods = ( $ch_methods rcb-partmore rcb-partmore-ts )
      set ch_methods = ( $ch_methods rcb-partlocal1 rcb-partlocal1-ts )
      set ch_methods = ( $ch_methods rcb-partlocal2 rcb-partlocal2-ts )
      set ch_methods = ( $ch_methods rcb-partlocal3 rcb-partlocal3-ts )
      set ch_methods = ( $ch_methods rcb-partlocal4 rcb-partlocal4-ts )
      set ch_methods = ( $ch_methods rcb-avg rcb-avg-ts )
      set ch_methods = ( $ch_methods rcb-rect-avg rcb-rect-avg-ts )
      set ch_methods = ( $ch_methods rcb-partlocal1-avg rcb-partlocal1-avg-ts )
    endif
  endif
  if (! $no_rib) then
    set ch_methods = ( $ch_methods rib rib-ts )
    if (! $old_interface) then
      set ch_methods = ( $ch_methods rib-partless rib-partless-ts )
      set ch_methods = ( $ch_methods rib-partmore rib-partmore-ts )
      set ch_methods = ( $ch_methods rib-partlocal1 rib-partlocal1-ts )
      set ch_methods = ( $ch_methods rib-partlocal2 rib-partlocal2-ts )
      set ch_methods = ( $ch_methods rib-partlocal3 rib-partlocal3-ts )
      set ch_methods = ( $ch_methods rib-partlocal4 rib-partlocal4-ts )
      set ch_methods = ( $ch_methods rib-avg rib-avg-ts )
      set ch_methods = ( $ch_methods rib-partlocal1-avg rib-partlocal1-avg-ts )
    endif
  endif
  if (! $no_hsfc) then
    set ch_methods = ( $ch_methods hsfc )
    if (! $old_interface) then
      set ch_methods = ( $ch_methods hsfc-partless hsfc-partmore )
      set ch_methods = ( $ch_methods hsfc-partlocal1 hsfc-partlocal2 )
      set ch_methods = ( $ch_methods hsfc-partlocal3 hsfc-partlocal4 )
    endif
  endif
  if (! $no_oct) then
    set ch_methods = ( $ch_methods oct0 oct1 oct2 )
    set ch_methods = ( $ch_methods oct0-partlocal3 oct1-partlocal3 oct2-partlocal3 )
  endif
  if (! $no_parmetis) then
    if ( $pmversion == 2) then
      set ch_methods = ( $ch_methods partkway partgeom diffusion )
    else # $pmversion > 2 
      set ch_methods = ( $ch_methods partkway-v$pmversion \
        partgeom-v$pmversion diffusion-v$pmversion \
        partgeomkway-v$pmversion adaptive-v$pmversion )
      if (! $old_interface) then
        set ch_methods = ( $ch_methods \
          partkway-partless-v$pmversion partkway-partmore-v$pmversion \
          partkway-partlocal1-v$pmversion partkway-partlocal2-v$pmversion \
          partkway-partlocal3-v$pmversion partkway-partlocal4-v$pmversion \
          adaptive-partless-v$pmversion adaptive-partmore-v$pmversion \
          adaptive-partlocal1-v$pmversion adaptive-partlocal2-v$pmversion \
          adaptive-partlocal3-v$pmversion adaptive-partlocal4-v$pmversion \
          adaptive-partlocal5-v$pmversion )
        if (! $no_order) then
          set ch_methods = ( $ch_methods order-metis-v$pmversion  \
            order-parmetis-v$pmversion partkway-order-metis-v$pmversion )
        endif
      endif
    endif
  endif
else
# Using C

  # These Chaco problems are run only for C driver; F90 driver does not
  # read assignment input files or multiple weights.
  if ( $yes_serial ) then
    set ch_name = ($ch_name vwgt2 hammond2)
    set ch_nproc = ($ch_nproc 1 1) # no. of procs
  else
    set ch_name = ($ch_name drake vwgt2 hammond2 brack2_3)
    set ch_nproc = ($ch_nproc 3 2 6 5) # no. of procs
  endif

  if (! $no_rcb) then
    set ch_methods = ( $ch_methods rcb rcb-oneproc rcb-ts )
    if (! $old_interface) then
      set ch_methods = ( $ch_methods rcb-reuse rcb-reuse-ts )
      set ch_methods = ( $ch_methods rcb-rect rcb-rect-ts )
      set ch_methods = ( $ch_methods rcb-lock rcb-lock-ts )
      set ch_methods = ( $ch_methods rcb-set1 rcb-set2 )
      set ch_methods = ( $ch_methods rcb-set3 rcb-set4 )
      set ch_methods = ( $ch_methods rcb-set5 rcb-set6 )
      set ch_methods = ( $ch_methods rcb-partless rcb-partless-ts )
      set ch_methods = ( $ch_methods rcb-partmore rcb-partmore-ts )
      set ch_methods = ( $ch_methods rcb-partlocal1 rcb-partlocal1-ts )
      set ch_methods = ( $ch_methods rcb-partlocal2 rcb-partlocal2-ts )
      set ch_methods = ( $ch_methods rcb-partlocal3 rcb-partlocal3-ts )
      set ch_methods = ( $ch_methods rcb-partlocal4 rcb-partlocal4-ts )
      set ch_methods = ( $ch_methods rcb-avg rcb-avg-ts )
      set ch_methods = ( $ch_methods rcb-rect-avg rcb-rect-avg-ts )
      set ch_methods = ( $ch_methods rcb-partlocal1-avg rcb-partlocal1-avg-ts )
      set ch_methods = ( $ch_methods rcb-comparable rcb-norm2 rcb-norm3)
    endif
    set nem_methods = ( $nem_methods rcb rcb-ts )
    if (! $old_interface) then
      set nem_methods = ( $nem_methods rcb-reuse rcb-reuse-ts )
      set nem_methods = ( $nem_methods rcb-rect rcb-rect-ts )
      set nem_methods = ( $nem_methods rcb-lock rcb-lock-ts )
      set nem_methods = ( $nem_methods rcb-set1 rcb-set2 )
      set nem_methods = ( $nem_methods rcb-set3 rcb-set4 )
      set nem_methods = ( $nem_methods rcb-set5 rcb-set6 )
      set nem_methods = ( $nem_methods rcb-partless rcb-partless-ts )
      set nem_methods = ( $nem_methods rcb-partmore rcb-partmore-ts )
      set nem_methods = ( $nem_methods rcb-partlocal1 rcb-partlocal1-ts )
      set nem_methods = ( $nem_methods rcb-partlocal2 rcb-partlocal2-ts )
      set nem_methods = ( $nem_methods rcb-partlocal3 rcb-partlocal3-ts )
      set nem_methods = ( $nem_methods rcb-partlocal4 rcb-partlocal4-ts )
      set nem_methods = ( $nem_methods rcb2 rcb2-ts )
      set nem_methods = ( $nem_methods rcb2-comparable rcb2-comparable-ts )
      set nem_methods = ( $nem_methods rcb2-norm2 rcb2-norm2-ts )
      set nem_methods = ( $nem_methods rcb2-norm3 rcb2-norm3-ts )
      set nem_methods = ( $nem_methods rcb2-partless rcb2-partless-ts )
      set nem_methods = ( $nem_methods rcb2-partlocal1 rcb2-partlocal1-ts )
      set nem_methods = ( $nem_methods rcb2-partlocal2 rcb2-partlocal2-ts )
      set nem_methods = ( $nem_methods rcb2-partlocal3 rcb2-partlocal3-ts )
      set nem_methods = ( $nem_methods rcb2-partlocal4 rcb2-partlocal4-ts )
      set nem_methods = ( $nem_methods rcb2-partmore rcb2-partmore-ts )
      set nem_methods = ( $nem_methods rcb2-set1 rcb2-set1-ts )
      set nem_methods = ( $nem_methods rcb-avg rcb-avg-ts )
      set nem_methods = ( $nem_methods rcb-rect-avg rcb-rect-avg-ts )
      set nem_methods = ( $nem_methods rcb-partlocal1-avg rcb-partlocal1-avg-ts )
    endif
  endif
  if (! $no_rib) then
    set ch_methods = ( $ch_methods rib rib-oneproc rib-ts )
    if (! $old_interface) then
      set ch_methods = ( $ch_methods rib-partless rib-partless-ts )
      set ch_methods = ( $ch_methods rib-partmore rib-partmore-ts )
      set ch_methods = ( $ch_methods rib-partlocal1 rib-partlocal1-ts )
      set ch_methods = ( $ch_methods rib-partlocal2 rib-partlocal2-ts )
      set ch_methods = ( $ch_methods rib-partlocal3 rib-partlocal3-ts )
      set ch_methods = ( $ch_methods rib-partlocal4 rib-partlocal4-ts )
      set ch_methods = ( $ch_methods rib-avg rib-avg-ts )
      set ch_methods = ( $ch_methods rib-partlocal1-avg rib-partlocal1-avg-ts )
    endif
    set nem_methods = ( $nem_methods rib rib-ts )
    if (! $old_interface) then
      set nem_methods = ( $nem_methods rib-partless rib-partless-ts )
      set nem_methods = ( $nem_methods rib-partmore rib-partmore-ts )
      set nem_methods = ( $nem_methods rib-partlocal1 rib-partlocal1-ts )
      set nem_methods = ( $nem_methods rib-partlocal2 rib-partlocal2-ts )
      set nem_methods = ( $nem_methods rib-partlocal3 rib-partlocal3-ts )
      set nem_methods = ( $nem_methods rib-partlocal4 rib-partlocal4-ts )
      set nem_methods = ( $nem_methods rib-avg rib-avg-ts )
      set nem_methods = ( $nem_methods rib-partlocal1-avg rib-partlocal1-avg-ts )
    endif
  endif
  if (! $no_hsfc) then
    set ch_methods = ( $ch_methods hsfc hsfc-oneproc )
    if (! $old_interface) then
      set ch_methods = ( $ch_methods hsfc-partless hsfc-partmore )
      set ch_methods = ( $ch_methods hsfc-partlocal1 hsfc-partlocal2 )
      set ch_methods = ( $ch_methods hsfc-partlocal3 hsfc-partlocal4 )
      set ch_methods = ( $ch_methods hsfc-partlocal6 hsfc-partlocal7 )
    endif
    set nem_methods = ( $nem_methods hsfc )
    if (! $old_interface) then
      set nem_methods = ( $nem_methods hsfc-partless hsfc-partmore )
      set nem_methods = ( $nem_methods hsfc-partlocal1 hsfc-partlocal2 )
      set nem_methods = ( $nem_methods hsfc-partlocal3 hsfc-partlocal4 )
      set nem_methods = ( $nem_methods hsfc-partlocal6 hsfc-partlocal7 )    
    endif
  endif
  if (! $no_oct) then
    set ch_methods = ( $ch_methods oct0 oct1 oct2 )
    set ch_methods = ( $ch_methods oct0-partlocal3 oct1-partlocal3 oct2-partlocal3 )
    set ch_methods = ( $ch_methods oct0-partlocal6 oct1-partlocal6 oct2-partlocal6 )
    set ch_methods = ( $ch_methods oct0-partlocal7 oct1-partlocal7 oct2-partlocal7 )
    set nem_methods = ( $nem_methods oct0 oct1 oct2 )
    set nem_methods = ( $nem_methods oct0-partlocal3 oct1-partlocal3 oct2-partlocal3 )
  endif
  if (! $no_reftree) then
    set nem_methods = ( $nem_methods reftree reftree-connected)
  endif
  if (! $no_parmetis) then
    if ( $pmversion == 2) then
      set ch_methods = ( $ch_methods partkway partkway-oneproc partkway-cyclic partgeom diffusion )
      set nem_methods = ( $nem_methods partkway partgeom diffusion )
    else # $pmversion > 2
      set ch_methods = ( $ch_methods partkway-v$pmversion \
        partkway-oneproc-v$pmversion partkway-cyclic-v$pmversion \
        partgeom-v$pmversion diffusion-v$pmversion \
        partgeomkway-v$pmversion adaptive-v$pmversion )
      set nem_methods = ( $nem_methods partkway-v$pmversion \
        partgeomkway-v$pmversion adaptive-v$pmversion )
      if (! $old_interface) then
        set ch_methods = ( $ch_methods \
          partkway-partless-v$pmversion partkway-partmore-v$pmversion \
          partkway-partlocal1-v$pmversion partkway-partlocal2-v$pmversion \
          partkway-partlocal3-v$pmversion partkway-partlocal4-v$pmversion \
          adaptive-partless-v$pmversion adaptive-partmore-v$pmversion \
          adaptive-partlocal1-v$pmversion adaptive-partlocal2-v$pmversion \
          adaptive-partlocal3-v$pmversion adaptive-partlocal4-v$pmversion \
          adaptive-partlocal5-v$pmversion )
        set nem_methods = ( $nem_methods \
          partkway-partless-v$pmversion partkway-partmore-v$pmversion \
          partkway-partlocal1-v$pmversion partkway-partlocal2-v$pmversion \
          partkway-partlocal3-v$pmversion partkway-partlocal4-v$pmversion \
          adaptive-partless-v$pmversion adaptive-partmore-v$pmversion \
          adaptive-partlocal1-v$pmversion adaptive-partlocal2-v$pmversion \
          adaptive-partlocal3-v$pmversion adaptive-partlocal4-v$pmversion )
        if (! $no_order) then
          set ch_methods = ( $ch_methods order-metis-v$pmversion  \
            order-parmetis-v$pmversion partkway-order-metis-v$pmversion )
        endif
      endif
    endif
  endif
endif

# Set up log file
if ( -e $logfile ) /bin/mv $logfile ${logfile}.old
echo "Test date  = `date`" > $logfile
echo "System     = `uname -a`" >> $logfile
echo "Arch       = ${arch}" >> $logfile
echo "Fortran    = $yes_fortran" >> $logfile
echo "Run cmd    = $run" >> $logfile
echo "Run dir    = $cwd" >> $logfile
echo "Executable = $zdrive" >> $logfile
echo "Old Interf = $old_interface" >> $logfile
echo " " >> $logfile


# Loop over Chaco problems
if (! $no_chaco ) then
  @ nprob = $#ch_name
  @ nfailed = 0
  @ ndropfailed = 0
  while ( $#ch_name )

    # Go to the next test directory, initialize
    cd ch_${ch_name[1]}
    @ np = $ch_nproc[1]
    echo "Running test case ${ch_name[1]} on ${ch_nproc[1]} procs" | tee -a ../$logfile

    # Check output directories 
    if (! -d $outdir ) mkdir $outdir
    if (! -d $answers ) then
      echo "Warning: Answer directory missing in ch_${ch_name[1]}" | tee -a ../$logfile
    endif

    # Save generic input file 
    if (-e zdrive.inp ) /bin/mv zdrive.inp zdrive.inp.bak

    # Add special test cases for some multiweight problems
    if ((${ch_name[1]} == "vwgt2") || (${ch_name[1]} == "hammond2")) then
       if ($pmversion > 2) then
          set methods = ( partkway-imbal-v$pmversion )
       else
          set methods = ( )
       endif
       set methods = ( $ch_methods $methods )
    else
       set methods = ( $ch_methods )
    endif

    # Special case for purecov runs:  don't include brack2_3; it takes too long.
    if ((${ch_name[1]} == "brack2_3") && ($arch == "purecov")) then
       set methods = ( )
    endif

    # Loop over all methods
    foreach mtd ( $methods )
      # Clear fail flag
      @ fail = 0
      @ dropfail = 0
      @ droptest = 0
      @ skip = 0  # Was used to skip certain methods in previous versions.

      if (! $skip ) then

        # Check input file
        if (-e zdrive.inp.${mtd} ) then
          /bin/cp zdrive.inp.${mtd} zdrive.inp
          if (-e ${outdir}/${ch_name[1]}.$mtd.$np.0 ) then
            /bin/rm ${outdir}/${ch_name[1]}.$mtd.$np.*
          endif

          #  Delete old drop files, if any.
          if (-e ${outdir}/${ch_name[1]}.$mtd.drops.$np.0 ) then
            /bin/rm ${outdir}/${ch_name[1]}.$mtd.drops.$np.*
          endif
          if (-e ${ch_name[1]}.drops.$np.0 ) then
            /bin/rm ${ch_name[1]}.drops.$np.*
          endif

          # Run the driver
          $run $np ../$zdrive
          sleep 1 # Make sure all processes have time to write to disk
    
          # Save and compare output files 
          @ i = 0
          while ( $i < $np )
            /bin/mv ${ch_name[1]}.$out_tag.$np.$i  ${outdir}/${ch_name[1]}.$mtd.$np.$i
            if (-e ${answers}/${ch_name[1]}.$mtd.$np.$i.$arch ) then
       	      set answerfile = ${answers}/${ch_name[1]}.$mtd.$np.$i.$arch
            else
              set answerfile = ${answers}/${ch_name[1]}.$mtd.$np.$i
            endif
            diff -ciw ${outdir}/${ch_name[1]}.$mtd.$np.$i $answerfile >> ../$logfile
            if ( $status ) then 
              @ fail = 1
            endif

            # If drop files were created, test them. 
            if (-e ${ch_name[1]}.drops.$np.$i ) then
              @ droptest = 1
              /bin/mv ${ch_name[1]}.drops.$np.$i  ${outdir}/${ch_name[1]}.$mtd.drops.$np.$i
              if (-e ${answers}/${ch_name[1]}.$mtd.drops.$np.$i.$arch ) then
       	        set answerfile = ${answers}/${ch_name[1]}.$mtd.drops.$np.$i.$arch
              else
                set answerfile = ${answers}/${ch_name[1]}.$mtd.drops.$np.$i
              endif
              diff -ciw ${outdir}/${ch_name[1]}.$mtd.drops.$np.$i $answerfile >> ../$logfile
              if ( $status ) then 
                @ dropfail = 1
              endif
            endif

            @ i = $i + 1
          end
    
        else
          echo "Warning: No input file ${ch_name[1]}/zdrive.inp.${mtd}, skipping..." | tee -a ../$logfile
        endif
  
  
        # Report success or failure 
        if ( $fail ) then
          @ nfailed = $nfailed + 1
          echo "Test problem ${ch_name[1]} with method ${mtd} FAILED" | tee -a ../$logfile
        else
          echo "Test problem ${ch_name[1]} with method ${mtd} OK" | tee -a ../$logfile 
        endif

        # Report failure of drop tests, if any.
        if ( $droptest ) then
          if ( $dropfail ) then
            @ ndropfailed = $ndropfailed + 1
            echo "Test problem ${ch_name[1]} with method ${mtd} drop tests FAILED" | tee -a ../$logfile
          else
            echo "Test problem ${ch_name[1]} with method ${mtd} drop tests OK" | tee -a ../$logfile
          endif
        endif

      endif # !skip

    end # foreach method

    # Restore zdrive.inp
    if (-e zdrive.inp.bak ) /bin/mv zdrive.inp.bak zdrive.inp

    # Shift arguments and return to original directory
    shift ch_name
    shift ch_nproc
    cd ..
  end
  
  # Print failure summary
  echo " " | tee -a $logfile
  if ( $nfailed == 0 ) then
    echo "Success: all Chaco problems passed." | tee -a $logfile
  else
    echo "Failure: $nfailed Chaco problems failed." | tee -a $logfile
  endif
  echo " " | tee -a $logfile
  if ( $ndropfailed == 0 ) then
    echo "Success: all Chaco drop tests passed." | tee -a $logfile
  else
    echo "Failure: $ndropfailed Chaco drop tests failed." | tee -a $logfile
  endif
  echo " " | tee -a $logfile

endif # chaco

# Loop over Nemesis problems
if (! $no_nemesis ) then
  @ nprob = $#nem_name
  @ nfailed = 0
  @ ndropfailed = 0
  while ( $#nem_name )

    # Go to the next test directory, initialize
    cd nem_${nem_name[1]}
    @ np = $nem_nproc[1]
    echo "Running test case ${nem_name[1]} on ${nem_nproc[1]} procs" | tee -a ../$logfile

    # Check output directories 
    if (! -d $outdir ) mkdir $outdir
    if (! -d $answers ) then
      echo "Warning: Answer directory missing in nem_${nem_name[1]}" | tee -a ../$logfile
    endif

    # Save input file 
    if (-e zdrive.inp ) /bin/mv zdrive.inp zdrive.inp.bak

    # Loop over all methods
    foreach mtd ( $nem_methods )
      # Clear fail flag
      @ fail = 0
      @ dropfail = 0
      @ droptest = 0
      @ skip = 0

      if (! $skip ) then

        # Check input file
        if (-e zdrive.inp.${mtd} ) then
          /bin/cp zdrive.inp.${mtd} zdrive.inp
          /bin/rm ${outdir}/${nem_name[1]}.$mtd.$np.*
          /bin/rm ${outdir}/${nem_name[1]}.$mtd.drops.$np.*
    
          # Run the driver
          $run $np ../$zdrive
    
          # Save and compare output files 
          @ i = 0
          @ pdirno = 1 # parallel subdirectory number
          while ( $i < $np )
            if ( $pdirno < 10 ) then
               set pdir = pio_0${pdirno}
            else
               set pdir = pio_${pdirno}
            endif
            /bin/mv ${pdir}/${nem_name[1]}-m${np}-r.par.out.$np.$i  ${outdir}/${nem_name[1]}.$mtd.$np.$i
            if (-e ${answers}/${nem_name[1]}.$mtd.$np.$i.$arch ) then
       	      set answerfile = ${answers}/${nem_name[1]}.$mtd.$np.$i.$arch
            else
              set answerfile = ${answers}/${nem_name[1]}.$mtd.$np.$i
            endif
            diff -ciw ${outdir}/${nem_name[1]}.$mtd.$np.$i $answerfile >> ../$logfile
            if ( $status ) then 
              @ fail = 1
            endif

            if (-e ${pdir}/${nem_name[1]}-m${np}-r.par.drops.$np.$i ) then
              @ droptest = 1
              /bin/mv ${pdir}/${nem_name[1]}-m${np}-r.par.drops.$np.$i  ${outdir}/${nem_name[1]}.$mtd.drops.$np.$i
              if (-e ${answers}/${nem_name[1]}.$mtd.drops.$np.$i.$arch ) then
      	        set answerfile = ${answers}/${nem_name[1]}.$mtd.drops.$np.$i.$arch
              else
                set answerfile = ${answers}/${nem_name[1]}.$mtd.drops.$np.$i
              endif
              diff -ciw ${outdir}/${nem_name[1]}.$mtd.drops.$np.$i $answerfile >> ../$logfile
              if ( $status ) then 
                @ dropfail = 1
              endif
            endif

            @ i = $i + 1
            @ pdirno = $pdirno + 1
            if ($pdirno > $nem_pdisk[1]) then
               @ pdirno = 1
            endif
          end
    
        else
          echo "Warning: No input file ${nem_name[1]}/zdrive.inp.${mtd}, skipping..." | tee -a ../$logfile
        endif
  
        # Report success or failure 
        if ( $fail ) then
          @ nfailed = $nfailed + 1
          echo "Test problem ${nem_name[1]} with method ${mtd} FAILED" | tee -a ../$logfile
        else
          echo "Test problem ${nem_name[1]} with method ${mtd} OK" | tee -a ../$logfile 
        endif

        if ( $droptest ) then
          if ( $dropfail ) then
            @ ndropfailed = $ndropfailed + 1
            echo "Test problem ${nem_name[1]} with method ${mtd} drop tests FAILED" | tee -a ../$logfile
          else
            echo "Test problem ${nem_name[1]} with method ${mtd} drop tests OK" | tee -a ../$logfile 
          endif
        endif
      endif # !skip

    end # foreach method

    # Restore zdrive.inp
    if (-e zdrive.inp.bak ) /bin/mv zdrive.inp.bak zdrive.inp

    # Shift list arguments and return to original directory
    shift nem_name
    shift nem_nproc
    shift nem_pdisk
    cd ..
  end
  
  # Print failure summary
  echo " " | tee -a $logfile
  if ( $nfailed == 0 ) then
    echo "Success: all Nemesis problems passed." | tee -a $logfile
  else
    echo "Failure: $nfailed Nemesis problems failed." | tee -a $logfile
  endif
  echo " " | tee -a $logfile
  if ( $ndropfailed == 0 ) then
    echo "Success: all Nemesis drop tests passed." | tee -a $logfile
  else
    echo "Failure: $ndropfailed Nemesis drop tests failed." | tee -a $logfile
  endif
  echo " " | tee -a $logfile

endif # Nemesis

# Loop over hg problems
if (! $no_hg) then
  @ nprob = $#hg_name

  cd hg_test
  if (-e ./zdrive) /bin/rm ./zdrive
  /bin/cp ../$zdrive .

  # Check output directories 
  if (! -d $outdir ) mkdir $outdir
  if (! -d $answers ) mkdir $answers
 
  # Save input file 
  if (-e zdrive.inp ) /bin/cp zdrive.inp zdrive.inp.bak
  
  foreach name ( $hg_name )

    echo "Running test case ${name}" | tee -a ../$logfile

    # Loop over all methods
    foreach mtd ( $hg_methods )

        # Check input file
        if (-e zdrive.inp.${name} ) then
            /bin/rm  zdrive.inp
            /bin/cp  zdrive.inp.${name} zdrive.inp

            # add some parameters not already in the input file
            /bin/echo "Zoltan Parameters = hg_reduction_method=$mtd" \
                >> zdrive.inp
            /bin/echo "Zoltan Parameters = hg_reduction_local_improvement=no" \
                >> zdrive.inp
            /bin/echo "Zoltan Parameters = hg_local_refinement=no" \
                >> zdrive.inp
            /bin/echo "Zoltan Parameters = hg_reduction_limit=5000" \
                >> zdrive.inp
            #/bin/echo "Zoltan Parameters = hg_global partitioning=ran" \
            #    >> zdrive.inp
            /bin/echo "number of iterations = 10" >> zdrive.inp
            # Run the driver
            ./zdrive > $outdir/${name}.$mtd

        else
            echo "Warning: Can't find hg_test/zdrive.inp.${name}, skipping..." \
                | tee -a ../$logfile
        endif

    end # foreach method

    # Restore zdrive.inp
    if (-e zdrive.inp.bak ) /bin/mv zdrive.inp.bak zdrive.inp
  end # foreach name
  cd ..  
endif # Hypergraph


###

# Exit successfully
echo "Test final = `date`" >> $logfile
exit 0

# Print usage and exit with error
usage:
  echo "Usage: $0 [-arch arch-type] [-cmd command]"
  echo "where arch-type is one of {generic, gcc, gcc64, sun, solaris, tflop, cplant, dec, linux, sgi32, sgi64}."
  echo "(If you have set ZOLTAN_ARCH you do not need to use -arch.)"
  echo "Alternatively, specify the command to load and run a parallel "
  echo "program with the -cmd option."
  echo "Other options:"
  echo "   -logfile filename"
  echo "   -exe filename"
  echo "   -no_rcb"
  echo "   -no_rib"
  echo "   -no_hsfc"
  echo "   -no_oct"
  echo "   -no_parmetis"
  echo "   -no_reftree"
  echo "   -no_order"
  echo "   -no_nemesis"
  echo "   -no_chaco"
  echo "   -no_hg"
  echo "   -yes_fortran"
  echo "   -yes_jostle"
  echo "   -old_interface"
  echo "The default is to run all methods (except Jostle) and file formats."
  exit -1

