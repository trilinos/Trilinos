
/** \defgroup Thyra_Op_Vec_use_cases_grp Use Cases for the Foundational Thyra Operator/Vector Interfaces

\brief Here we outline three common use cases related to the \ref
Thyra_Op_Vec_foundational_interfaces_sec.

Click on the links below for a discussion of each of these three use
cases and a description of additional supporting C++ classes and
non-member functions.

<ol>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_Adapters_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ol>

*/

/** \defgroup Thyra_Op_Vec_ANA_Interoperability_grp Thyra Operator/Vector Interfaces as an Interoperability Layer for Abstract Numerical Algorithms (ANAs)

\ingroup Thyra_Op_Vec_use_cases_grp

\brief As stated in the \ref index "introduction", the primary purpose
of %Thyra is to define a set of basic and minimal abstract
interfaces to support the interoperability of abstract numerical
algorithms (ANAs).

ToDo: Put in links to fundamental and extended operator-vector interfaces.

\section Thyra_Op_Vec_ANA_Interoperability_other_sec Other Use Cases

<ul>

<li> \ref Thyra_Op_Vec_Adapters_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_Adapters_grp Development of Concrete Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_use_cases_grp

\brief In order for abstract numerical algorithms (ANAs)
\ref Thyra_Op_Vec_ANA_Development_grp "developed with Thyra" or
\ref Thyra_Op_Vec_ANA_Interoperability_grp "accessed using Thyra" to be useful,
concrete implementations of the
\ref Thyra_Op_Vec_foundational_interfaces_sec must be provided.
However, because of a number of convenient C++ subclasses described
here, a developer of such implementation subclasses does not really need to understand much at all
about the philosophy or details behind the fundamental %Thyra
interfaces in order to provide implementations for the most common use
cases.

One of the main motivations behind the design of the \ref
Thyra_Op_Vec_foundational_interfaces_sec is the uniform support for many
different computing environments such as serial shared-memory (i.e. SMP) and a
variety of distributed-memory models (e.g. SPMD (single program, multiple
data), client-server, master-slave and client-server/master-slave).  While
this is the case, the overwhelming majority of concrete implementations of
these types will be in more typical SMP serial shared-memory or SPMD
distributed-memory environments.  Because of this, the Trilinos package %Thyra
contains a set of base subclasses that makes the development of concrete
vector space, vector, multi-vector and linear operator subclasses as easy as
possible.  However, the \ref Thyra_Op_Vec_foundational_interfaces_sec allow
for almost limitless possibilities with respect to the types of
implementations so it is not reasonable to provide pre-packaged support for
all of the possibilities.

<b>Heads Up!</b> In case you think you will have to develop your own concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> or
<tt>Thyra::MultiVectorBase</tt> subclasses in addition to whatever
<tt>Thyra::LinearOpBase</tt> subclasses that you need for you application, you
are probably wrong!  You most likely will not need to create any concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> or
<tt>Thyra::MultiVectorBase</tt> subclasses and instead should only need to
develop concrete <tt>Thyra::LinearOpBase</tt> subclass(es) by deriving from
<tt>Thyra::SerialLinearOpBase</tt> for serial platforms or
<tt>Thyra::MPILinearOpBase</tt> for MPI SPMD platforms.  As described below,
general yet efficient implementations of concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> and
<tt>Thyra::MultiVectorBase</tt> subclasses for serial and MPI SPMD platforms
are already available.

Next, we provide a description of the various types of support code
for creating concrete implementations as well as concrete
implementations that are available.  Just browse the categories that
you are interested in.

\section Thyra_Op_Vec_Adapters_overview_sec Overview of Concrete Thyra Subclass Implementations

<ol>

<li><b>Basic default implementation node subclasses</b>

The following subclasses directly derive from \ref
Thyra_Op_Vec_foundational_interfaces_sec and provide general default
implementations for as many virtual functions as reasonable:

<ul>

<li><tt>Thyra::VectorSpaceDefaultBase</tt> should be a direct or indirect base
class of almost every <tt>Thyra::VectorSpaceBase</tt> subclass.  This node
subclass provides the default implementation
<tt>Thyra::VectorSpaceDefaultBase::createMembers()</tt> using
<tt>Thyra::DefaultColumnwiseMultiVector</tt>.  Therefore, a subclass need only provide a
<tt>VectorBase</tt> implementation and override
<tt>Thyra::VectorSpaceBase::createMember()</tt> and related functions.

<li><tt>Thyra::MultiVectorDefaultBase</tt> should be a direct or indirect base
class of almost every <tt>Thyra::MultiVectorBase</tt> subclass.  This node
subclass provides a default of every inherited virtual function from the base
class <tt>Thyra::MultiVectorBase</tt> in terms of just
<tt>Thyra::MultiVectorBase::col()</tt>.  While many of these default function
implementations are highly non-optimal, the none the less allow for rapid
prototyping of new <tt>Thyra::MultiVectorBase</tt> subclasses.

<li><tt>Thyra::VectorDefaultBase</tt> should be a direct or indirect base
class of almost every <tt>Thyra::VectorBase</tt> subclass.  This node subclass
provides full general and efficient implementations of all of the inherited
virtual functions from the base class <tt>Thyra::MultiVectorBase</tt>.

</ul>

<li><b>\ref Thyra_Op_Vec_basic_adapter_support_grp</b>

Click \ref Thyra_Op_Vec_basic_adapter_support_grp "here" if you want to know
about high-level support subclasses for separating out the definition of the
scalar product from the data structures and factory methods for specific
computing platforms.  All of the concrete %Thyra implementation subclasses
outlined below derive from and use these base interfaces.  However, knowing
the details of these base interfaces is not critical for developing concrete
implementations in most situations unless application-defined scalar products
are needed.  The Euclidean scalar product is used automatically by default and
if that is all you need then you can ignore these base classes.

<li><b>Support subclasses for specific types of computing platforms</b>

Below we outline support code contained in the %Thyra package for
different categories of computing platforms.

<b>Note!</b> Before attempting to create your own concrete subclasses
of the \ref Thyra_Op_Vec_foundational_interfaces_sec please browse the 
links below so that you know what support is already available.  In many
cases, most of the concrete implementation software that you need for
%Thyra is already provided.

<ol>

<li><b>\ref Thyra_Op_Vec_serial_adapters_grp</b>

Click \ref Thyra_Op_Vec_serial_adapters_grp "here" if you want to know about
support for developing %Thyra subclass implementations for serial
shared-memory platforms.  Since these are the most commonly used computing
platforms by applied mathematicians and academic researchers, these subclasses
should be the most commonly used by this group.  Note that the above link also
describes very general and efficient concrete serial subclasses for vector
spaces, vectors and multi-vectors as well as a support class for creating
concrete linear operator implementations.

<li><b>\ref Thyra_Op_Vec_mpi_adapters_grp</b>

Click \ref Thyra_Op_Vec_mpi_adapters_grp "here" if you want to know about
support for developing %Thyra subclass implementations for SPMD
distributed-memory platforms.  These platforms are most commonly used in
large-scale scientific computing.  Note that the above link also describes
very general and efficient concrete MPI SPMD subclasses for vector spaces,
vectors, and multi-vectors as well as a support class for creating concrete
SPMD linear operator implementations.

</ol>

</ol>

\section Thyra_Op_Vec_Adapters_other_sec Other Use Cases

<ul>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_general_adapter_support_code_grp Miscellaneous Support Code for Developing Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_Adapters_grp

\brief This is some basic C++ code to support the development of Thyra subclass implementations.

*/


/** \defgroup Thyra_Op_Vec_general_adapter_support_code_utils_grp Internal Helper Code not meant for General Use

\brief Some support code that is not meant for general programmers to access.

\ingroup Thyra_Op_Vec_general_adapter_support_code_grp

*/

/** \defgroup Thyra_Op_Vec_basic_adapter_support_grp Basic Support Subclasses Abstracting Application-Specific Scalar Products

\ingroup Thyra_Op_Vec_Adapters_grp

\brief The \ref Thyra_Op_Vec_foundational_interfaces_sec define an interface
for providing ANAs with the functionality they need concerning
application-specific scalar products without concern for how such scalar
products are implemented or how such scalar products relate to the
implementation of vectors, multi-vectors or linear operators.  While this is
most straightforward for clients of these interfaces, it is not the most
convenient for subclass implementation developers.  The first level of basic
subclasses for supporting the development of concrete %Thyra operator/vector
implementations involves separating out the definition of the scalar product
from the basic vector and multi-vector data structures and the factory methods
for creating them.  The base subclasses for supporting application-defined
scalar products are shown in the UML class diagram below.

\image html ScalarProdVectorSpaceBase.gif "Support base subclasses for abstracting application-specific scalar products (Note: above graphic is not hyperlinked!)"

The classes shown in the above UML class diagram are described below:

<ul>

<li><tt>Thyra::ScalarProdBase</tt> defines an interface for an
application-specific scalar product independent from a vector space.

<li><tt>Thyra::ScalarProdVectorSpaceBase</tt> is subclass of
<tt>%Thyra::%VectorSpaceBase</tt> that defines the scalar product functions in
terms of an aggregate <tt>%Thyra::%ScalarProdBase</tt> object that can be
swapped in and out (see the C++ code for the
<tt>Thyra::ScalarProdVectorSpaceBase::scalarProd()</tt> function as an
example).

<li><tt>Thyra::EuclideanScalarProd</tt> is a standard implementation subclass
of <tt>%Thyra::%ScalarProdBase</tt> for Euclidean scalar products (i.e. using
the dot product).  This is the default scalar product definition used by
<tt>%Thyra::%ScalarProdVectorSpaceBase</tt> and all of its subclass objects.

<li><tt>Thyra::LinearOpScalarProd</tt> is a more general implementation of a
scalar product that uses an arbitrary symmetric positive-definite
<tt>%Thyra::%LinearOpBase</tt> object (shown using the <tt>op</tt>
relationship in the above UML class diagram).

<li><tt>Thyra::EuclideanLinearOpBase</tt> is a base subclass that allows the
development of general concrete implementations of
<tt>%Thyra::%LinearOpBase</tt> that are independent of an application-specific
scalar product.  This base subclass defines the functions
<tt>Thyra::EuclideanLinearOpBase::euclideanApply()</tt> and
<tt>Thyra::EuclideanLinearOpBase::euclideanApplyTranspose()</tt> which are
called by <tt>Thyra::ScalarProdBase::apply()</tt> to modify the application of
an Euclidean linear operator for the definition of the scalar product (see the
C++ code for the overridden <tt>Thyra::EuclideanLinearOpBase::apply()</tt> and
<tt>Thyra::EuclideanLinearOpBase::applyTranspose()</tt> functions).  This base
class is most helpful for the definition of concrete
<tt>Thyra::MultiVectorBase</tt> subclasses.  More specialized linear operators
that already define the operator with respect to application-specific scalar
product should not derive from this subclass but should instead derive
directly from <tt>%Thyra:%LinearOpBase</tt>.

</ul>

The base subclasses <tt>Thyra::ScalarProdVectorSpaceBase</tt> and
<tt>Thyra::EuclideanLinearOpBase</tt> are used for almost all of the other
adapter support subclasses and concrete implementations in the %Thyra package.

*/

/** \defgroup Thyra_Op_Vec_serial_adapters_grp Thyra Operator/Vector Subclasses for Serial Shared-Memory Platforms

\ingroup Thyra_Op_Vec_Adapters_grp

\brief The package %Thyra includes subclasses for common serial
shared-memory vector spaces, vectors and multi-vectors which are
described here.

Given the subclasses described below, there should be no need to create new
concrete serial shared-memory vector spaces, vectors or multi-vectors when
interfacing to most other well designed software.

\section Thyra_Op_Vec_serial_adapters_classes_sec Subclasses for Serial Implementations

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_serial_support_grp</b>

Click \ref Thyra_Op_Vec_adapters_serial_support_grp "here" if you want to know
about the basic support node subclasses for a common type of serial vector and
multi-vector implementation that all of the concrete implementations described
below derive from.

<li> <b>Concrete Serial Subclasses</b>

Below are some concrete implementations of %Thyra classes that are
derived from the
\ref Thyra_Op_Vec_adapters_serial_support_grp "basic serial base subclasses"
mentioned above.

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_serial_concrete_std_grp</b>

Click \ref Thyra_Op_Vec_adapters_serial_concrete_std_grp "here" if you want to
know about some general, yet very efficient, concrete implementations of
serial vector spaces, vectors and multi-vectors.

</ol>

</ol>

\section Thyra_Op_Vec_serial_adapters_examples_sec Example Subclasses for Serial Shared-Memory Platforms

The only example that one should need for how to provide a serial
implementation for the \ref Thyra_Op_Vec_foundational_interfaces_sec is
provided below:

<ul>

<li><tt>SerialTridiagLinearOp</tt> is a simple templated
concrete linear operator subclass for tridiagonal matrices that
derives from <tt>Thyra::SerialLinearOpBase</tt>.

</ul>

To create a new specialized serial <tt>Thyra::LinearOpBase</tt> subclass
one should just have to copy the source code for the above example
<tt>SerialTridiagLinearOp</tt> subclass into a new file(s), change the
name and then modify the new subclass as needed.

*/

/** \defgroup Thyra_Op_Vec_serial_adapters_support_code_grp Support code for Thyra Operator/Vector Subclasses for Serial Shared-Memory Platforms

\ingroup Thyra_Op_Vec_serial_adapters_grp

*/

/** \defgroup Thyra_Op_Vec_adapters_serial_support_grp Thyra Operator/Vector Base Support Subclasses for Serial Shared-Memory Implementations

\ingroup Thyra_Op_Vec_serial_adapters_grp

\brief The package %Thyra includes node subclasses for serial vector spaces,
vectors, multi-vectors, and linear operators.

The UML class diagram below shows the subclasses described here:

\image html SerialVectorSpaceBase.gif "Support base subclasses for serial shared-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

\section Thyra_Op_Vec_serial_adapters_classes_sec Base Subclasses for Serial Shared-Memory Platforms

The following subclasses represent general yet very efficient node subclasses
that almost all serial shared-memory vector space, vector and multi-vector
subclasses can and should inherit from.

<ul>

<li><tt>Thyra::SerialVectorSpaceBase</tt> is a useful node subclass for
defining concrete serial vector space subclasses.  This subclass simply
overrides <tt>%Thyra::VectorSpaceBase::isCompatible()</tt> to return
<tt>true</tt> if the other vector space is in core and is the same dimension
since this is all that should be required for serial vectors and multi-vectors
to be 100\% compatible.

<li><tt>Thyra::SerialVectorBase</tt> is a useful node subclass for defining
concrete serial vector subclasses.  This base class provides a very general
implementation for <tt>%Thyra::%VectorBase::%applyOp()</tt> that relies on
explicit vector element access.  All that a concrete subclass must do to is to
provide explicit access to vector data in overrides of the virtual
<tt>Thyra::SerialVectorBase::getData()</tt> functions.

<li><tt>Thyra::SerialMultiVectorBase</tt> is a useful node subclass for
defining concrete serial multi-vector subclasses.  This base class provides
implementations for both <tt>%Thyra::%MultiVectorBase::%applyOp()</tt> and
<tt>%Thyra::%MultiVectorBase::%apply()</tt> that relies on explicit
multi-vector element access.  All that a concrete subclass must do is to
provide explicit access to multi-vector data in overrides of the
<tt>Thyra::SerialMultiVectorBase::getData()</tt> functions.  Note in general
that the override of <tt>Thyra::MultiVectorBase::apply()</tt> is a level-3
BLAS operation and this base class uses <tt>Teuchos::BLAS::GEMM()</tt> to
access optimized level-3 BLAS.  This assumes that the %Teuchos package has
been configured to use optimized BLAS (for the data types <tt>float</tt>,
<tt>double</tt>, <tt>std::complex<float></tt> and
<tt>std::complex<double></tt> of course).

</ul>

The above base subclasses <tt>Thyra::SerialVectorBase</tt> and
<tt>Thyra::SerialMultiVectorBase</tt> should provide very efficient
implementations of all of the operations defined on <tt>Thyra::VectorBase</tt>
and <tt>Thyra::MultiVectorBase</tt> for serial shared-memory platforms.  All
that concrete subclasses must provide is explicit access to vector and
multi-vector data.

\section Thyra_Op_Vec_serial_adapters_linear_op_sec Base Subclasses for Serial Thyra::LinearOpBase Implementations

To facilitate the creation of concrete serial linear operators the
following simple but very general base class is supplied:

<ul> <li><tt>Thyra::SerialLinearOpBase</tt> is a general node subclass for
serial shared-memory platforms that only requires concrete subclass
implementations to override one function that accepts explicit vector data.
</ul>

*/

/** \defgroup Thyra_Op_Vec_adapters_serial_concrete_std_grp Efficient Generic Serial Concrete Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_serial_adapters_grp

\brief The package %Thyra includes general, yet very efficient, concrete
subclass implementations for serial vector spaces, vectors, multi-vectors, and
linear operators.

The UML class diagram below shows the subclasses described here:

\image html DefaultSerialVectorSpace.gif "Concrete subclasses for serial shared-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

<ul>

<li><tt>Thyra::DefaultSerialVectorSpaceFactory</tt> is a general concrete
implementation of a factory for serial vector spaces that creates
<tt>%Thyra::%DefaultSerialVectorSpace</tt> objects of any given dimension.  This
subclass is used to provide the default implementation of
<tt>%Thyra::VectorSpaceDefaultBase::smallVecSpcFcty()</tt>.  As a result,
<tt>%Thyra::%DefaultSerialVectorSpace</tt> is the default implementation of the
domain space of the default multi-vectors returned from
<tt>%Thyra::%VectorSpaceDefaultBase::%createMembers()</tt>.

<li><tt>Thyra::DefaultSerialVectorSpace</tt> is a general concrete implementation
for serial vector spaces that creates <tt>%Thyra::DefaultSerialVector</tt> and
<tt>%Thyra::DefaultSerialMultiVector</tt> objects.  All this subclass really does
is provide trivial implementations for the factory methods
<tt>%Thyra::%VectorSpaceBase::%createMember()</tt> and
<tt>%Thyra::%VectorSpaceBase::%createMembers()</tt>.

<li><tt>Thyra::DefaultSerialVector</tt> is an efficient general concrete
implementation for serial vectors.  All this subclass does is provide storage
for a serial vector and return pointers to that storage to the
<tt>%Thyra::SerialVectorBase</tt> base class through the overridden
<tt>%Thyra::DefaultSerialVector::getData()</tt> functions.  This concrete subclass
has constructors that accept arbitrary strided data and can trivially handle
any underlying data storage format due to the magic of
<tt>%Teuchos::RefCountPtr</tt>.

<li><tt>Thyra::DefaultSerialMultiVector</tt> is an efficient general concrete
implementation for serial multi-vectors.  All this subclass does is provide
storage for a serial multi-vector and return pointers to that storage (and
leading dimension) to the <tt>%Thyra::SerialMultiVectorBase</tt> base class
through the overridden <tt>%Thyra::DefaultSerialMultiVector::getData()</tt>
functions.  This concrete subclass has constructors that accept column-major
data and can trivially handle any underlying data storage format due to the
magic of <tt>%Teuchos::RefCountPtr</tt>.

</ul>

The above concrete subclasses provide very general and very efficient
implementations for serial vector space, vector, and multi-vector objects.
There should almost never be a need to develop any other serial subclasses for
these objects.  However, if for some reason one decides that one wants to
develop new such subclasses then the above concrete subclasses should provide
an adequate example for how to do so.

*/

/** \defgroup Thyra_Op_Vec_mpi_adapters_grp Thyra Operator/Vector Subclasses for MPI-based SPMD Distributed-Memory Platforms

\ingroup Thyra_Op_Vec_Adapters_grp

\brief The package %Thyra includes subclasses for common MPI-based SPMD vector
spaces, vectors, and multi-vectors which are described here.

When interfacing to most other well designed packages, there should be no need
to create new concrete MPI-based SPMD vector space, vector or multi-vector
subclasses given the subclasses described below.

\section Thyra_Op_Vec_mpi_adapters_classes_sec Subclasses for MPI SPMD Thyra Implementations

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_MPI_support_grp</b>

Click \ref Thyra_Op_Vec_adapters_MPI_support_grp "here" if you want to know
about the basic support base subclasses for a common type of MPI-based SPMD
vector and multi-vector implementation that all of the concrete
implementations described below depend on.

<li> <b>Concrete MPI-based SPMD subclasses</b>

Below are some concrete implementations of %Thyra classes that are
derived from the
\ref Thyra_Op_Vec_adapters_MPI_support_grp "basic MPI-support base subclasses"
mentioned above.

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_MPI_concrete_std_grp</b>

Click \ref Thyra_Op_Vec_adapters_MPI_concrete_std_grp "here" if you want to
know about some general, yet very efficient, concrete implementations of
MPI-based SPMD vector spaces, vectors and multi-vectors.

<li> <b><a href="../../../../../../epetra/thyra/doc/html/index.html">Epetra to Thyra Operator/Vector Adapters</a></b> (separate doxygen collection)

Click <a href="../../../../../../epetra/thyra/doc/html/index.html">here</a> if
you want to know about some general code that takes Epetra objects and creates
%Thyra wrappers for them.

</ol>

</ol>

*/

/** \defgroup Thyra_Op_Vec_adapters_MPI_support_grp Thyra Operator/Vector Base Support Subclasses for MPI-based SPMD Thyra Implementations

\ingroup Thyra_Op_Vec_mpi_adapters_grp

\brief The package %Thyra contains base subclasses that support a
common type of MPI-based SPMD implementation of vectors and
multi-vectors that are described here.

The UML class diagram below shows the subclasses described here:

\image html MPIVectorSpaceDefaultBase.gif "Support base subclasses for MPI SPMD distributed-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

The base subclasses described here provide support for a simple, yet
general, category of MPI-based SPMD vectors, multi-vectors and vector
spaces.

<ul>

<li><tt>Thyra::MPIVectorSpaceDefaultBase</tt> abstracts the the types of
SPMD distributed-memory data distributions supported by these base
subclasses.  This vector space base class assumes a unique
partitioning of vector and multi-vector elements to a set of
processors where there exists no ghost elements.

<li><tt>Thyra::MPIVectorBase</tt> is a base subclass for MPI-based
SPMD <tt>%Thyra::%VectorBase</tt> objects.  This class defines concrete
implementations for the <tt>%Thyra::%VectorBase</tt> virtual functions
<tt>%applyOp()</tt>, <tt>%acquireDetachedView() const</tt>, <tt>%releaseDetachedView()
const</tt>, <tt>%acquireDetachedView()</tt> and <tt>%commitDetachedView()</tt>.
These functions are implemented given explicit access to local processor
elements as returned by the <tt>getLocalData()</tt> functions overridden
in a subclass object.

<li><tt>Thyra::MPIMultiVectorBase</tt> is a base subclass for
MPI-based SPMD <tt>%Thyra::%MultiVectorBase</tt> objects.  This class
defines concrete implementations for the
<tt>%Thyra::%MultiVectorBase</tt> virtual functions <tt>%applyOp()</tt>,
<tt>%acquireDetachedView() const</tt>, <tt>%releaseDetachedView()
const</tt>, <tt>%acquireDetachedView()</tt> and
<tt>%commitDetachedView()</tt>.  These functions are implemented
given explicit access to local processor elements as returned by the
<tt>getLocalData()</tt> functions overridden in a subclass object.  In
addition, this subclass derives from
<tt>Thyra::EuclideanLinearOpBase</tt> so that any
application-specific scalar product is automatically supported.  The
multi-vector version of
<tt>Thyra::MPIMultiVectorBase::euclideanApply()</tt> is implemented
by calling <tt>Teuchos::BLAS::GEMM()</tt> on each local processor to
access level-3 BLAS.  Therefore, if %Teuchos is configured to link to
optimized BLAS then this base subclass will provided a near optimal
implementation of a MPI SPMD multi-vector.

</ul>

One of the big advantages of deriving concrete MPI-based SPMD
implementations from these base subclasses is that they provide automatic
interoperability between different concrete subclasses.  This type of
automatic interoperability is demonstrated in ???this testing program???.

\section Thyra_Op_Vec_mpi_adapters_linear_op_sec Base Subclasses for MPI Thyra::LinearOpBase Implementations

To facilitate the creation of concrete MPI linear operators the
following simple but very general base class is supplied:

<ul> <li><tt>Thyra::MPILinearOpBase</tt> is a general base subclass
for MPI SPMD platforms that only requires concrete subclass
implementations to override one function that accepts explicit local
vector data.  </ul>

*/

/** \defgroup Thyra_Op_Vec_adapters_MPI_concrete_std_grp Efficient Generic MPI-based SPMD Concrete Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_mpi_adapters_grp

\brief The package %Thyra contains highly efficient concrete
implementations of MPI-based vector space, vector and multi-vector
subclasses.

\image html DefaultMPIVectorSpace.gif "Concrete subclasses for MPI-based SPMD distributed-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

\section Thyra_Op_Vec_adapters_MPI_concrete_std_classes_grp Concrete MPI-based SPMD Subclasses

The concrete subclasses described here derive directly from the \ref
\ref Thyra_Op_Vec_adapters_MPI_support_grp.

<ul>

<li><tt>Thyra::DefaultMPIVectorSpaceFactory</tt> is a concrete
<tt>%Thyra::%VectorSpaceFactoryBase</tt> subclass implementation that
creates locally replicated <tt>%Thyra::%DefaultMPIVectorSpace</tt> objects
given their dimension.  This class is meant to create domain spaces for
any MPI-based SPMD multi-vector object it is is used as such (for
example, see <tt>Thyra::MPIVectorSpaceDefaultBase::smallVecSpcFcty()</tt>).

<li><tt>Thyra::DefaultMPIVectorSpace</tt> is a general
<tt>%Thyra::%VectorSpaceBase</tt> subclass implementation for MPI-based
SPMD vector spaces which creates <tt>%Thyra::%DefaultMPIVector</tt> and
<tt>%Thyra::%DefaultMPIMultiVector</tt> objects.

<li><tt>Thyra::DefaultMPIVector</tt> is a very general, highly
efficient <tt>%Thyra::%VectorBase</tt> subclass implementation for
MPI-based SPMD vectors.  Objects of this type can be constructed
from a variety of data sources due to the magic of
<tt>%Teuchos::%RefCountPtr</tt>.

<li><tt>Thyra::DefaultMPIMultiVector</tt> is a very general, highly
efficient <tt>%Thyra::%MultiVectorBase</tt> subclass implementation for
MPI-based SPMD multi-vectors.  Objects of this type can be constructed
from a variety of data sources due to the magic of
<tt>%Teuchos::%RefCountPtr</tt>.

</ul>

Together, these concrete subclasses provide a complete and highly
efficient implementation for MPI-based SPMD vector, multi-vector and
vector space objects.  From the standpoint of the needs of an ANA,
there is really no need for any other concrete implementations of
these subclasses for MPI SPMD platforms.

*/

/** \defgroup Thyra_Op_Vec_ANA_Development_grp Thyra Operator/Vector Interfaces as an API for the Development of Abstract Numerical Algorithms (ANAs)

\ingroup Thyra_Op_Vec_use_cases_grp

\brief While the \ref Thyra_Op_Vec_foundational_interfaces_sec were not
principally designed to provide a direct API for the development of
ANA software, with some minimal helper functions and classes, directly
writing even sophisticated ANA implementations directly in terms of
%Thyra objects is quite straightforward.

It turns out that using %Thyra for the development of simple ANAs,
as described below, really does not require any deep understanding of
the \ref Thyra_Op_Vec_foundational_interfaces_sec "foundational Thyra operator/vector interfaces.

\section Thyra_Op_Vec_ANA_Development_overview_sec Overview of Using Thyra Software for Development of ANA Software

There are several different types of helper classes and functions that
simplify the use of %Thyra for the development of ANAs.

<ol>

<li> <b>"Standard" non-member wrapper functions for vector (and multi-vector) reduction/transformation operations</b>

While the use of the <tt>RTOpPack::RTOpT</tt> interface class and the
single <tt>Thyra::VectorBase::applyOp()</tt> function provide an elegant
and efficient solution for the interoperability of vector
interfaces, it is not the easiest API for developing ANAs.  However,
a number of easy to use C++ wrapper functions for many different
 vector and multi-vector operations is already provided:

<ul>
<li> \ref Thyra_Op_Vec_VectorStdOps_grp
<li> \ref Thyra_Op_Vec_MultiVectorStdOps_grp
</ul>

These C++ wrapper functions rely on pre-implemented
<tt>RTOpPack::RTOpT</tt> subclasses.  Adding new
<tt>RTOpPack::RTOpT</tt> subclasses and new wrapper functions for new
vector and multi-vector reduction/transformation operations is an easy
matter for an experienced C++ developer who understands
<tt>RTOpPack::RTOpT</tt> (please contact rabartl@sandia.gov if you
need a new vector or multi-vector operation that is not already
supported).

<li> <b>Creating explicit views of vector and multi-vector elements</b>

<b>Warning!</b> using the utility classes below it is very easy to
obtain direct access to vector and multi-vector elements but in
general, this is a very bad idea.  However, as described in <a
href="http://software.sandia.gov/trilinos/packages/tsfcore/TSFCoreSAND.pdf">this
report</a>, there are some types of ANAs that require direct element
access to certain kinds of vectors and multi-vectors (for example,
vectors and multi-vectors that lie is the domain space of a
multi-vector).  The following utility classes streamline creating and
using explicit views.

<ul>
<li><tt>Thyra::ConstDetachedVectorView</tt> creates a (<tt>const</tt>) non-mutable explicit view of a <tt>const %Thyra::%VectorBase</tt> object,
    allows direct access to vector elements and then frees the view in the destructor.
<li><tt>Thyra::DetachedVectorView</tt> creates a (non-<tt>const</tt>) mutable explicit view of a <tt>%Thyra::%VectorBase</tt> object,
    allows direct access to vector elements and then frees the view in the destructor.
<li><tt>Thyra::ConstDetachedMultiVectorView</tt> creates a (<tt>const</tt>) non-mutable explicit view of a <tt>const %Thyra::%MultiVectorBase</tt> object,
    allows direct access to multi-vector elements and then frees the view in the destructor.
<li><tt>Thyra::DetachedMultiVectorView</tt> creates a (non-<tt>const</tt>) mutable explicit view of a <tt>%Thyra::%MultiVectorBase</tt> object,
    allows direct access to multi-vector elements and then frees the view in the destructor.
</ul>

One of the big advantages of using the above utility classes in
addition to their convenience is that views are freed in destructors
and these view will be freed even in the event that an exception is
thrown.  The use of these view classes is quite straightforward.

<li> <b>Aggregate vector space, vector, multi-vector and linear operator objects</b>

One of the big advantages of having a set of abstract interfaces to operators
and vectors is that it is quite easy to define some very useful aggregate
subclasses that allow one or more individual objects be treated as a single
object (see the "Composite" and "Decorator" design patterns in the GoF's
"Design Patterns" book).

<ol>

<li> <b>Product vector spaces, vectors and multi-vectors</b>

One particularly useful category of composite linear algebra objects
is the product vector space \f$\mathcal{X} = \mathcal{V}_1 {}\times
\mathcal{V}_2 {}\times {}\ldots {}\times \mathcal{V}_m\f$ where
\f$\mathcal{V}_k\f$, for \f$k = 1 {}\ldots m\f$, are different constituent
vector spaces.  Product vector spaces give rise to product vectors

\f[
x = \left[\begin{array}{c} v_1 \\ v_2 \\ \vdots \\ v_m \end{array}\right]
\f]

(where \f$v_1 \in \mathcal{V}_1, v_2 \in \mathcal{V}_2, \ldots, v_m
\in \mathcal{V}_m\f$) and product multi-vectors

\f[
X = \left[\begin{array}{c} V_1 \\ V_2 \\ \vdots \\ V_m \end{array}\right].
\f]

(where \f$V_1 \in \mathcal{V}_1 | \mathcal{D}, V_2 \in \mathcal{V}_2 | \mathcal{D},
\ldots, V_m \in \mathcal{V}_m | \mathcal{D}\f$ and \f$\mathcal{D}\f$ is the
domain space for the multi-vectors).

Very general concrete implementations of the product vector space, vector and
multi-vector interfaces described \ref
Thyra_Op_Vec_Interoperability_Extended_Interfaces_sec "here" are provided and
are shown below:

<ul>
<li><tt>Thyra::DefaultProductVectorSpace</tt> is a general concrete implementation of <tt>Thyra::ProductVectorSpaceBase</tt>
    that should be sufficient for most use cases.
<li><tt>Thyra::DefaultProductVector</tt> is a general concrete implementation of <tt>Thyra::ProductVectorBase</tt>
    that should be sufficient for most use cases.
<li><tt>Thyra::DefaultProductMultiVector</tt> is a general concrete implementation of <tt>Thyra::ProductMultiVectorBase</tt>
    that should be sufficient for most use cases. (ToDo: This needs to be implemented!)
</ul>

Note that the above concrete subclasses are very efficient for must,
but not all, possible use cases for such composite objects.

When using product vector spaces, product vectors and product
multi-vectors it is generally the case where a concrete
<tt>Thyra::DefaultProductVectorSpace</tt> object is first created and then
<tt>Thyra::DefaultProductVector</tt> and
<tt>Thyra::DefaultProductMultiVector</tt> objects are created by the
functions <tt>Thyra::DefaultProductVectorSpace::createMember()</tt> and
<tt>Thyra::DefaultProductVectorSpace::createMembers()</tt>.  See
\ref Thyra_Op_Vec_product_vec_spc_prg_grp "this example"
of how product vector spaces are used.

<li> <b>Miscellaneous aggregate linear operators</b>

There are several different types of useful composite
<tt>Thyra::LinearOpBase</tt> subclasses that one can define.  A few
useful composite linear operator subclasses are shown below:

<ul>

<li><tt>Thyra::DefaultDiagonalLinearOp</tt> is a simple concrete subclass
  that defines a diagonal linear operator

  \f$M = \mbox{diag}(d) \in \Re^{n \times n}\f$

  out of any <tt>Thyra::VectorBase</tt> object for the diagonal \f$d \in \Re^n\f$.

<li><tt>Thyra::DefaultScaledAdjointLinearOp</tt> is a simple concrete
  decorator subclass that defines an
  implicit scaled and/or adjoined (or transposed) linear operator

  \f$M = \gamma \; op(A)\f$.

<li><tt>Thyra::DefaultMultipliedLinearOp</tt> is a simple concrete composite
  subclass that defines a composite multiplicative
  <tt>Thyra::LinearOpBase</tt> of the form

  \f$M =\; A_1 A_2 \ldots A_m}\f$

  composed out of one or more constituent linear operators
  \f$A_0, A_1 \ldots A_{m-1}\f$.

<li><tt>Thyra::DefaultBlockedLinearOp</tt> is a simple concrete composite
  subclass that defines a composite blocking of
  <tt>Thyra::LinearOpBase</tt> objects of the form

  \f$M = \begin{array}{cccc}
    A_{0,0} & A_{0,1} & \ldots & A_{0,N} \\
    A_{1,0} & A_{1,1} & \ldots & A_{1,N} \\
    \vdots &  \vdots  & \ddots & \vdots \\
    A_{M,0} & A_{M,1} & \ldots & A_{M,N}
  \end{array}\f$

  composed out of one or more constituent linear operators.

</ul>

</ol>

<li> <b>Unit testing software</b>

This is basic testing software for %Thyra:

<ul>
<li><tt>Thyra::LinearOpTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::LinearOpBase</tt> object by checking its linear properties, and/or its adjoint,
    and/or symmetry.  In addition, it can check if two linear operators are the same.
<li><tt>Thyra::MultiVectorTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::MultiVectorBase</tt> object.  This class exposes a <tt>Thyra::LinearOpTester</tt> object
    for testing the <tt>LinearOpBase</tt> base interface of <tt>Thyra::MultiVectorBase</tt>. 
<li><tt>Thyra::VectorTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::VectorBase</tt> object.  This class exposes a <tt>Thyra::MultiVectorTester</tt> object
    for testing the <tt>MultiVectorBase</tt> base interface of <tt>Thyra::VectorBase</tt>. 
<li><tt>Thyra::VectorSpaceTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then proceeds to create a number of <tt>Thyra::VectorBase</tt> and
    <tt>Thyra::MultiVectorBase</tt> objects and then and validates all of these objects.
    This class class, therefore, is a unit testing class for all three interfaces <tt>%Thyra::VectorSpaceBase</tt>,
    <tt>%Thyra::VectorBase</tt>, and <tt>Thyra::MultiVectorBase</tt>.
<li><tt>Thyra::VectorStdOpsTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then tests all of the standard vector RTOp wrappers documented
    \ref Thyra_Op_Vec_VectorStdOps_grp "here".
<li><tt>Thyra::MultiVectorStdOpsTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then tests all of the standard multi-vector RTOp wrappers documented
    \ref Thyra_Op_Vec_MultiVectorStdOps_grp "here".
</ul>

<li> <b>Miscellaneous Tools for testing and debugging</b>

There is software included in the Thyra package to support basic
testing and debugging.

First, 100/% general output stream operators for any
<tt>Thyra::VectorBase</tt> or <tt>Thyra::LinearOpBase</tt> object are
provided in the following operator functions:

<ul>
<li><tt>Thyra::operator<<(std::ostream& o, const Thyra::VectorBase<Scalar>& v)</tt>
    is an output stream operator for printing <tt>Thyra::VectorBase</tt> objects.
<li><tt>Thyra::operator<<(std::ostream& o, const Thyra::LinearOpBase<Scalar>& M)</tt>
    is an output stream operator for printing <tt>Thyra::LinearOpBase</tt> (and therefore
also <tt>Thyra::MultiVectorBase</tt>) objects.
</ul>

\section Thyra_Op_Vec_ANA_Development_examples_sec Examples of Abstract Numerical Algorithms

There are several code examples that one can study to see how to use
the code described here as an API for developing ANAs.

<ul>

<li><tt>sillyPowerMethod()</tt> is a simple example ANA that
implements the power method for estimating the dominate eigenvalue
of a linear operator.

<li><tt>sillyCgSolve()</tt> is a simple example ANA that
implements the conjugate gradient method for solving a symmetric
positive definite linear system.

<li><tt>Thyra::LinearOpTester::check()</tt> shows how to access a
<tt>Thyra::LinearOpBase</tt> objects domain and range spaces, how to use
these spaces to create vectors and multi-vectors and how to perform
various types of operations involving vectors, multi-vectors and
linear operators.

</ul>

\section Thyra_Op_Vec_ANA_Development_other_sec Other Use Cases

<ul>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_Adapters_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_ANA_Development_support_code_grp General ANA support code
 *
 * \ingroup Thyra_Op_Vec_ANA_Development_grp
 */

/** \defgroup Thyra_Op_Vec_ANA_Development_support_code_utils_grp General ANA support code utilities
 *
 * \ingroup Thyra_Op_Vec_ANA_Development_support_code_grp
 */

//
// Examples
//


/** \defgroup Thyra_Op_Vec_examples_grp Assorted Thyra Operator/Vector Example Code

\brief Below are links to example code that demonstrate various use cases for
%Thyra operator/vector code:

<ol>

<li>\ref Thyra_Op_Vec_examples_power_method_grp

<li>\ref Thyra_Op_Vec_examples_cg_grp

<li>\ref Thyra_Op_Vec_product_vec_spc_prg_grp

<li>\ref Thyra_Op_Vec_test_scalar_product_prg_grp

</ol>

*/

//
// Silly power method example
//

/** \defgroup Thyra_Op_Vec_examples_power_method_grp Power Method Examples

\ingroup Thyra_Op_Vec_examples_grp

\brief Here we show some simple examples of using code in the %Thyra
package with an example linear ANA algorithm for the power method for
estimating the dominate eigen value of a matrix.

These example programs are meant to mimic the power method example
program shown in the <a href="../../../../../../epetra/doc/html/index.html#example">Epetra
documentation</a>.

The power method ANA is implemented in the function
<tt>sillyPowerMethod()</tt> and its implementation is shown below:

\dontinclude sillyPowerMethod.hpp

\skip template
\until end sillyPowerMethod

The above templated function <tt>%sillyPowerMethod()</tt> is used in
the following various example implementations which use several
different scalar types:

<ol>

<li>\ref Thyra_Op_Vec_examples_power_method_serial_grp

</ol>

*/

/** \example sillyPowerMethod.hpp

Click \ref Thyra_Op_Vec_examples_power_method_grp "here" for a more
detailed discussion of this example function.

*/

/** \defgroup Thyra_Op_Vec_examples_power_method_serial_grp Templated Serial Implementation of the Power Method

\ingroup Thyra_Op_Vec_examples_power_method_grp

\brief Here is an example program that shows the use of the example
serial templated matrix class <tt>SerialTridiagLinearOp</tt>
with the example linear ANA implementation <tt>sillyPowerMethod()</tt>.

This example program is contained in the source file:

\verbatim ./example/Core/sillyPowerMethod_serial.cpp \endverbatim

where <tt>./</tt> is the base source directory for %Thyra
(i.e. <tt>???/Trilinos/packages/Thyra</tt>).

The class <tt>SerialTridiagLinearOp</tt> that derives from the
base class <tt>Thyra::SerialLinearOpBase</tt> is quite simple and
its complete implementation looks like:

\dontinclude SerialTridiagLinearOp.hpp
\skip template
\until end class SerialTridiagLinearOp

\dontinclude sillyPowerMethod_serial.cpp

The above serial matrix class is used in an example program (see
<tt>runPowerMethodExample()</tt> below) that calls <tt>%sillyPowerMethod()</tt>.
In this example program, the matrix constructed and used is the
well-known tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2      & -1 \\
-1     &  2      & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -1      & 2       & -1 \\
       &         &         &  -1     & 2
\end{array}\right].
\f]

The power method is then run on the matrix \f$A\f$ run for a number of
iterations (or until convergence to some tolerance).

After this, the first diagonal element \f$A_{(1,1)}=2\f$ is then
scaled to \f$A_{(1,1)}=20\f$ and the power method is run again (which
much faster convergence).

The following templated function implements the example described
above:

\skip template
\until end runPowerMethodExample

The above templated function <tt>runPowerMethodExample()</tt> is
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
<li> Real extended-precision type <b><tt>mpf_class</tt></b>
     (if <tt>--enable-teuchos-gmp</tt> was used at configuration time)
<li> Complex extended-precision type <b><tt>std::complex<mpf_class></tt></b>
     (if <tt>--enable-teuchos-complex</tt> and <tt>--enable-teuchos-gmp</tt>
     where used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/Core/sillyPowerMethod_serial.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>???/Trilinos/$BUILD_DIR/packages/Thyra</tt>).

This example program should run successfully with no arguments and, at the
time of this writing, produces the following output:

\verbatim

$ ./sillyPowerMethod_serial.exe

***
*** Running power method example using scalar type = 'float' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = 2.634806e+00, ||A*q-lambda*q|| = 9.051834e-01
Iter = 4, lambda = 3.552294e+00, ||A*q-lambda*q|| = 2.496006e-01
Iter = 8, lambda = 3.612831e+00, ||A*q-lambda*q|| = 7.194513e-02
Iter = 12, lambda = 3.617640e+00, ||A*q-lambda*q|| = 1.981858e-02
Iter = 16, lambda = 3.618005e+00, ||A*q-lambda*q|| = 5.435463e-03
Iter = 20, lambda = 3.618032e+00, ||A*q-lambda*q|| = 1.490343e-03
Iter = 24, lambda = 3.618034e+00, ||A*q-lambda*q|| = 4.085834e-04

  Estimate of dominate eigenvalue lambda = 3.618034e+00

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = 1.791493e+01, ||A*q-lambda*q|| = 5.881544e+00
Iter = 4, lambda = 2.005555e+01, ||A*q-lambda*q|| = 3.251727e-03
Iter = 8, lambda = 2.005556e+01, ||A*q-lambda*q|| = 2.788594e-06

  Estimate of dominate eigenvalue lambda = 2.005556e+01

***
*** Running power method example using scalar type = 'double' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = 2.634806e+00, ||A*q-lambda*q|| = 9.051834e-01
Iter = 4, lambda = 3.552293e+00, ||A*q-lambda*q|| = 2.496007e-01
Iter = 8, lambda = 3.612831e+00, ||A*q-lambda*q|| = 7.194514e-02
Iter = 12, lambda = 3.617641e+00, ||A*q-lambda*q|| = 1.981868e-02
Iter = 16, lambda = 3.618004e+00, ||A*q-lambda*q|| = 5.435543e-03
Iter = 20, lambda = 3.618032e+00, ||A*q-lambda*q|| = 1.490271e-03
Iter = 24, lambda = 3.618034e+00, ||A*q-lambda*q|| = 4.085797e-04

  Estimate of dominate eigenvalue lambda = 3.618034e+00

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = 1.791493e+01, ||A*q-lambda*q|| = 5.881543e+00
Iter = 4, lambda = 2.005555e+01, ||A*q-lambda*q|| = 3.251777e-03
Iter = 8, lambda = 2.005556e+01, ||A*q-lambda*q|| = 2.681092e-06

  Estimate of dominate eigenvalue lambda = 2.005556e+01

***
*** Running power method example using scalar type = 'std::complex<float>' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = (1.885460e+00,2.235174e-08), ||A*q-lambda*q|| = 8.366854e-01
Iter = 4, lambda = (2.908303e+00,1.490116e-08), ||A*q-lambda*q|| = 4.634469e-01
Iter = 8, lambda = (3.465825e+00,-5.960464e-08), ||A*q-lambda*q|| = 3.592391e-01
Iter = 12, lambda = (3.604720e+00,-2.980232e-08), ||A*q-lambda*q|| = 1.146174e-01
Iter = 16, lambda = (3.617021e+00,-9.778887e-09), ||A*q-lambda*q|| = 3.181574e-02
Iter = 20, lambda = (3.617958e+00,9.010546e-08), ||A*q-lambda*q|| = 8.730849e-03
Iter = 24, lambda = (3.618028e+00,1.565786e-08), ||A*q-lambda*q|| = 2.393888e-03
Iter = 28, lambda = (3.618034e+00,9.727955e-09), ||A*q-lambda*q|| = 6.563177e-04

  Estimate of dominate eigenvalue lambda = (3.618034e+00,9.727955e-09)

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = (1.316405e+01,-1.341105e-07), ||A*q-lambda*q|| = 8.828070e+00
Iter = 4, lambda = (2.005556e+01,1.859358e-07), ||A*q-lambda*q|| = 4.617708e-03
Iter = 8, lambda = (2.005555e+01,5.564779e-08), ||A*q-lambda*q|| = 4.349416e-06

  Estimate of dominate eigenvalue lambda = (2.005555e+01,5.564779e-08)

***
*** Running power method example using scalar type = 'std::complex<double>' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = (1.885459e+00,1.387779e-17), ||A*q-lambda*q|| = 8.366853e-01
Iter = 4, lambda = (2.908303e+00,-2.775558e-17), ||A*q-lambda*q|| = 4.634469e-01
Iter = 8, lambda = (3.465825e+00,-1.040834e-16), ||A*q-lambda*q|| = 3.592392e-01
Iter = 12, lambda = (3.604720e+00,1.249001e-16), ||A*q-lambda*q|| = 1.146174e-01
Iter = 16, lambda = (3.617021e+00,-1.058181e-16), ||A*q-lambda*q|| = 3.181573e-02
Iter = 20, lambda = (3.617958e+00,6.179952e-17), ||A*q-lambda*q|| = 8.730912e-03
Iter = 24, lambda = (3.618028e+00,-4.602438e-17), ||A*q-lambda*q|| = 2.393871e-03
Iter = 28, lambda = (3.618034e+00,-8.632960e-18), ||A*q-lambda*q|| = 6.563170e-04

  Estimate of dominate eigenvalue lambda = (3.618034e+00,-8.632960e-18)

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = (1.316405e+01,-5.551115e-16), ||A*q-lambda*q|| = 8.828069e+00
Iter = 4, lambda = (2.005555e+01,-3.814166e-16), ||A*q-lambda*q|| = 4.617726e-03
Iter = 8, lambda = (2.005556e+01,-1.371085e-17), ||A*q-lambda*q|| = 3.719354e-06

  Estimate of dominate eigenvalue lambda = (2.005556e+01,-1.371085e-17)

***
*** Running power method example using scalar type = 'mpf_class' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = 9.402176e-01, ||A*q-lambda*q|| = 1.103226e+00
Iter = 4, lambda = 3.577075e+00, ||A*q-lambda*q|| = 1.999005e-01
Iter = 8, lambda = 3.614877e+00, ||A*q-lambda*q|| = 5.609685e-02
Iter = 12, lambda = 3.617796e+00, ||A*q-lambda*q|| = 1.542336e-02
Iter = 16, lambda = 3.618016e+00, ||A*q-lambda*q|| = 4.229461e-03
Iter = 20, lambda = 3.618033e+00, ||A*q-lambda*q|| = 1.159585e-03
Iter = 24, lambda = 3.618034e+00, ||A*q-lambda*q|| = 3.179170e-04

  Estimate of dominate eigenvalue lambda = 3.618034e+00

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = 1.102725e+01, ||A*q-lambda*q|| = 9.675451e+00
Iter = 4, lambda = 2.005556e+01, ||A*q-lambda*q|| = 1.920248e-03
Iter = 8, lambda = 2.005556e+01, ||A*q-lambda*q|| = 1.572132e-06

  Estimate of dominate eigenvalue lambda = 2.005556e+01

Congratulations! All of the tests checked out!

\endverbatim

This example program also takes a number of command-line options.  To
see what the command-line options are, use the <tt>--help</tt> option.
At the time of this writing, the command-line options returned from
<tt>./sillyPowerMethod_serial.exe --help</tt> are:

\verbatim
$ ./sillyPowerMethod_serial.exe --help
Usage: ./sillyPowerMethod_serial [options]
  options:
  --help                         Prints this help message
  --pause-for-debugging          Pauses for user input to allow attaching a debugger
  --verbose              bool    Determines if any output is printed or not.
  --quiet                        (default: --verbose)
  --dim                  int     Dimension of the linear system.
                                 (default: --dim=4)
  --dump-all             bool    Determines if quantities are dumped or not.
  --no-dump                      (default: --no-dump)
\endverbatim

To see the full listing of this example program click: <a
href="sillyPowerMethod__serial_8cpp-example.html">
sillyPowerMethod_serial.cpp </a>

*/

/** \example SerialTridiagLinearOp.hpp

Click \ref Thyra_Op_Vec_examples_power_method_serial_grp "here" and
\ref Thyra_Op_Vec_examples_cg_serial_grp "here" for example programs that
use this example class.

*/

/** \example MPITridiagLinearOp.hpp

Click \ref Thyra_Op_Vec_examples_power_method_MPI_grp "here" and
\ref Thyra_Op_Vec_examples_cg_MPI_grp "here" for example programs that
use this example class.

*/

/** \example sillyPowerMethod_serial.cpp

Click \ref Thyra_Op_Vec_examples_power_method_serial_grp "here" for a more
detailed discussion of this example program.

*/

//
// Silly CG example
//

/** \defgroup Thyra_Op_Vec_examples_cg_grp CG Examples

\ingroup Thyra_Op_Vec_examples_grp

\brief Here we show some simple examples of using code in the %Thyra
package with an example ANA algorithm for the iterative solution of
symmetric positive-definite linear systems using the conjugate
gradient (CG) method.

The CG ANA is implemented in the function <tt>sillyCgSolve()</tt> and
its implementation is shown below:

\dontinclude sillyCgSolve.hpp

\skip template
\until end sillyCgSolve

This above templated function is used in the following various example
implementations which use several different scalar types:

<ol>

<li>\ref Thyra_Op_Vec_examples_cg_serial_grp

<li>\ref Thyra_Op_Vec_examples_cg_MPI_grp

</ol>

*/

/** \example sillyCgSolve.hpp

Click \ref Thyra_Op_Vec_examples_cg_grp "here" for a more
detailed discussion of this example function.

*/

/** \defgroup Thyra_Op_Vec_examples_cg_serial_grp Templated Serial Implementation of the CG Method

\ingroup Thyra_Op_Vec_examples_cg_grp

\brief Here is an example program that shows the use of the example
serial templated matrix class <tt>SerialTridiagLinearOp</tt>
with the example linear ANA implementation <tt>sillyCgSolve()</tt>.

The class <tt>SerialTridiagLinearOp</tt> that derives from the
base class <tt>Thyra::SerialLinearOpBase</tt> is quite simple and
its complete implementation looks like:

\dontinclude SerialTridiagLinearOp.hpp
\skip template
\until end class SerialTridiagLinearOp

\dontinclude sillyCgSolve_serial.cpp

The above serial matrix class is used in an example program (see
<tt>runCgSolveExample()</tt> below) that calls <tt>%sillyCgSolve()</tt>.
In this example program, the matrix constructed and used is the following
tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2 a    & -1 \\
-r(1)  &  2 a    & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -r(n-2) & 2 a       & -1 \\
       &         &         &  -r(n-1)  & 2 a
\end{array}\right]
\f]

where \f$a\f$ is an adjustable diagonal scale factories that makes the matrix
\f$A\f$ more or less well conditioned and \f$r(i)\f$ is either \f$-1\f$ for a
symmetric operator or \f$rand()\f$ for an unsymmetric operator.

If a symmetric operator is used, then CG is run using \f$A\f$ directly.  If
\f$A\f$ is unsymmetric, then the normal equations

\f[

  A^H A x = A^H b

\f]

are solved and the operator used is

\f[
A \Rightarrow A^H A
\f]

The CG method is then run on the matrix \f$A\f$ or \f$A^H A\f$ for a number of
iterations or until convergence to some tolerance is achieved.

The following templated function <tt>runCgSolveExample()</tt>
implements the example described above:

\skip template
\until end runCgSolveExample

The above templated function <tt>runCgSolveExample()</tt> is then
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
<li> Real extended-precision type <b><tt>mpf_class</tt></b>
     (if <tt>--enable-teuchos-gmp</tt> was used at configuration time)
<li> Complex extended-precision type <b><tt>std::complex<mpf_class></tt></b>
     (if <tt>--enable-teuchos-complex</tt> and <tt>--enable-teuchos-gmp</tt>
     where used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/Core/sillyCgSolve_serial.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>???/Trilinos/$BUILD_DIR/packages/Thyra</tt>).

This example program should run successfully with no arguments and, at the time
of this writing, produces the following output:

\verbatim

$ ./sillyCgSolve_serial.exe

***
*** Running silly CG solver using scalar type = 'float' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<float>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(-0.0412178,-0.0412174) = 1.03937e-05
         <= linear_properties_error_tol() = 0.0001 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err(-0.0412178,-0.0412174) = 1.03937e-05
         >= linear_properties_warning_tol() = 1e-06!

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-15.3963,-15.3963) = 3.09709e-07
         <= adjoint_error_tol() = 0.0001 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<float>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<float>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(0.216513,0.216513) = 2.13352e-06
         <= linear_properties_error_tol() = 0.0001 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err(0.216513,0.216513) = 2.13352e-06
         >= linear_properties_warning_tol() = 1e-06!

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-10.5495,-10.5495) = 1.808e-07
         <= adjoint_error_tol() = 0.0001 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(18.106,18.106) = 3.1603e-07
         <= symmetry_error_tol() = 0.0001 : passed

*** Leaving LinearOpTester<float>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<float>', size = 500

describe x:
  type = 'DefaultSerialVector<float>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.812529e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 6.589733e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.381910e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 3.546838e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.840684e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 1.891940e-04
Iter = 204, ||b-A*x||/||b-A*x0|| = 9.613070e-05

||b-A*x||/||b|| = 1.344797e-03/1.299397e+01 = 1.034939e-04 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 3.680000e-01 sec

***
*** Running silly CG solver using scalar type = 'double' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<double>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.394610e-01,2.394610e-01) = 1.101131e-14
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-5.913676e+00,-5.913676e+00) = 9.011435e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<double>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<double>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.165119e-01,2.165119e-01) = 4.743187e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-1.054952e+01,-1.054952e+01) = 5.051482e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(1.810601e+01,1.810601e+01) = 1.962174e-16
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<double>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<double>', size = 500

describe x:
  type = 'DefaultSerialVector<double>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.812612e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 6.590140e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.382036e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 3.547269e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.842233e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 1.892296e-04
Iter = 204, ||b-A*x||/||b-A*x0|| = 9.615059e-05

||b-A*x||/||b|| = 1.249378e-03/1.299397e+01 = 9.615059e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 2.020000e-01 sec

***
*** Running silly CG solver using scalar type = 'std::complex<float>' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<std::complex<float>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-3.456044e-01,-4.895731e-01),(-3.456052e-01,-4.895744e-01)) = 2.541641e-06
         <= linear_properties_error_tol() = 1.000000e-04 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err((-3.456044e-01,-4.895731e-01),(-3.456052e-01,-4.895744e-01)) = 2.541641e-06
         >= linear_properties_warning_tol() = 1.000000e-06!

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.643561e+01,6.788700e+00),(1.643562e+01,6.788701e+00)) = 2.211224e-07
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<std::complex<float>>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<std::complex<float>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-9.677564e-01,6.222531e-01),(-9.677570e-01,6.222509e-01)) = 1.950122e-06
         <= linear_properties_error_tol() = 1.000000e-04 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err((-9.677564e-01,6.222531e-01),(-9.677570e-01,6.222509e-01)) = 1.950122e-06
         >= linear_properties_warning_tol() = 1.000000e-06!

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.402400e+01,4.335190e+00),(1.402399e+01,4.335191e+00)) = 3.911690e-07
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.046669e+01,2.444866e+00),(1.046669e+01,2.444870e+00)) = 5.173613e-07
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<std::complex<float>>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<std::complex<float>>', size = 500

describe x:
  type = 'DefaultSerialVector<std::complex<float>>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.721108e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 7.355135e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.733771e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 4.754171e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.684857e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 2.239717e-04
Iter = 208, ||b-A*x||/||b-A*x0|| = 9.721012e-05

||b-A*x||/||b|| = 1.887406e-03/1.800947e+01 = 1.048008e-04 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 3.410000e-01 sec

***
*** Running silly CG solver using scalar type = 'std::complex<double>' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<std::complex<double>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-4.443735e-01,-2.545424e-01),(-4.443735e-01,-2.545424e-01)) = 7.714438e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((6.554045e+00,7.729893e+00),(6.554045e+00,7.729893e+00)) = 8.314229e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<std::complex<double>>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<std::complex<double>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-9.677554e-01,6.222520e-01),(-9.677554e-01,6.222520e-01)) = 2.869021e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.402400e+01,4.335187e+00),(1.402400e+01,4.335187e+00)) = 3.375439e-15
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.046669e+01,2.444870e+00),(1.046669e+01,2.444870e+00)) = 1.652665e-16
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<std::complex<double>>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<std::complex<double>>', size = 500

describe x:
  type = 'DefaultSerialVector<std::complex<double>>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.721187e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 7.355587e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.733925e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 4.754771e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.686419e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 2.240143e-04
Iter = 208, ||b-A*x||/||b-A*x0|| = 9.723106e-05

||b-A*x||/||b|| = 1.751081e-03/1.800948e+01 = 9.723106e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 3.120000e-01 sec

***
*** Running silly CG solver using scalar type = 'mpf_class' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<mpf_class>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(9.554737e-01,9.554737e-01) = 3.054291e-19
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-6.665022e-01,-6.665022e-01) = 3.655873e-19
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<mpf_class>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<mpf_class>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(1.811994e+00,1.811994e+00) = 2.692563e-19
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-2.469042e+00,-2.469042e+00) = 3.952367e-20
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(7.214884e-01,7.214884e-01) = 8.887522e-20
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<mpf_class>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<mpf_class>', size = 500

describe x:
  type = 'DefaultSerialVector<mpf_class>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 7.662633e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 1.869085e-01
Iter = 93, ||b-A*x||/||b-A*x0|| = 4.641508e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 1.001201e-02
Iter = 155, ||b-A*x||/||b-A*x0|| = 2.792430e-03
Iter = 186, ||b-A*x||/||b-A*x0|| = 5.392830e-04
Iter = 217, ||b-A*x||/||b-A*x0|| = 1.093640e-04
Iter = 219, ||b-A*x||/||b-A*x0|| = 9.685596e-05

||b-A*x||/||b|| = 1.255016e-03/1.295755e+01 = 9.685596e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 3.037000e+00 sec

Congratulations! All of the tests checked out!

\endverbatim

This example program also takes a number of command-line options.  To
see what the command-line options are, use the <tt>--help</tt> option.
At the time of this writing, the command-line options returned from
<tt>./sillyCgSolve_serial.exe --help</tt> are:

\verbatim

$ ./sillyCgSolve_serial.exe --help
Usage: ./sillyCgSolve_serial [options]
  options:
  --help                         Prints this help message
  --pause-for-debugging          Pauses for user input to allow attaching a debugger
  --verbose              bool    Determines if any output is printed or not.
  --quiet                        (default: --verbose)
  --dim                  int     Dimension of the linear system.
                                 (default: --dim=500)
  --diag-scale           double  Scaling of the diagonal to improve conditioning.
                                 (default: --diag-scale=1.001)
  --sym-op               bool    Determines if the operator is symmetric or not.
  --unsym-op                     (default: --sym-op)
  --tol                  double  Relative tolerance for linear system solve.
                                 (default: --tol=0.0001)
  --max-num-iters        int     Maximum of CG iterations.
                                 (default: --max-num-iters=300)
\endverbatim

When the option <tt>--unsym-op</tt> is selected, the normal equations are
solved which is shown in the following example:

\verbatim

$ ./sillyCgSolve_serial.exe --unsym-op --max-num-iters=20

***
*** Running silly CG solver using scalar type = 'float' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<float>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(19.2992,19.2992) = 3.95322e-07
         <= linear_properties_error_tol() = 0.0001 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-1.72592,-1.72592) = 9.66979e-07
         <= adjoint_error_tol() = 0.0001 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<float>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<float>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<float>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<float>', rangeDim = 500, domainDim = 500
          overallScalar=1
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(35.3825,35.3825) = 2.15626e-07
         <= linear_properties_error_tol() = 0.0001 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-36.7441,-36.744) = 2.07636e-07
         <= adjoint_error_tol() = 0.0001 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(37.9726,37.9726) = 0
         <= symmetry_error_tol() = 0.0001 : passed

*** Leaving LinearOpTester<float>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<float>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<float>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<float>', size = 500

describe x:
  type = 'DefaultSerialVector<float>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 6.660668e-03
Iter = 6, ||b-A*x||/||b-A*x0|| = 3.351218e-05

||b-A*x||/||b|| = 1.069767e-03/3.191998e+01 = 3.351403e-05 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 1.090000e-01 sec

***
*** Running silly CG solver using scalar type = 'double' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<double>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(-1.680574e+00,-1.680574e+00) = 1.321243e-16
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-6.383695e-01,-6.383695e-01) = 2.260901e-15
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<double>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<double>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<double>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<double>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(6.938410e+00,6.938410e+00) = 1.024071e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-2.814797e+01,-2.814797e+01) = 2.524312e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(4.438044e+01,4.438044e+01) = 1.601027e-16
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<double>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<double>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<double>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<double>', size = 500

describe x:
  type = 'DefaultSerialVector<double>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 1.233805e-01
Iter = 6, ||b-A*x||/||b-A*x0|| = 2.217761e-02
Iter = 9, ||b-A*x||/||b-A*x0|| = 4.338932e-03
Iter = 12, ||b-A*x||/||b-A*x0|| = 7.668738e-04
Iter = 15, ||b-A*x||/||b-A*x0|| = 1.317471e-04
Iter = 16, ||b-A*x||/||b-A*x0|| = 7.581160e-05

||b-A*x||/||b|| = 2.307234e-03/3.043379e+01 = 7.581160e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 6.700000e-02 sec

***
*** Running silly CG solver using scalar type = 'std::complex<float>' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<std::complex<float>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((2.723428e-01,2.028702e+00),(2.723447e-01,2.028702e+00)) = 9.390742e-07
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.121651e+01,3.660773e+00),(1.121650e+01,3.660776e+00)) = 2.914302e-07
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<std::complex<float>>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<std::complex<float>>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
          overallScalar=(1.000000e+00,0.000000e+00)
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-1.574269e+01,1.134796e+01),(-1.574271e+01,1.134796e+01)) = 8.368621e-07
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((5.278718e+01,4.448534e+00),(5.278718e+01,4.448544e+00)) = 1.938938e-07
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((2.419142e+01,1.037749e+01),(2.419140e+01,1.037749e+01)) = 6.680345e-07
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<std::complex<float>>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
          overallScalar=(1.000000e+00,0.000000e+00)
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<std::complex<float>>', size = 500

describe x:
  type = 'DefaultSerialVector<std::complex<float>>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 1.431026e-01
Iter = 6, ||b-A*x||/||b-A*x0|| = 2.387369e-02
Iter = 9, ||b-A*x||/||b-A*x0|| = 3.633558e-03
Iter = 12, ||b-A*x||/||b-A*x0|| = 5.538159e-04
Iter = 15, ||b-A*x||/||b-A*x0|| = 8.121288e-05

||b-A*x||/||b|| = 3.305705e-03/4.070510e+01 = 8.121108e-05 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 6.700000e-02 sec

***
*** Running silly CG solver using scalar type = 'std::complex<double>' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<std::complex<double>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-1.970843e+00,-3.441251e+01),(-1.970843e+00,-3.441251e+01)) = 6.291975e-16
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.372625e+00,1.850210e+01),(1.372625e+00,1.850210e+01)) = 8.360598e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<std::complex<double>>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<std::complex<double>>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
          overallScalar=(1.000000e+00,0.000000e+00)
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-5.472665e+01,3.895074e+01),(-5.472665e+01,3.895074e+01)) = 9.520071e-16
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((-1.017174e+01,1.130154e+01),(-1.017174e+01,1.130154e+01)) = 1.263687e-15
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((2.205033e+01,-4.284830e+01),(2.205033e+01,-4.284830e+01)) = 1.823840e-15
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<std::complex<double>>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
          overallScalar=(1.000000e+00,0.000000e+00)
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<std::complex<double>>', size = 500

describe x:
  type = 'DefaultSerialVector<std::complex<double>>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 2.153769e-02
Iter = 6, ||b-A*x||/||b-A*x0|| = 3.394906e-04
Iter = 7, ||b-A*x||/||b-A*x0|| = 9.023713e-05

||b-A*x||/||b|| = 4.053765e-03/4.492347e+01 = 9.023713e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 5.900000e-02 sec

***
*** Running silly CG solver using scalar type = 'mpf_class' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<mpf_class>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.352466e+02,2.352466e+02) = 1.221329e-20
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(6.045283e+01,6.045283e+01) = 1.019303e-20
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<mpf_class>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<mpf_class>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.173757e+02,2.173757e+02) = 1.945199e-20
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(4.949277e+01,4.949277e+01) = 1.752502e-20
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(5.540864e+01,5.540864e+01) = 2.152412e-20
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<mpf_class>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<mpf_class>', size = 500

describe x:
  type = 'DefaultSerialVector<mpf_class>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 2.692000e-01
Iter = 6, ||b-A*x||/||b-A*x0|| = 2.507806e-02
Iter = 9, ||b-A*x||/||b-A*x0|| = 3.479960e-03
Iter = 12, ||b-A*x||/||b-A*x0|| = 5.338185e-04
Iter = 15, ||b-A*x||/||b-A*x0|| = 7.988701e-05

||b-A*x||/||b|| = 1.412440e-03/1.768048e+01 = 7.988701e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 5.060000e-01 sec

Congratulations! All of the tests checked out!

\endverbatim

Note in the above example how the normal operator \f$A^H A\f$ is described.
This aggregate operator is created by the function calls
<tt>Thyra::scale()</tt> and <tt>Thyra::multiply()</tt> which create implicit
<tt>Thyra::ScaledAdjointedLinearOp</tt> and
<tt>Thyra::DefaultMultipliedLinearOp</tt> objects.

To see the full listing of this example program click: <a
href="sillyCgSolve__serial_8cpp-example.html">
sillyCgSolve_serial.cpp </a>

*/

/** \example sillyCgSolve_serial.cpp

Click \ref Thyra_Op_Vec_examples_cg_serial_grp "here" for a more
detailed discussion of this example program.

*/

/** \defgroup Thyra_Op_Vec_examples_cg_MPI_grp Templated MPI Implementation of the CG Method

\ingroup Thyra_Op_Vec_examples_cg_grp

\brief Here is an example program that shows the use of the example
MPI templated matrix class <tt>MPITridiagLinearOp</tt> with the
example linear ANA implementation <tt>sillyCgSolve()</tt>.

The class <tt>MPITridiagLinearOp</tt> that derives from the base class
<tt>Thyra::MPILinearOpBase</tt> is quite simple and its
implementation (minus the <tt>communication()</tt> function) looks
like:

\dontinclude MPITridiagLinearOp.hpp
\skip template
\until end class MPITridiagLinearOp

\dontinclude sillyCgSolve_mpi.cpp

The above MPI matrix class is used in an example program (see
<tt>runCgSolveExample()</tt> below) that calls
<tt>%sillyCgSolve()</tt>.  In this example program, the matrix
constructed and used is the well-known tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2 a    & -1 \\
-1     &  2 a    & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -1      & 2 a     & -1 \\
       &         &         &  -1     & 2 a
\end{array}\right]
\f]

where \f$a\f$ is an adjustable diagonal scale factor that makes the
matrix \f$A\f$ more or less well conditioned.

The CG method is then run on the matrix \f$A\f$ for a number of
iterations or until convergence to some tolerance is achieved.

The following templated function <tt>runCgSolveExample()</tt>
implements the example described above:

\skip template
\until end runCgSolveExample

The above templated function <tt>runCgSolveExample()</tt> is then
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/Core/sillyCgSolve_mpi.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>???/Trilinos/$BUILD_DIR/packages/Thyra</tt>).

This example program should run successfully with no arguments for any number
of processors and, at the time of this writing, for one processor produces the
following output:

\verbatim

$ ./sillyCgSolve_mpi.exe

***
*** Running silly CG solver using scalar type = 'float' ...
***

Constructing tridiagonal matrix A of local dimension = 500 and diagonal multiplier = 1.001 ...

Global dimension of A = 500

Testing the constructed linear operator A ...

*** Entering LinearOpTester<Scalar>::check(op,...) ...

op = 18MPITridiagLinearOpIfE

Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(-0.0412178,-0.0412174) = 1.0936e-05
         <= linear_properties_error_tol() = 0.0001 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err(-0.0412178,-0.0412174) = 1.0936e-05
         >= linear_properties_warning_tol() = 1e-06!

Skipping adjoint check since op.opSupported(CONJTRANS)==false

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-15.3963,-15.3963) = 3.09709e-07
         <= symmetry_error_tol() = 0.0001 : passed

*** Leaving LinearOpTester<Scalar>::check(...)

Starting CG solver ...

describe A:
  type = '18MPITridiagLinearOpIfE', rangeDim = 500, domainDim = 500

describe b:
  type = 'N5Thyra12MPIVectorStdIfEE', size = 500

describe x:
  type = 'N5Thyra12MPIVectorStdIfEE', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.812529e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 6.589733e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.381910e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 3.546838e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.840684e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 1.891940e-04
Iter = 204, ||b-A*x||/||b-A*x0|| = 9.613070e-05

||b-A*x||/||b|| = 1.344796e-03/1.299397e+01 = 1.034939e-04 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 5.490000e-01 sec

***
*** Running silly CG solver using scalar type = 'double' ...
***

Constructing tridiagonal matrix A of local dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Global dimension of A = 500

Testing the constructed linear operator A ...

*** Entering LinearOpTester<Scalar>::check(op,...) ...

op = 18MPITridiagLinearOpIdE

Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.165119e-01,2.165119e-01) = 4.871381e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Skipping adjoint check since op.opSupported(CONJTRANS)==false

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-1.054952e+01,-1.054952e+01) = 5.051482e-16
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<Scalar>::check(...)

Starting CG solver ...

describe A:
  type = '18MPITridiagLinearOpIdE', rangeDim = 500, domainDim = 500

describe b:
  type = 'N5Thyra12MPIVectorStdIdEE', size = 500

describe x:
  type = 'N5Thyra12MPIVectorStdIdEE', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.812612e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 6.590140e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.382036e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 3.547269e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.842233e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 1.892296e-04
Iter = 204, ||b-A*x||/||b-A*x0|| = 9.615059e-05

||b-A*x||/||b|| = 1.249378e-03/1.299397e+01 = 9.615059e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 2.120000e-01 sec

***
*** Running silly CG solver using scalar type = 'std::complex<float>' ...
***

Constructing tridiagonal matrix A of local dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Global dimension of A = 500

Testing the constructed linear operator A ...

*** Entering LinearOpTester<Scalar>::check(op,...) ...

op = 18MPITridiagLinearOpISt7complexIfEE

Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((5.142615e-01,1.741409e-01),(5.142629e-01,1.741405e-01)) = 2.639293e-06
         <= linear_properties_error_tol() = 1.000000e-04 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err((5.142615e-01,1.741409e-01),(5.142629e-01,1.741405e-01)) = 2.639293e-06
         >= linear_properties_warning_tol() = 1.000000e-06!

Skipping adjoint check since op.opSupported(CONJTRANS)==false

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.242970e+01,1.590466e+01),(1.242970e+01,1.590467e+01)) = 3.809048e-07
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<Scalar>::check(...)

Starting CG solver ...

describe A:
  type = '18MPITridiagLinearOpISt7complexIfEE', rangeDim = 500, domainDim = 500

describe b:
  type = 'N5Thyra12MPIVectorStdISt7complexIfEEE', size = 500

describe x:
  type = 'N5Thyra12MPIVectorStdISt7complexIfEEE', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.721108e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 7.355135e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.733771e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 4.754171e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.684857e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 2.239717e-04
Iter = 208, ||b-A*x||/||b-A*x0|| = 9.721012e-05

||b-A*x||/||b|| = 1.887406e-03/1.800947e+01 = 1.048008e-04 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 3.020000e-01 sec

***
*** Running silly CG solver using scalar type = 'std::complex<double>' ...
***

Constructing tridiagonal matrix A of local dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Global dimension of A = 500

Testing the constructed linear operator A ...

*** Entering LinearOpTester<Scalar>::check(op,...) ...

op = 18MPITridiagLinearOpISt7complexIdEE

Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-9.677554e-01,6.222520e-01),(-9.677554e-01,6.222520e-01)) = 2.869021e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Skipping adjoint check since op.opSupported(CONJTRANS)==false

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.402400e+01,4.335187e+00),(1.402400e+01,4.335187e+00)) = 3.375439e-15
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<Scalar>::check(...)

Starting CG solver ...

describe A:
  type = '18MPITridiagLinearOpISt7complexIdEE', rangeDim = 500, domainDim = 500

describe b:
  type = 'N5Thyra12MPIVectorStdISt7complexIdEEE', size = 500

describe x:
  type = 'N5Thyra12MPIVectorStdISt7complexIdEEE', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.721187e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 7.355587e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.733925e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 4.754771e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.686419e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 2.240143e-04
Iter = 208, ||b-A*x||/||b-A*x0|| = 9.723106e-05

||b-A*x||/||b|| = 1.751081e-03/1.800948e+01 = 9.723106e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 3.110000e-01 sec

Congratulations! All of the tests checked out!

\endverbatim

This example program also takes a number of command-line options.  To
see what the command-line options are, use the <tt>--help</tt> option.
At the time of this writing, the command-line options returned from
<tt>./sillyCgSolve_mpi.exe --help</tt> are:

\verbatim

$ ./sillyCgSolve_mpi.exe --help
Usage: ./sillyCgSolve_mpi [options]
  options:
  --help                         Prints this help message
  --pause-for-debugging          Pauses for user input to allow attaching a debugger
  --verbose              bool    Determines if any output is printed or not.
  --quiet                        (default: --verbose)
  --local-dim            int     Local dimension of the linear system.
                                 (default: --local-dim=500)
  --diag-scale           double  Scaling of the diagonal to improve conditioning.
                                 (default: --diag-scale=1.001)
  --tol                  double  Relative tolerance for linear system solve.
                                 (default: --tol=0.0001)
  --max-num-iters        int     Maximum of CG iterations.
                                 (default: --max-num-iters=300)
\endverbatim

To see the full listing of this example program click: <a
href="sillyCgSolve__mpi_8cpp-example.html">
sillyCgSolve_mpi.cpp </a>

*/

/** \example sillyCgSolve_mpi.cpp

Click \ref Thyra_Op_Vec_examples_cg_MPI_grp "here" for a more
detailed discussion of this example program.

*/

//
// Misc examples
//

/** \defgroup Thyra_Op_Vec_product_vec_spc_prg_grp Testing Program for Composite Product VectorBase Spaces and Product Vectors

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__product__space_8cpp-example.html">
test_product_space.cpp </a>.

*/

/** \example test_product_space.cpp

Click \ref Thyra_Op_Vec_product_vec_spc_prg_grp "here" for a more
detailed discussion of this example/test program.

*/

/** \defgroup Thyra_Op_Vec_test_composite_linear_ops_grp Testing Program for Composite Linear Operators

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__composite__linear__ops_8cpp-example.html">
test_composite_linear_ops.cpp </a>.

*/

/** \example test_composite_linear_ops.cpp

*/

/** \defgroup Thyra_Op_Vec_test_std_ops_grp Testing Program for Standard Vector and Multi-Vector Reduction/Transformation Operators

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__std__ops_8cpp-example.html">
test_std_ops.cpp </a>.

*/

/** \example test_std_ops.cpp

*/

/** \defgroup Thyra_Op_Vec_test_scalar_product_prg_grp Testing Program for non-Euclidean Scalar Products

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__scalar__product_8cpp-example.html">
test_scalar_product.cpp </a>.

*/

/** \example test_scalar_product.cpp

Click \ref Thyra_Op_Vec_test_scalar_product_prg_grp "here" for a more
detailed discussion of this example/test program.

*/
