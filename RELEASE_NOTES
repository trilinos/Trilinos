###############################################################################
#                                                                             #
# Trilinos Release 9.0 Release Notes                                          #
#                                                                             #
###############################################################################

Overview:

The Trilinos Project is an effort to develop algorithms and enabling 
technologies within an object-oriented software framework for the solution of 
large-scale, complex multi-physics engineering and scientific problems. All 
packages are self-contained, with the Trilinos top layer providing a common 
look-and-feel and infrastructure.

Packages:

The version 9.0 general release contains 37 packages: Amesos, Anasazi, Aztecoo,
Belos, Didasko, Epetra, Epetraext, Fei*, Galeri, Ifpack, Isorropia, Kokkos,
Komplex, Loca, Meros, ML, Moertel, Moocho, New_Package, NOX, Pamgen*, Phalanx*,
PhdMesh*, Pliris, PyTrilinos, RTOp, Rythmos, Sacado, Stratimikos,
Sundance*, Teuchos, ThreadPool*, Thyra, Trilinoscouplings, Triutils,
WebTrilinos, and Zoltan*

(* denotes packages that are being released as a part of Trilinos for the
first time.)

The limited release contains an additional 4 packages that are available in
special situations by request. These are: Claps, Intrepid, RBGen, and Tpetra.

More information:

Trilinos website: http://trilinos.sandia.gov


===============================================================================

Package Release Notes:

-------------------------------------------------------------------------------

Amesos

(*) Amesos now includes Paraklete version 0.3.

(*) Amesos 2.4 in Trilinos 9.0 is compatible with Tim Davis' SuiteSparse
    version 3.0.0 (not the latest version).

(*) Known bug: Paraklete does not currently work on 64-bit machines.

-------------------------------------------------------------------------------

Anasazi

(*) The Anasazi package released in Trilinos 9.0 includes a new type of
    eigensolver.

(*) The IRTR solvers are implicit versions of the Riemannian Trust-Region
    eigensolvers (Absil, Baker, Gallivan 2007).

(*) Two implementations are provided, which balance computation/memory
    trade-offs via the ability to disable caching of operator applications.

-------------------------------------------------------------------------------

Epetra

Epetra support for PETSc matrices: The Epetra_PETScAIJMatrix class is a
lightweight wrapper class for encapsulating PETSc serial and parallel AIJ
matrices. Its intended audience is PETSc users who would like to build and
apply Trilinos preconditioners and solvers. This class derives from the
Epetra_RowMatrix class.

-------------------------------------------------------------------------------

Isorropia

Isorropia has expanded its scope from partitioning and load-balancing to
include other algorithms for combinatorial scientific computing. The primary
focus is still on partitioning and load-balancing of matrices and vectors.
Version 3.0 includes a significant code refactoring compared to earlier
versions to improve efficiency and robustness.

(*) Isorropia now depends on Zoltan, which is available as a package in
    Trilinos 9.0.  (Zoltan is automatically enabled by Isorropia.)

(*) The default partitioning method for sparse matrices is Zoltan's hypergraph
    partitioner, which is significantly better than the internal method.

(*) New features: Graph/matrix coloring and graph/matrix ordering (nested
    dissection).

(*) Redesign of the class structure to support new features. An
    Isorropia::Operator is the parent class of Partitioner, Colorer, and
    Orderer.

(*) Significant improvement in the efficiency (run time and memory usage) of
    redistributing Epetra matrices due to improved memory allocation.

(*) New redistribute_reverse() method in the Redistributor to support moving
    vectors back and forth between two distributions.

(*) When redistributing Epetra matrices, improved default choices for the maps.
    The call to FillComplete() is now optional, allowing the application to
    supply its own range and domain maps.

(*) Several minor changes in interface to enforce more consistent naming
    schemes, but version 3.0 is fully backwards compatible.

-------------------------------------------------------------------------------

Komplex

The Komplex package includes a new class that provide equivalent real
formulation capabilities to Epetra users called Komplex_LinearProblem.This is
the newest capability and should be used if at all possible.
Komplex_LinearProblem constructs an Epetra_LinearProblem from existing matrix
and coefficient data. A real matrix of twice the dimension of the original
complex-valued problem is explicitly constructed as an Epetra_CrsMatrix. Given
this matrix and the user-supplied RHS (and possibly an initial guess), the
Komplex_LinearProblem object is ready for use with any Trilinos solver and
preconditioner.

-------------------------------------------------------------------------------

ML

(*) New support for PETSc smoothers in the case when the fine grid matrix is
    really a PETSc data structure.  This is meant to be used in conjunction
    with the Epetra_PETScAIJMatrix class.

(*) New use of MPI subcommunicators for direct solves with KLU on the coarsest
    level.  This will mainly impact large scale simulations (>1K processors).

(*) New restart capability to ensure behavior can be reproduced exactly from
    solve to solve.

(*) New interfaces to Zoltan's hypergraph repartioning algorithms.

-------------------------------------------------------------------------------

MOOCHO

Mostly minor changes which include:

(*) Added response-only DiagonalQuadraticResponseOnlyOpt exampled based on an
    EpetraExt::ModelEvaluator.  This is to show users how to run MOOCHO on an
    unconstrained problem in parallel.

(*) Cleaned out some junk

-------------------------------------------------------------------------------

Phalanx

Phalanx is a local field evaluation kernel specifically designed for general
partial differential equation solvers.  The main goal of Phalanx is to
decompose a complex problem into a number of simpler problems with managed
dependencies to support rapid development and extensibility of the PDE code.
Through the use of template metaprogramming concepts, Phalanx supports
arbitrary user defined data types and evaluation types.  This allows for
unprecedented flexibility for direct integration with user applications and
provides extensive support for embedded technology such as automatic
differentiation for sensitivity analysis and uncertainty quantification.

-------------------------------------------------------------------------------

RTOp

Major refactoring of all code.

(*) All interfaces in rtop/src/interfaces are now "memory safe" using Teuchos
    memory management classes

(*) Support code in rtop/src/support has been significantly changed to remove
    duplication and bloat, provide for memory safely, and make it infinitely
    easier to create simple RTOp subclasses.

(*) All of the concrete RTOp classes in rtop/src/ops_lib have been updated.

(*) All of the simpler RTOps now use a simple set of macros and provide good
    examples for users on how to create their own RTOp classes.  This includes
    very detailed unit tests for all of the code.

(*) Old MPI junk that was not needed anymore was removed.

(*) Removed SUNDIAL RTOp subclasses since these are not being used and there
    was no unit tests for them.

With few exceptions, all changes should be backward compatible for clients of
the RTOpPack::RTOpT abstract interface (search for "deprecated" comments).

-------------------------------------------------------------------------------

Stratimikos

Mostly minor changes which include:

(*) Changed the name of Thyra::DefaultRealLinearSolverBuilder to
    Stratimikos::DefaultLinearSolverBuilder.

(*) Added some better unit tests, especially for adjoint solves.

-------------------------------------------------------------------------------

Teuchos

The Teuchos package released in Trilinos 9.0 has some additional tools to
assist users and developers with memory management and unit testing:

(*) Memory Management Classes:  The suite of debug-checking memory management
    classes has been extended to include the Ptr, ArrayView, and Tuple classes.
    Together with the existing classes RCP, ArrayRCP, and Array, these form a
    complete memory management system to replace all raw pointers to single
    objects and contiguous arrays of value-type objects in all
    application-level code.  For a few details on how these should be used, see:

     http://www.cs.sandia.gov/~rabartl/ThyraCodingGuideLines.pdf

(*) xUnit-like Unit Testing Infrastructure:  Full featured support for native
    unit testing has been developed.  See examples in teuchos/test/UnitTest.

-------------------------------------------------------------------------------

Thyra

(*) Added new templated Thyra::DefaultSerialDenseLinearOp[WithSolve]Factory
    subclasses to allow use of LAPACK for solving linear systems using
    Thyra::MultiVector objects as input.  This was mostly just to allow for
    better, more independent unit tests.

(*) Some refactorings to replace raw C++ pointers with safe Teuchos memory
    management classes (but a lot of work still needs to be done here)

(*) Removed the SUNDIALS RTOp wrappers since they no longer exist in RTOp

(*) Changed from Thyra::ETransp to Thyra::EOpTransp to avoid doxygen conflicts
    with Teuchos::ETransp.  A backward-compatible typedef to Thyra::ETransp
    still exists to not break existing external code.

With few exceptions, all changes should be backward compatible
(search for "deprecated" comments).

-------------------------------------------------------------------------------

Zoltan

The Zoltan Toolkit provides critical data-management services to a wide range
of parallel applications.  Zoltan includes many utilities needed by
unstructured and/or adaptive parallel applications. These utilities include

  (*) a suite of dynamic load-balancing and parallel partitioning tools
      (including geometric, hypergraph-based and graph-based algorithms) that
      distribute data over sets of processors for balanced computation
      with low interprocessor communication costs,
  (*) data migration tools that simplify movement of data to new parts,
  (*) parallel graph/matrix ordering algorithms for fill-reducing matrix
      ordering, including interfaces to PT-Scotch (LaBRI/INRIA-Bordeaux) and
      ParMETIS (U. Minnesota),
  (*) parallel graph coloring including distance-1 and distance-2 coloring,
  (*) distributed data directories that efficiently locate off-processor data,
      and
  (*) an unstructured communication package that greatly simplifies
      interprocessor communication.

Zoltan's native interface is object-oriented and easy-to-use;
it enables Zoltan to be used by a wide range of different applications.
Zoltan is designed to be flexible and extensible, so different algorithms
can be used, compared and added easily.
Zoltan has been used in particle simulations, finite element methods with
adaptive mesh refinement, linear solvers and preconditioners, circuit
simulations, crash simulations and contact detection, and
biological cell simulations.

The Zoltan toolkit was first released in 2001; this release is Zoltan v3.1.
New features in Zoltan v3.1 include
  (*) Graph/Matrix ordering interface to PT-Scotch, a high-quality graph
      ordering and partitioning library from LaBRI/INRIA-Bordeaux;
  (*) New matrix ordering interface that returns ordering information such as
      permutations and separators to the application;
  (*) New hypergraph partitioning options for inexpensively refining
      partitions;
  (*) Robustness improvements to Zoltan's parallel hypergraph partitioner and
      repartitioner;
  (*) New Autotools build environment;
  (*) Serial, non-MPI builds enabled through the Autotools build environment;
      and
  (*) Tight integration with the Trilinos project, including Trilinos package
      Isorropia, a matrix-based interface to Zoltan.

Many applications use both Zoltan and Trilinos.  Zoltan's
inclusion in Trilinos simplifies the configuration and build process for
those applications.  It also enables tighter coupling between Trilinos
packages that use Zoltan, such as the Isorropia package of Epetra-based
interfaces to Zoltan's partitioning, ordering and coloring capabilities.

Zoltan can still be built as a stand-alone toolkit separate from Trilinos,
as backward compatibility with previous Zoltan releases has been maintained.

Please visit the Zoltan Home Page (http://www.cs.sandia.gov/Zoltan) for
more information on Zoltan.

-------------------------------------------------------------------------------

###############################################################################
#                                                                             #
# Trilinos Release 8.0 Release Notes                                          #
#                                                                             #
###############################################################################

Overview:

Trilinos is a collection of compatible software packages that support parallel 
linear algebra computations, solution of linear, non-linear and eigen systems 
of equations and related capabilities. The majority of packages are written in 
C++ using object-oriented techniques. All packages are self-contained, with the 
Trilinos top layer providing a common look-and-feel and infrastructure. 

Packages:

The version 8.0 general release contains 30 packages: Amesos, Anasazi, AztecOO,
Belos, Didasko, Epetra, EpetraExt, Galeri, IFPACK, Isorropia, Kokkos, Komplex,
LOCA, Meros, ML, Moertel, MOOCHO, New_Package, NOX, Pliris, PyTrilinos, RTOp,
Rythmos, Sacado, Stratimikos, Teuchos, Thyra, Triutils, TrilinosCouplings, and
WebTrilinos.

The limited release contains an additional 2 packages that are available in 
special situations by request. These are: Claps and Tpetra.

In addition to many new features across most packages, Trilinos Release 8.0
contains 3 packages that are being released for the first time:

- Belos (Next-generation iterative solvers)
- Sacado (Automatic differentiation)
- TrilinosCouplings (Select trilinos package interfaces)

Package-specific features for these new packages, as well as many of
the other packages are listed below.

More information:

Trilinos website: http://trilinos.sandia.gov

===============================================================================

New Make Targets

Trilinos now supports a large set of make targets.  Prior to Trilinos 8.0,
"make" built libraries, tests, and examples.  Starting with Trilinos 8.0,
"make" builds only libraries.  Tests can be compiled using "make tests", and
examples using "make examples".  To build libraries, tests, and examples, the
"make everything" make target can be used.  Below is a listing of new and
modified make targets that will be most useful to users:

make - Builds just the libraries
make install - Installs just the libraries
make examples - Makes just the examples (assumes libraries are built)
make install-examples - Install the examples (assumes libraries are installed)
make tests - Makes just the tests (assumes libraries are built)
make everything - Builds libraries, tests, and examples
make install-everything - Installs libraries and examples

===============================================================================

Shared Libraries

- There is now rudimentary, experimental support for shared libraries
  under Linux and Mac OS X.  Shared versions of Trilinos libraries are
  now required for the PyTrilinos package, so this is where the shared
  libraries are built.  However, it is not necessary to enable the
  PyTrilinos package to build the shared libraries.  Also, shared
  libraries are built for ALL enabled packages, not just those with
  python interfaces.  To enable shared libraries without enabling
  PyTrilinos, use the configuration option

    --enable-shared

  Note that the build system for building shared libraries employs
  python, so this must be installed.  However, the other PyTrilinos
  prerequisites -- swig and numpy -- are not required for building
  shared libraries.  The resulting shared libraries are stored in your
  build directory in the sub-directory

    packages/PyTrilinos/shared

  and are installed in the same directory in which the static
  libraries are installed.  Note that these shared libraries are
  considered EXPERIMENTAL.  Only those shared libraries that are
  linked to PyTrilinos extension modules get tested.  The other shared
  libraries might possibly have unresolved symbols.  Please report any
  problems.

- To get shared libraries to work, it may be necessary to manually add
  position-independent code options to the compiler flag variables.
  This is not necessary on Mac OS X or some flavors of Linux, because
  position-independent code is the default.  However, on those Linux
  versions for which this is not the default, and on 64-bit systems,
  you will need to add these compiler options.  For example, if the
  proper option for your compiler for position-independent code is
  "-fPIC", then your configuration invocation should include

    FFLAGS=-fPIC CFLAGS=-fPIC CXXFLAGS=-fPIC

  There is a standing feature request that this be done automatically,
  but it has not been implemented yet.

===============================================================================

Package Release Notes:

-------------------------------------------------------------------------------

Amesos

- KLU and BTF have been upgraded to version 1.0.

-------------------------------------------------------------------------------

Belos

The Trilinos 8.0 release will contain the first public release of the Belos
iterative linear solver package.  Belos provides next-generation iterative
linear solvers and a powerful linear solver developer framework.  This
framework includes

- Abstract interfaces to linear algebra allowing the user to leverage any
  existing investment in their description of matrices and vectors.  Linear
  algebra adapters are included for Epetra and Thyra.

- Abstract interfaces to orthogonalization; implementations of iterated
  classical Gram-Schmidt (ICGS), classical Gram-Schmidt with a DGKS correction
  step, and iterated modified Gram-Schmidt (IMGS) are included.

- Abstract interfaces to iteration kernels; implementations of conjugate
  gradient (CG), block CG, block GMRES, pseudo-block GMRES, block flexible
  GMRES, and GCRO-DR iterations are included.

- Powerful solver managers are provided for solving a linear system using CG
  or block CG, GMRES or block GMRES with restarting, pseudo-block GMRES for
  performing single-vector GMRES simultaneously on multiple right-hand sides,
  and a single-vector recycled Krylov method (GCRO-DR).

- Basic linear problem class is provided for the user to define a
  unpreconditioned or preconditioned (left, right, two-sided) linear system for
  Belos to solve.

- Many examples for solving unpreconditioned, preconditioned linear systems
  with one or multiple right-hand sides using all the Belos solver managers.

-------------------------------------------------------------------------------

Epetra

- Epetra contains a new class called Epetra_VbrRowMatrix that completely
  supports the use of an existing Epetra_VbrMatrix object via the
  Epetra_RowMatrix interface. This new class addresses the fact that it is
  impossible to fully support Epetra_RowMatrix directly with Epetra_VbrMatrix
  (having Epetra_VbrMatrix inherit from Epetra_RowMatrix), so this new class
  should be used.

-------------------------------------------------------------------------------

Moocho

- Miscellaneous improvements for Thyra support.

-------------------------------------------------------------------------------

Pliris

- A problem with a large number of multiple Right Hand Sides has been addressed
  and a fix implemented.

-------------------------------------------------------------------------------

PyTrilinos

- PyTrilinos is now a single, self-contained package again.  For the
  most part, this affects developers more than users, with one
  exception.  The PyTrilinos package is enabled with the configuration
  option

    --enable-pytrilinos

  rather than the previous option, --enable-python, which had the
  effect of enabling python support within each package that provided
  wrappers.  Individual PyTrilinos package wrappers can be enabled or
  disabled with

    --enable-pytrilinos-package
    --disable-pytrilinos-package

  where "package" refers to a specific Trilinos package.

-------------------------------------------------------------------------------

Sacado

Sacado is a set of automatic differentiation tools for C++ applications. It
provides templated classes for forward, reverse and Taylor mode automatic
differentiation.

Sacado contains several basic AD classes:

  * Forward mode AD with the number of derivative components chosen at
    run-time: Sacado::Fad::DFad (most flexible)
  * Forward mode AD with the number of derivative components chosen at
    compile-time: Sacado::Fad::SFad (most efficient)
  * Forward mode AD with the maximum number of derivative components chosen
    at compile-time but actual number used chosen at run-time:
    Sacado::Fad::SLFad (sits between Sacado::Fad::DFad and Sacado::Fad::SFad
    in flexibility and efficiency)
  * Reverse mode: Sacado::Rad::ADvar
  * High-order univariate Taylor polynomials: Sacado::Tay::Taylor

-------------------------------------------------------------------------------

Stratimikos

- New Belos wrappers (Belos released for first time in Trilinos 8.0)

-------------------------------------------------------------------------------

Teuchos

- Name change from Teuchos::RefCountPtr to Teuchos::RCP

  The name of the class Teuchos::RefCountPtr has been changed to Teuchos::RCP
  and the file Teuchos_RefCountPtr.hpp is not Teuchos_RCP.hpp.  You can update
  all of you C++ code automatically and safely using the script:

    Trilinos/packages/teuchos/refactoring/change-RefCountPtr-to-RCP-20070619.sh

  Please see the header of this script for instructions.

  If you choose not to refactor your code (e.g. by running the above script on
  it) then you can take your chances and just include the backward
  compatibility file Teuchos_RefCountPtr.hpp.  However, this is *not*
  recommended because this file uses a terrible macro that is dangerous to
  have.

- Improved parameter validation support 

-------------------------------------------------------------------------------

Thyra

- Improved support for implicit linear operators with object labels and other
  improvements

- Various miscellaneous improvements and additions

-------------------------------------------------------------------------------

TrilinosCouplings

TrilinosCouplings is a new package that was created as a place to put select
interfaces between Trilinos packages.  The code for the Trilinos 8.0 release
was all taken from existing packages.  Currently there is code for interfaces
between Ifpack and ML, and ML and NOX.

-------------------------------------------------------------------------------

The following packages did not report any significant feature updates for
Trilinos 8.0:

  Anasazi, Aztecoo, Didasko, EpetraExt, Galeri, Ifpack, Isorropia, Kokkos,
  Komplex, LOCA, Meros, ML, Moertel, New_Package, NOX, RTOp, Rythmos,
  TriUtils, WebTrilinos

===============================================================================

Known Issues

- Sacado does not build on the Sun platform with no known workaround.  See
  bugzilla bug 3586 for more information.

- The test for TrilinosCouplings is currently not functioning.  Changes need to
  be made to the configuration for the package to fix this issue.  We plan to
  address this in one of the first release updates.  On many machines this test
  will fail in mpi, in other cases, the test will simply output a message and
  exit.

- We are aware of a number of other minor, platform-specific test failures:

    Linux (mpi):
        Anasazi             BlockDavidson_test.exe (12 processors)
        PyTrilinos          exMLAPI_Simple.p
        PyTrilinos          exMLAPI_Smoother.py
        PyTrilinos          testML_Preconditioner.py
        TrilinosCouplings   ml_nox_1Delasticity_example.exe
    Linux (serial):
        Belos               gcrodr_hb.exe
        PyTrilinos          exAztecOO_RowMatrix.py
        PyTrilinos          exNOX_1Dfem.py
        Rythmos             basicExample_amesos.exe
    Mac (mpi):
        Meros               testEpetraThyra.exe
        ML                  ml_user_smoothing.exe
    Mac (serial):
        Meros               testEpetraThyra.exe


###############################################################################
#                                                                             #
# Trilinos Release 7.0 Release Notes                                          #
#                                                                             #
###############################################################################

Overview:

Trilinos is a collection of compatible software packages that support parallel 
linear algebra computations, solution of linear, non-linear and eigen systems 
of equations and related capabilities. The majority of packages are written in 
C++ using object-oriented techniques. All packages are self-contained, with the 
Trilinos top layer providing a common look-and-feel and infrastructure. 

Packages:

The version 7.0 general release contains 27 packages: Amesos, Anasazi, AztecOO, 
Didasko, Epetra, EpetraExt, Galeri, IFPACK, Isorropia, Kokkos, Komplex, LOCA,
Meros, Moertel, MOOCHO, ML, New_Package, NOX, Pliris, PyTrilinos, RTOp,
Rythmos, Stratimikos, Teuchos, Thyra, Triutils, and WebTrilinos.

The limited release contains an additional 5 packages that are available in 
special situations by request. These are: Belos, Capo, Claps, Jpetra, and
Tpetra.

In addition to many new features across most packages, Trilinos Release 7.0
contains nine packages that are being released for the first time:

- Galeri (distributed linear system generation)
- Isorropia (repartitioning and rebalancing)
- Meros (segregated preconditioning)
- Moertel (Mortar methods)
- MOOCHO (Multifunctional Object-Oriented arCHitecture for Optimization)
- RTOp (reduction/transformation operators)
- Rythmos (transient integrator for ordinary differential equations and
  differential-algebraic equations)
- Stratimikos (unified set of Thyra-based wrappers to linear solver and
  preconditioner capabilities)
- WebTrilinos (web-based interface to some Trilinos packages - must be set up
  on a user's server/machine)

Package-specific features for these new packages, as well as many of
the other packages are listed below.

More information:

Trilinos website: http://software.sandia.gov/trilinos 

===============================================================================

External Package Capability

The "external" Trilinos package makes it easy add additional packages that are
external to Trilinos to the Trilinos build process.  Users who develop
additional capabilities on top of and outside of Trilinos may find this tool
useful for simplifying their Trilinos interface.  Packages that utilize this
tool can easily be added to a user's existing set of Trilinos packages.

Instructions for using the external package capability can be found in the
Trilinos tarball in packages/external/README or on the web at
http://software.sandia.gov/trilinos/external.html.

===============================================================================

Amesos

- Cleaned the MUMPS interface. Improved memory management by using smart
  pointers. Dropped the not-so-well-tested single-precision MUMPS. Improved
  passing of CNTL and ICNTL through the parameter list.

- Increases the performances of the UMFPACK interface by a factor of at least
  2. This means that the time requires by the Amesos wrappers is reduced by
  2 -- the time required by UMFPACK still is unaffected.

- Added to (almost) all classes profiling to evaluate how much time is spent
  in the amesos wrappers (that is, without considering any of the time spent
  in the called solver). This time is printed on screen when PrintTiming() is
  called.

Amesos/Thyra adapters:

What’s New:

- Timing and output tracing:  The Teuchos::TimeMonitor class has been
  incorporated to time the various factorization and solve operations and
  produce profiler-like output.  In addition, the Teuchos::VerboseObject
  interface is now supported which allows some informational outputting to be
  sent to a configurable output stream.

Known issues:

- Incomplete parameter validation and inconsistent use of parameter lists:
  Currently, parameters not specified in the input parameter list are not
  appended with the default values and all parameters and sublists are not
  fully validated.  This is an issue that needs to be resolved in the core
  Amesos source code.

-------------------------------------------------------------------------------

Anasazi

In Trilinos Release 7.0, the Anasazi eigensolver framework has been
considerably refactored to provide simpler user interfaces as well as
powerful eigensolver developer interfaces.

- This release provides simpler user interfaces, called solver managers,
  for three eigensolvers:  block Davidson, block Krylov-Schur, and
  locally-optimal block preconditioned conjugate gradient (LOBPCG).

- Powerful lower-level interfaces are provided for each eigensolver,
  enabling the expert user to specialize their own solver manager.

- Status test mechanisms have been incorporated into the Anasazi framework
  to give the user and solver manager the flexibility to direct the behavior
  of the eigensolver.

- The Anasazi::OrthoManager provides the eigensolver with an abstract
  interface to orthogonalization and orthonormalization.  This enables the
  user to specialize their own orthogonalization/orthonormalization if those
  already provided in Anasazi (CGS w/ iterative refinement or SVQB) are not
  sufficient.
   
- Interfaces to linear algebra are provided through the templated traits
  classes:  Anasazi::MultiVecTraits and Anasazi::OperatorTraits.  These
  classes have template specializations for Epetra and Thyra.  Testing
  functionality is also provided for user-written template specializations
  via the Anasazi::TestMultiVecTraits() and Anasazi::TestOperatorTraits()
  functions.

- All Trilinos web documentation and Didasko tutorial have been updated to
  reflect the changes in the Anasazi framework.

-------------------------------------------------------------------------------

AztecOO 3.5

- Additional scaling capabilities.

- Improved I/O control.

- Numerous small "hardening" changes.

AztecOO/Thyra Adapters:

What’s New:

- Timing and output tracing:  The Teuchos::TimeMonitor class has been
  incorporated to time the various setup and solve operations and produce
  profiler-like output.  In addition, the Teuchos::VerboseObject interface is
  now supported which allows some informational outputting to be sent to a
  configurable output.

- Acceptance of external preconditioner factory object:  The AztecOO/Thyra
  adapters now except an external preconditioner factory object to create
  preconditioners.  This allows Ifpack, ML, and Meros preconditioners to all be
  used in a seamless way.  Any other compatible preconditioner can also be
  supported as well.

- General Thyra operator support: Any general Thyra linear operator can now be
  supported including implementations based on product vector spaces.  To be
  effective, an appropriate preconditioner factory must also be set to create a
  preconditioner.  This is used in Meros to allow AztecOO to be used with the
  segregated block preconditioners.

-------------------------------------------------------------------------------

Didasko

- No significant changes.

-------------------------------------------------------------------------------

Epetra 3.5

- New Epetra_BasicRowMatrix class: Facilitates easy development of
  user-defined adapters for the Epetra_RowMatrix interface.  Greatly reduces
  the number of methods that must be be implemented.

- New Epetra_JadMatrix class (which supercedes Epetra_JadOperator).  This
  classes accepts an existing Epetra_RowMatrix object and creates an
  Epetra_JadMatrix object.  The Epetra_JadMatrix object uses the so-called
  jagged diagonal data structure to store the sparsematrix coefficients in a
  format especially suitable for vector processors.  Once constructed, the
  JadMatrix object can be used with any Trilinos package that requires an
  Epetra_RowMatrix or Epetra_Operator object.  This implementation also
  contains special Cray compiler directives (_Pragma "ivdep") to force optimal
  vectorization.

- New Epetra_InvOperator class.  A simple class that interprets an existing
  Epetra_Operator as an inverse operator.

- New method for Epetra Map and BlockMap objects to cheaply test if a map
  has 1-to-1 (uniquely-owned) global IDs:  This method facilitates easy
  testing for whether or not a particular map can be used as an input
  argument to functions that require the map to have uniquely-owned global
  IDs.

- New function called Create_OneToOne_Map in Epetra_Util namespace that
  creates an Epetra_Map with unique global IDs from an existing Epetra_Map
  that may or may not have unique global IDs.

- New function called Create_OneToOne_BlockMap in Epetra_Util namespace that
  creates an Epetra_BlockMap with unique global IDs from an existing
  Epetra_BlockMap that may or may not have unique global IDs.

- New function called Create_Root_Map in Epetra_Util namespace that creates
  an Epetra_Map from an existing Epetra_Map such that all global IDs are
  collected to the specified root processor and all other processors own
  no global IDs.

- New method to compute the Frobenius norm of an Epetra_CrsMatrix or
  Epetra_VbrMatrix object.

- Debugging code in Epetra_CrsMatrix to support detailed printing of
  intermediate matrix-vector multiplication information.  This code is
  compiled if  EPETRA_CRS_MATRIX_TRACE_DUMP_MULTIPLY is defined at compile
  time.

Epetra/Thyra adapters:

What’s New:

- Refactored for new SPMD classes:  The “fake” Epetra/Thyra adapters have been
  updated for the new Thyra SPMD support software.  The names of the conversion
  functions in Thyra_EpetraThyraWrappers.hpp have also be simplified.

-------------------------------------------------------------------------------

EpetraExt 3.5

- New class EpetraExt_ProductOperator: Supports implicit composition of
  multiple Epetra_Operator objects to act as a single operator.

- New class EpetraExt_BlockCrsMatrix: Supports aggregation of multiple
  Epetra_CrsMatrix as sub-matrix objects to act as a single matrix.

- New class EpetraExt_MultiMpiComm: Supports two-level communication where
  each processor is part of the global communicator and a sum-domain
  communicator.

- EpetraExt_MatrixMatrix performance improvements:  Substantial improvments to
  sparse matrix time sparse matrix multiplication for most cases.

- InOut facilities: Substantial improvement to input and output functions that
  read and write matrix and vector objects to and from files.  Added simplified
  interfaces that allow distributed matrix construction without requiring the
  user to define Epetra_Maps.  Added support to write the implied matrix
  coefficients of an Epetra_Operator.  Added support for HDF5 and XML formatted
  files.

- ModelEvaluator: New capabilities to support generic solution interfaces for
  linear and non-linear systems via Thyra.

EpetraExt/Thyra adapters:

What’s New:

- Thyra::EpetraModelEvaluator:  This class wraps an EpetraExt::ModelEvaluator
  object (which deals only in Epetra-based objects) and provides an
  implementation of the Thyra::ModelEvaluator interface strictly in terms of
  abstract Thyra objects.  Any linear solver and preconditioner can be
  supported by configuring a EpetraExt::ModelEvaluator object with a compatible
  linear solver factory object.

-------------------------------------------------------------------------------

Galeri (new)

Understanding, validating, using and developing algorithms and software tools
for distributed linear algebra solvers, like Krylov accelerators and
preconditioners, requires input data. This data should have three critical
properties:

   1. reflect real-life applications to a sufficient extent so that we can use 
      them to predict performance;
   2. be sufficiently simple to be amenable to mathematical analysis;
   3. it is possible to write generators that easily provide instances of
      these problems. 

The goal of the Galeri package is exactly to produce these input data for
linear solvers.

As regards real-life applications, we have here selected PDE-type problems.
Although Galeri can generate some non-PDE linear systems, surely there is a
strong focus on PDE applications. Among them, the Laplace problem is probably
the most widely studied application, and a broad range of results are
available. For most solvers and preconditioners, often there is a sharp
convergence bound that can be used to validate a particular class, or to get a
sense of the performances of a new method. A Trilinos package that uses Galeri
is the MatrixPortal module of WebTrilinos.

Galeri's Matrix generation capabilities can help to make examples shorter and
easier to read, since they can produce challenging linear systems in a few code
lines. Therefore, the attention of the example's reader is not distracted by
complicated instructions aiming to build this or that linear system. Since most
linear algebra packages of Trilinos use Galeri, users will quickly become
familiar with it. Galeri is used in the examples of the Amesos, IFPACK, and ML
packages. For more details, please check the Galeri web page
(http://software.sandia.gov/trilinos/packages/galeri).

-------------------------------------------------------------------------------

Ifpack 3.1

- New class Ifpack_Chebyshev: Chebyshev polynomial preconditioner.

- New class Ifpack_DiagPreconditioner: Simplifies construction and use of
  diagonal preconditioners.

- New functionality to test if Teuchos ParameterList values are valid for
  Ifpack preconditioner.

- Changed the hash table class for ICT and ILUT. The latter is then much faster
  than the previous version. The new class has a better memory usage and it is
  simpler to modify and extend.

- Fixed a few memory leaks in the ILU factorization class.

- Added Chebyshev preconditioner with point diagonal scaling.

- Added support for UseTranspose(true) in Ifpack_AdditiveSchwarz, Ifpack_ILUT
  and Ifpack_Amesos.

Ifpack/Thyra adapters:

Thyra preconditioner factory adapters for Ifpack are new for this release.

Known issues:

- Incomplete parameter validation and inconsistent use of parameter lists:
  Currently, parameters not specified in the input parameter list are not
  appended with the default values and all parameters and sublists are not
  fully validated.  This is an issue that needs to be resolved in the core
  Ifpack source code.

-------------------------------------------------------------------------------

Isorropia 1.0 (new)

- initial release, version 1.0

- Isorropia is a Trilinos interface to Zoltan repartitioning/balancing
  capabilities

- requires Zoltan version 2

- several example programs illustrate usage

- doxygen documentation on Trilinos website

-------------------------------------------------------------------------------

Kokkos 1.1

- New experimental interface to OSKI optimized kernels.

-------------------------------------------------------------------------------

Komplex 1.1

- No significant changes.

-------------------------------------------------------------------------------

LOCA

- Many of the internals of LOCA have been rewritten to more fully support
  multi-parameter continuation, constraint tracking, higher-order predictors
  and advanced bifurcation algorithms. The old framework has been completely
  removed, and therefore all users must upgrade their interface to the new
  framework. For a brief description of the new framework, see the New LOCA
  Framework page. In addition, some of the parameter list entries that control
  LOCA have changed. See the LOCA Parameter Reference Page for a description of
  the new parameter list structure.

- A minimally augmented turning point formulation has been added to LOCA. This
  method appears to be significantly faster and more robust than the turning
  point methods based on the Moore-Spence formulation.

- A modified pitchfork bordering method has been added to LOCA, which is
  similar to the modified turning point method already available. This method
  avoids the singular matrix solves in the original pitchfork bordering method.

- Parallel and serial Hopf support has been added to LOCA.

-------------------------------------------------------------------------------

Meros 1.0 (new) 

Meros is a segregated preconditioning package. It provides scalable block
preconditioning for problems that couple simultaneous solution variables such
as Navier-Strokes problems.

The source documentation can be found on the Meros web page:
http://software.sandia.gov/Trilinos/packages/meros/

For more information, see Trilinos/packages/meros/README-MEROS

-------------------------------------------------------------------------------

ML

ML/Thyra Adapters:

Thyra preconditioner factory adapters for ML are new for this release.

Known issues:

- Incomplete parameter validation, inconsistent use of parameter lists, non-XML
  compatible parameters:  Currently, parameters not specified in the input
  parameter list are not appended with the default values and all parameters
  and sublists are not fully validated.   In addition, many of the ML
  parameters can not be read in from an XML file.  For example, the parameters
  that control AztecOO from ML can not be directly read in from an XML file.
  These are issues that need to be resolved in the core ML source code.

-------------------------------------------------------------------------------

Moertel (new)

- Supplies capabilities for nonconforming mesh tying and contact formulations
  in 2 and 3 dimensions using Mortar methods.

- Uses dual and standard Mortar methods to construct Lagrange multiplier
  constraints for nonconforming interfaces.

- Serves as a programming language for other types of mesh tying approaches.

-------------------------------------------------------------------------------

MOOCHO (new)

MOOCHO is collection of software for the solution of large-scale
simulation-constrained optimization problems using primarily reduced-space
successive quadratic programming algorithms.

Known issues:

- Incomplete support for all Thyra::ModelEvaluator options:  All of the bells
  and whistles for the different possible modes for simulation-constrained
  optimization through the Thyra::ModelEvaluator classes are not yet in place.
  Right now, the code handles the cases of exact direct sensitivities, finite
  difference direct sensitivities and adjoint sensitivities with some caveats.
  For example, even through the direct sensitivity method only requires the
  application of the operator DgDx (ModelEvaluator notation) onto vectors, the
  current implementation requires that a vector for transpose(DgDx ) be
  explicitly returned.  In the next release of Trilinos, all modes should be
  fully supported without imposing undue requirements on the application.

- Outdated linear algebra and model interfaces:  MOOCHO currently uses its own
  linear algebra layer called AbstractLinAlgPack that actually predates (and
  helped to inspire) Thyra.  In the next release, it is highly possible that
  MOOCHO will be refactored to use a linear algebra layer based directly on
  Thyra and perhaps the new Thyra handle layer which will help to help other
  Trilinos developers to be able to understand and develop algorithms in
  MOOCHO.  This refactoring is also likely to radically change the NLP
  interfaces to move to a single ModelEvaluator-like interface that will allow
  for faster prototyping of new optimization algorithms.

-------------------------------------------------------------------------------

New_Package

- No significant changes.

-------------------------------------------------------------------------------

NOX

- NOX is now using reference counted smart pointers (RCPs) for memory
  management. Passing an RCP wrapped object through a method call implies a
  persisting relationship. We are using the Teuchos::RefCountPtr object for
  the RCP.

- The NOX::Parameter::List has been removed. We are now using the
  Teuchos::ParameterList object. This has the same functionality with minor
  changes to the syntax of method calls.

- NOX now has a non-optional dependency on the Teuchos package (also part of
  Trilinos). While it can be built stand-alone, we recomend building NOX as
  part of Trilinos with the teuchos library enabled to simplify dependencies.

- NOX and LOCA now generate Makefiles that users can include in their own
  makefiles to get all dependencies correct. For example if NOX is built with
  Epetra support enabled, nox depends on epetra, aztecoo and ifpack headers and
  libraries. To keep the user from having to learn about those packages so they
  can link nox into their codes, just include the NOX file Makefile.export.nox
  file to get variables that have all sub package dependencies correct. In the
  installation directory, look at the files include/Makefiles.export.nox and
  include/Makefiles.export.nox.macros. The important flags in
  Makefile.export.nox are NOX_INCLUDES, NOX_LIBS, LOCA_INCLUDES, and LOCA_LIBS
  flags. The Makefile.export.nmox.macros file contains the compiler flags that
  were used to build the NOX and LOCA packages. It is very important to use
  consistent flags when linking your application against Trilinos.

- Multivector support is no longer a configure option, but is automatically
  built as part of the library.

- The epetra interfaces (NOX::Epetra::Interface namespace) have been changed.
  They now take an Epetra_Operator as an argument when evaluating the Jacobian
  and preconditioner objects. While this is redundant for our base epetra group
  (since it shares the same operator between groups), this allows users to
  override the eptra group and use separate operators for each group if
  desired.

- There are 2 options for creating an Ifpack preconditioners. The original code
  where the "Preconditioner" option in the "Linear Solver" sublist was set to
  "Ifpack" and the new ifpack code "New Ifpack". The original option explicitly
  constructs an ifpack ilu object that has since been deprecated and will most
  likely be removed in the next release (Trilinos 8.0). The option "New Ifpack"
  uses the new ifpack factory object. You can now create a parameter list that
  directly uses the ifpack factory arguments and can create any ifpack
  preconditioner (not limited to ILU). We recommend switching to the "New
  Ifpack" preconditionerr interface asap.

- In the epetra support, the preconditioner options "AztecOO", "New Ifpack",
  and "ML" allow users to recompute the preconditioner using the same graph so
  that preconditioner memory is not allocated and destroyed each linear solve.
  The new "Linear Solver" sublist key is "Preconditioner Reuse Policy" with the
  possible values "Rebuild", "Reuse", and "Recompute". If you choose "Rebuild",
  this is what nox has done in previous releases - destroy, reallocate and
  recompute the preconditioner for each linear solve. "Reuse" wil use the same
  preconditioner for every linear solve. "Recompute" will recompute the
  preconditioner, but will try to efficiently reuse any objects that don't need
  to be destroyed. How efficient the "Recompute" option is depends on the type
  of preconditioner. For example if we are using ILU in Ifpack, the graph that
  is allocated does not need to be destroyed and recomputed even though the
  computation will recompute the factorization when the matrix changes. These
  changes support native Aztec, Ifpack and ML preconditioners. 

-------------------------------------------------------------------------------

Pliris 1.1

- Added a new method - Solve.  This allows a user to split the factor and solve
  for a dense matrix.  This is useful when the right hand side is changing in
  the numerical simulation.

- A test case has been added to test this functionality. 

-------------------------------------------------------------------------------

PyTrilinos 3.0

PyTrilinos 3.0 is a significant structural change from version 2.0,
although most of these changes will be invisible to the typical user.
"PyTrilinos" used to refer to both a python package (here using the
python definition of package, meaning "a module of modules") and to a
small Trilinos package (here using the Trilinos definition of package,
meaning a set of one or more related compiled libraries) of utility
classes that helped to enable the python modules.

The classes that used to comprise the PyTrilinos library have either
been eliminated or moved to other Trilinos packages.  The PyTrilinos
Trilinos package now serves to enable certain cleanup functions.  The
most important of these is to fix a problem seen with MPI builds,
where bad_cast exceptions can be raised because the python extension
modules are linked to static libraries.

If you are building Trilinos on Linux or Mac OS X and have enabled
both python and MPI, the PyTrilinos package will go back and create
dynamic versions of various Trilinos libraries (e.g., libepetra.so).
These get stored in your build directory under

    packages/PyTrilinos/src

PyTrilinos then goes back again and re-links the python extension
modules (e.g. _Epetra.so) to these new dynamic libraries.  This has
eliminated several (but not all) problems seen when running PyTrilinos
scripts in parallel.

Note that if you wish to run python test scripts *prior* to installing
Trilinos, you need to tell your shell how to find the dynamic
libraries.  You do this by setting an environment variable, either

    LD_LIBRARY_PATH, or
    DYLD_LIBRARY_PATH

for Linux and Mac OS X respectively, to include the directory that
contains the dynamic libraries.  When you invoke mpirun, you must
export this environment variable.  For example,

    mpirun -x LD_LIBRARY_PATH -np 4 testVector.py -t

When you run "make install", the dynamic libraries will get installed
as well.  Depending on where you specify installation, this may
eliminate the need to specify and export these environment variables.

                         --------------------                         

Several other changes have been made since PyTrilinos 2.0/Trilinos 6.0:

* As the first part of these release notes indicate, MPI is explicitly
  supported.  This support was considered "experimental" in PyTrilinos
  2.0.

* The build process has been significantly improved.  PyTrilinos now
  uses the export Makefiles that are supported by many Trilinos
  packages, and this has greatly helped in using accurate lists of
  include paths, library paths and libraries.  Furthermore, the
  PyTrilinos build system now parses Makefiles directly to obtain the
  values of user-configured variables, eliminating another source of
  build error.

* NumPy support.  PyTrilinos has been upgraded from compatibility with
  the now-obsolete Numeric module to its successor, NumPy.  As of this
  writing, NumPy is in beta testing for release 1.0.  PyTrilinos is
  compatible with NumPy 0.9.6 and 0.9.8, and has been tested against
  NumPy 1.0b, versions 2 and 4.

* Much focus has been placed on improving the Epetra module.
  Previously, many Epetra class methods were wrapped, but if they had
  pointers in the argument list representing C arrays, these methods
  could not actually be used in python.  A large percentage of these
  methods have been updated.  Any python sequence can be used in place
  of input array arguments, and NumPy arrays are returned for output
  arrays.

* More Epetra array-like classes now doubly-inherit from NumPy arrays.
  These classes are:

    + Epetra.IntSerialDenseMatrix
    + Epetra.IntSerialDenseVector
    + Epetra.IntVector
    + Epetra.MultiVector
    + Epetra.SerialDenseMatrix
    + Epetra.SerialDenseVector
    + Epetra.Vector

  When you instantiate one of these classes, the resulting object can
  also be treated as and will be recognized as a NumPy array.  This
  creates a high-degree of compatibility with other python packages,
  such as SciPy, matplotlib, etc.

* Exception handling added.  Not all cases are yet handled, but many
  of the common ones are, and an infrastructure is in place for
  PyTrilinos developers to convert C++ exceptions into python
  exceptions.

* The Teuchos module has been added and ParameterLists are explicitly
  handled now, but python dictionaries can be used in their place.
  Also, nested dictionaries are now recognized as sub-lists, greatly
  increasing the usefulness of this feature.

* The Galeri module has been added.

* For Trilinos release 7.0, the NOX module has been disabled.  We have
  been unable to keep up with the significant changes made in the NOX
  package, but we are working on it.  Hopefully, this module will be
  re-enabled in a minor future update, 7.0.x.

* Documentation has been expanded.  The documentation section of the
  PyTrilinos web site now covers prerequisites, build notes and has an
  individual page for each module covering differences between the C++
  and python interfaces.

-------------------------------------------------------------------------------

RTOp (new)

RTOp (reduction/transformation operators) provides the basic mechanism
for implementing vector operations in a flexible and efficient manner.
This software was basically refactored out of Thyra from the last
release of Trilinos 6.0 since MOOCHO, and in the future Tpetra, directly
depends on RTOp but not Thyra.  Contained in RTOp is:

a) a small number of interoperability interfaces

b) support software including code for the parallel SPMD mode based on
only Teuchos::Comm (and not MPI directly)

c) a library of pre-implemented RTOp subclasses for everything from
simple AXPYs and norms, to more specialized vector operations.

-------------------------------------------------------------------------------

Rythmos 1.0 (new)

Rythmos is a transient integrator for ordinary differential equations and
differential-algebraic equations with support for explicit, implicit, one-step
and multi-step algorithms.  The fundamental design of Rythmos is aimed at
supporting operator-split algorithms, multi-physics applications, block linear
algebra, and adjoint integration. 

New Features:

 - Everything is new.  This is the first release for Rythmos.

 - Implicit Backward Differentiation Formula Stepper:  This stepper provides a
   re-implementation of the implicit algorithms in the LLNL Sundials code CVODE.
   This is an implicit BDF integrator for ODEs which uses variable step-sizes
   and variable-orders first through fifth.

 - Explicit Runge-Kutta Stepper:  This stepper provides a four stage fourth
   order explicit RK steper with fixed step-sizes provided by the application.
   Full variable step-size support and application provided Butcher tableaus
   will be supported in the next release.

 - Forward Euler Stepper:  This stepper provides the explicit forward Euler
   algorithm with fixed step-sizes provided by the application.  Full variable
   step-size support will be in the next release.

 - Backward Euler Stepper:  This stepper provides the implicit backward Euler
   algorithm with fixed step-sizes provided by the application.  This
   class supports ODEs and DAEs.  Full variable step-size support will be
   in the next release.

Known Issues:

 - Currently Rythmos does not have an interface to NOX.  This will be provided
   through an EpetraExt::ModelEvaluator interface in NOX in the next release.
   Therefore the nonlinear solving capabilities in Rythmos are limited to a
   simple undampened Newton iteration in Thyra::TimeStepNewtonNonlinearSolver.

 - The InterpolationBuffer base class is just starting to be developed and has
   not been compiled or tested in any way yet.  It is provided as an example of
   what the interface could look like and where the integrator class will be
   derived from.

 - An integrator class does not yet exist.  It will depend on the
   InterpolationBuffer class and both of these will be completed in the next
   release.  Therefore users should use the Stepper class directly to step
   differential equations forward in time.  When this class is implemented it
   will enable solving operator-split and multi-physics problems.
 
 - The Explicit Taylor Polynomial Stepper is in active development and under
   current research.  It is provided only as an example interface.  This
   stepper may be completed in the next release.

-------------------------------------------------------------------------------

Stratimikos (new)

Stratimikos is a set of wrappers of common linear solver functionality through
Thyra.  In this initial release, Stratimikos provides the “Façade” class
Thyra::DefaultRealLinearSolverBuilder that provides a single parameter list
(i.e. Teuchos::ParameterList) driven interface to much of the linear solver and
preconditioner capability contained in Trilinos.  For example, the class
Thyra::DefaultRealLinearSolverBuilder is the recommended way to access the
linear solver adapters in Amesos/Thyra, AztecOO/Thyra, and Belos/Thyra (not in
Trilinos 7.0) as well as the preconditioner adapters in Ifpack/Thyra and
ML/Thyra.  With a single parameter list that can be read from an XML file, the
user can select for a wide variety of different linear solver and
preconditioner combinations.

Known issues:

- Incomplete parameter validation and inconsistent use of parameter lists:
  While many of the parameter lists and sublists accepted by the Stratimikos
  façade class Thyra::DefaultRealLinearSolverBuilder are fully validated and
  will write default parameter values when missing in the input parameter list
  such as for AztecOO/Thyra, other sublists for other solvers are not.  This is
  not specifically a Stratimikos issue but instead is an issue for the core
  code in Ifpack, ML, and Amesos.

-------------------------------------------------------------------------------

Teuchos

In Trilinos Release 7.0, the Teuchos tools package has some additional
functionality available to Trilinos developers and users:

- This release provides a simple XML parser that is compiled by default
  when eXpat is not available, enabling the perpetual use of Teuchos' XML
  utilities like XML-ParameterList reading and writing in any code.  Also,
  the Teuchos' XML utilities are now built by default.

- Complex scalar-type support is built by default for scalar-type templated
  utilities like the ScalarTraits, BLAS, LAPACK, and SerialDenseMatrix.

- A reference-counted class similiar to RefCountPtr designed to manage an
  array of objects is available, called ArrayRefCountPtr.

-------------------------------------------------------------------------------

Thyra

What's New:

- Implicit Linear Operators:  Thyra now includes support software that
  implements implicit zero, identity, diagonal, added, multiplied,
  scaled/adjoint, and blocked linear operators that complement the existing
  product vector space and (multi)vector subclasses.  These implicit operators
  allow you to create arbitrarily complex, nested, linear operators that are
  useful in a variety of contexts (e.g. Schur complement solvers, block
  preconditioners, time/space discretizations etc.).  Look for these in the
  “ANA Operator/Vector Support” collection and click on “ANA Development
  Support” link.

- Removal of explicit MPI support/dependence:  The separate serial and MPI
  support software collections for vector spaces, vectors, multi-vectors and
  linear operators have been merged into a single set of SPMD support software
  that is only dependent on the small new Teuchos::Comm interface.  This got
  rid of a lot of duplicate code and will allow for other more specialized
  implementations of communication.

- Java-like handle classes supporting Matlab-like operator overloading:  Thyra
  now includes a set of Java-like handle classes for wrapping vector spaces,
  vectors and linear operators and allowing you to write expressions like
  y=x+alpha*z and y=beta*A*x + B*y that don’t result in any unnecessary
  temporary copies unless required..  The linear operator handle class also
  provides full support for the implicit linear operator subclasses described
  above.  Look for these in the “ANA Operator/Vector Support” collection and
  click on “ANA Development Support” link.

- Zero-based indexing:  All of Thyra has been changed from largely 1-based
  indexing to completely zero-based indexing.  This especially impacted the
  multi-vector column access and subview functions.  Therefore, any current
  users are cautioned to carefully review their codes to see what impact this
  will have.  Note that most single-vector ANAs will not be affected by this
  change at all since there is not such indexing used in these types of
  algorithms.

- Compile-time enabled runtime checks: Almost all runtime tests in
  Thyra-related software must be explicitly enabled by adding
  –enable-teuchos-debug to the configure line.  This replaces having to
  manually define a _DEBUG macro as was required in the last release of
  Trilinos.  We highly recommend that this flag be turned on by all users and
  developers while developing with Thyra-related software.  Once a program is
  working and you want to run timed studies, then you should remove
  –enable-teuchos-debug, and turn up the compiler optimization flags.

- Expanded linear solver and preconditioner factory interfaces:  The Thyra
  linear solver interfaces in Trilinos 6.0 have been refined to now include the
  concept of a preconditioner factory.  Adapters are found in Amesos, AztecOO,
  Ifpack and ML.

- Nonlinear model evaluator:  The Thyra::ModelEvaluator interface now supports
  functionality for simulation-constrained optimization (i.e. as used by
  MOOCHO).

Known issues:

- Long compilation times: Compilation times for the examples and tests can be
  very excessive on older machines or when using some compilers.  The reason
  for this is that Thyra is entirely templated code currently and uses implicit
  template instantiation.  Therefore, when every *.cpp test/example file is
  compiled, the compiler has to parse and analyze every header and create
  instantiations over and over again.  In the future, the option of performing
  explicit template instantiation will be available and this will greatly
  speed up the build process but will also inhibit some of the flexibility of
  supporting different Scalar types and might complicate the build process.
  In the mean time for this release, to speed up the builds for Trilinos,
  users might consider adding –disable-thyra-tests and –disable-thyra-examples
  to the configure line.

- Wrong behavior of explicit element access functions: The behavior of the
  Thyra::[Multi]VectorBase::acquireDetachedView(…) functions is not consistent
  with the nature of abstract numerical algorithms (ANA) in single program
  multiple data (SPMD) mode.  The current behavior facilitates the
  interoperability of abstract vectors in an SPMD configuration without
  requiring lots of dynamic casts but is the wrong behavior from the ANA
  perspective.  This will be corrected in the next version of the release and
  specialized interfaces will be developed for (multi)vector-(multi)vector
  interoperability and the behavior of the functions
  Thyra::[Multi]VectorBase::acquireDetachedView(…) will be the same in every
  process of an SPMD, or any other type, of runtime configuration.  Therefore,
  users are warned to isolate any code that depends on the current behavior of
  the Thyra::[Multi]VectorBase::acquireDetachedView(…) functions since this
  behavior will change on the next release.   Note that most user code will
  never use these functions so this future refactoring this should cause
  serious problems for users.

- Unnecessary temporary creation in handle layer code:  The performance of
  handle-based code can be less efficient that nonhandle-based code in some
  cases, such as the creation of extra temporary vectors.  This may be fixable
  in later releases through more careful consideration operator evaluation
  logic.  In the mean time, studying the current implementation and some
  experimentation may help.

- Does not compile on IBM xlC compiler:  Thyra and all Thyra-related software
  can not be compiled on the IBM AIX C++ compiler (i.e. xlC).  The problem is
  that this C++ compiler gets tripped up with calling one version of an
  overloaded virtual function and declares the call to be ambiguous (which
  about 6 other distinct compilers consider the call to be non-ambiguous).
  Specifically, it declares that a call to the acquireDetachedView(…) function
  to be ambiguous.  The next release of Thyra might remove the overloaded
  functions and replace them with distinct names.

- ConstHandle classes will be removed:  The handle layer (e.g.
  Thyra::[Const]Vector, Thyra::[Const]LinearOperator etc.) is likely to change
  after the initial release of Trilinos 7.0.  The change will involve getting
  rid of the ConstHandle classes and going to a runtime protection of const
  involving just a single Handle class (e.g. Thyra::Vector and
  Thyra::LinearOperator).  Any code that uses the two-class handle system
  [Const]Handle should have no little problem being updated after the
  refactoring.  In fact, typedefs could allow all user code to be recompiled
  without change in most cases (but an actual code change would be a better
  long term solution).

-------------------------------------------------------------------------------

TriUtils

- No significant changes.

-------------------------------------------------------------------------------

WebTrilinos (new)

WebTrilinos is a scientific portal, a web-based environment to use several
Trilinos packages through the web. If you are teaching sparse linear algebra,
you can use WebTrilinos to present code snippets and simple scripts, and let
the students execute them from their browsers. If you want to test linear
algebra solvers, you can use the MatrixPortal module, and you just have to
select problems and options, then plot the results in nice graphs.

From the user's perspective, the only component required to use WebTrilinos is
any browser and an internet connection. Then, (simple) C++ and Python programs
can be written on a web form, executed on a server, and the output is sent back
to the user's browser. Code snippets for most of Trilinos and PyTrilinos
packages are already available in convenient repositories. WebTrilinos also
contains a problem solving environment (PSE) for the analysis of linear algebra
solvers, like direct solvers, Krylov solvers, and preconditioners. This
environment is called MatrixPortal.

To be installed, WebTrilinos requires the following:

   1. a web server, like Apache;
   2. PHP installed on the web server;
   3. an installed version of Trilinos, with the following packages: Teuchos,
      Epetra, EpetraExt, AztecOO, IFPACK, Amesos, ML, Galeri, PyTrilinos (and,
      of course, WebTrilinos itself);
   4. the PyChart package;
   5. the convert *nix tool to convert image files. 

WebTrilinos comes with a set of easy-to-use tools that suggest the
configuration options. For more details, please check the WebTrilinos web page
(http://software.sandia.gov/trilinos/packages/webtrilinos).


###############################################################################
#                                                                             #
# Trilinos Release 6.0 Release Notes                                          #
#                                                                             #
###############################################################################

Overview:

Trilinos is a collection of compatible software packages that support parallel 
linear algebra computations, solution of linear, non-linear and eigen systems 
of equations and related capabilities. The majority of packages are written in 
C++ using object-oriented techniques. All packages are self-contained, with the 
Trilinos top layer providing a common look-and-feel and infrastructure. 

Packages:

The version 6.0 general release contains 18 packages: Amesos, Anasazi, AztecOO, 
Didasko, Epetra, EpetraExt, Ifpack, Kokkos, Komplex, LOCA, ML, New_Package, 
NOX, Pliris, PyTrilinos, Teuchos, Thyra, and Triutils.

The limited release contains an additional 9 packages that are available in 
special situations by request. These are: Belos, Capo, Claps, Jpetra, Meros, 
Rythmos, Tpetra, TSF, and TSFExtended.

In addition to many new features across most packages, Trilinos Release 6.0 
contains one new package, Thyra.  This package represents our first general 
release of an abstract interface to support generic programming.  Thyra 
contains interfaces for basic linear algebra objects, a first linear solver 
interface, and supporting software.  Furthermore, adapters for Amesos, AztecOO, 
Epetra, Ifpack, ML, NOX and Teuchos provide a broad set of functionality to 
users of Thyra.  Finally, since Thyra is fundamentally an interface, users can 
write code based on Thyra without commiting to any particular concrete linear 
algebra package, but instead have access to a growing collection of supported 
concrete libraries.

A second major feature is the much improved design and implementation of 
PyTrilinos.  PyTrilinos capabilities are now primarily distributed across 
Trilinos packages (although critical common functionality is still in the 
PyTrilinos package), so that Epetra, EpetraExt, Triutils, AztecOO, Amesos, 
Ifpack, ML, LOCA, NOX and New_Package are accessible to Python applications.  
PyTrilinos also supports parallel MPI execution without additional Python 
modules, and parallel performance for large-grain computations matches native 
Trilinos peformance.  Finally, Python users are able to define their own matrix 
modules in Python, satisfying Trilinos abstract interface, that can be used by 
Trilinos solvers.

Other package-specific features are listed below.

More information:

Trilinos website: http://software.sandia.gov/trilinos 

===============================================================================

Amesos

- Improved memory management and performances 
- Added Scalapack, TAUCS and PARDISO support.
- Python interface for the factory and most classes.
- Amesos_Klu:
  - Improved performance on small matrices 
  - Supports non-standard indexing (i.e. {1,2,5,8,9}
  - Supports domain and range maps which differ from the matrix row map
- Amesos_Superlu and Amesos_Superludist:
  - Compatible with all Amesos solvers
  - Memory leaks eliminated
- Thyra wrappers for linear solve interface.  These adapter subclasses allow 
  any amesos direct solver to be incorporated, in a seamless way, into abstract 
  numerical algorithms written using the Thyra operator/vector abstractions.
- Makefile.export support 
- Eliminated dependence on triutils 
- Improved robustness through enhanced nighty testing

Known bugs:

- Amesos_Dscpack has memory leaks, prints to standard out and may crash if 
  SymbolicFactorization() is called multiple times on the same Amesos object.
- Amesos packages other than Amesos_Klu do not accept non-standard maps (e.g. 
  one with indices {1,2,5,8,9, ... } )
- Amesos packages other than Amesos_Klu do not accept range and domain maps 
  which differ from the matrix map
- Superludist fails on some matrices
- Error handling on singular and near singular matrices is inconsistent

-------------------------------------------------------------------------------

Anasazi

In Trilinos Release 6.0, Anasazi has a new solver, enhanced functionality and 
much more documentation.

- This release of Anasazi provides abstract implementations of three 
  eigensolvers:  block Davidson,  block Krylov-Schur, and locally-optimal block 
  preconditioned conjugate gradient (LOBPCG).  LOBPCG is the newest abstract 
  eigensolver implementation in the Anasazi framework for computing solutions 
  to symmetric eigenvalue problems.

- All three eigensolvers in Anasazi use the Anasazi::SortManager to sort for 
  the eigenvalues of interest. This functionality was previously available for 
  only the block Krylov-Schur implementation.

- Anasazi solvers now collect timing information that will be outputted if the 
  Anasazi::OutputManager is given the Anasazi::TimingDetails flag.

- The Anasazi framework now provides testing functionality for user-written 
  interfaces to Anasazi::MultiVecTraits and Anasazi::OperatorTraits.  This 
  functionality gives users a way to perform a sanity check on their interface.

- Anasazi has an updated and expanded tutorial in Didasko.

-------------------------------------------------------------------------------

AztecOO

- Python interface.
- Thyra linear solver adapters : Allows an AztecOO solver to be incorporated, 
  in a seamless way, into abstract numerical algorithms written using the Thyra 
  operator/vector abstractions.

-------------------------------------------------------------------------------

Didasko

- New chapter on Anasazi.

-------------------------------------------------------------------------------

Epetra

- Python interface for several objects, in serial and MPI: Epetra_Map, 
  Epetra_CrsMatrix, Epetra_LinearProblem, Epetra_Vector, Epetra_MultiVector, 
  Epetra_SerialDenseVector Epetra_SerialDenseMatrix, and more.
- Thyra adapters for vector space, linear operator, vector and multivector 
  classes.

-------------------------------------------------------------------------------

EpetraExt

- Python interface for I/O

-------------------------------------------------------------------------------

IFPACK

- Python interface for the factory class

-------------------------------------------------------------------------------

Kokkos

- No notable changes.

-------------------------------------------------------------------------------

Komplex

- No notable changes.

-------------------------------------------------------------------------------

LOCA

New features:

- A constraint tracking feature has been added to LOCA where the user can 
  specify additional algebraic constraints that must be satisfied along with 
  the residual.  Examples include boundary conditions, phase conditions in 
  periodic orbits, etc.  The resulting Newton system can be efficiently solved 
  using the QR method discussed below.  This capability is only available using 
  the LOCA::NewStepper also discussed below.

- A QR method for solving augmented systems of equations in parallel has been 
  added, and is an extension of the Householder method already available to 
  systems with more than one augmented row/column.  This method allows bordered 
  systems of equations to be solved in roughly the same time as original system 
  and is well-conditioned even when the original system is nearly singular.  
  This capability is only available using the LOCA::NewStepper discussed below.

- Many of the internals of LOCA have been rewritten to more fully support 
  multi-parameter continuation, constraint tracking, higher-order predictors 
  and advanced bifurcation algorithms.  This process is mostly, but not fully 
  complete.  This functionality is available by choosing the LOCA::NewStepper 
  for continuation instead of the original LOCA::Stepper.  However pitchfork 
  and Hopf continuation are currently not available in the new framework. 
  Documentation for this new framework can be found on the New LOCA Framework 
  page.

- LOCA's interface to eigensolvers has changed slightly and now uses a strategy 
  interface approach instead of relying on the group to provide 
  computeEigenvalues() and saveEigenvalues() methods.  This provides a more 
  natural decoupling of the parallel linear algebra data structures (i.e., the 
  group) from the eigensolver method/package (eigensolver strategy object). The 
  use of strategy interfaces instead of group methods is a major theme in the 
  new LOCA framework, and is discussed more fully on the new framework page.

Other notes:

- Teuchos::RefCountPtr support has been added to improve software quality. For 
  the most part, ref-count pointers are only used in the new framework.

- Many regression tests have been added to improve software quality.

- Libtool support has been removed from LOCA due to portability issues.

- Python support is temporarily disabled in this release due to a major 
  refactor of the build system for python wrappers in Trilinos.

Portability notes:

- There currently is a portability issue with LOCA to the Solaris platform 
  using the Sun Forte 7 compilers.  LOCA builds on this platform but does not 
  run correctly.  It appears the problem is compiler related as the virtual 
  table for some LOCA objects is not setup correctly.  All of the LOCA examples 
  and any LOCA tests involving continuation runs fail with a segmentation 
  fault.  It is not known whether LOCA runs correctly when built with version 
  10 of the Sun compilers.  See bugzilla bug 1238 for more information on this 
  issue.

-------------------------------------------------------------------------------

ML

- Improved the organization of the MLAPI source files and examples.  Now the 
  compilation of the MLAPI sources is about 20% faster, and the compilation of 
  the MLAPI examples up to 3 times faster.  Some never-used examples and 
  classes have been deleted.
- Drop the support for command line parameters. A similar capability is 
  supported by the Python interface.
- Repartitioning is now fully available through the MultiLevelPreconditioner 
  interface.
- Completed the ML wrapper for Python, using SWIG. The ML module still requires 
  a manual configuration of shared libraries, as done (on Linux/GCC at the 
  moment) with script make_shared_linux.sh, located in the PyTrilinos 
  directory.  The basic functionalities of the MultiLevelPreconditioner class 
  are available, for both serial and parallel runs. The ML module is compatible 
  with the Epetra and AztecOO modules.
- Changed the wrapper names and contents for Epetra matrices.  Now the dynamic 
  cast to Epetra_CrsMatrix and/or Epetra_VbrMatrix is done only once in the 
  construction of the preconditioner.  This results in an improvement of the 
  performances up to 30% for smore test problems.

- Added a simple finite element code, that can be used to test ML and MLAPI 
  preconditioners. The code offers a pure Galerkin and a SUPG discretization 
  for second order PDEs, in 2D and 3D, using triangles, quads, tets, and 
  hexahedra. L2 and H1 norms of the computed solution and error can be 
  computed. Results can be visualized using MEDIT.
- In the MLAPI namespace, added class MultiLevelAdaptiveSA, which implements 
  the \alpha SA algorithm (computation of slow converging modes for problems 
  with non-smooth kernels).
- Added a class, Ifpack_ML, that wraps an MultiLevelPreconditioner as 
  Ifpack_Preconditioner, so that ML can be used as local solver in a domain 
  decomposition preconditioner.
- Extended capabilities to read matrices from file in various formats.
- Added support for adaptive smoothed aggregation within MLAPI.  A new class, 
  called MultiLevelAdaptiveSA, has been added.
- Added a prototype of class for non-symmetric smoothed  aggregation.
- Added capability to write visualization files in legacy VTK (Visualization 
  toolkit) format.  These are readable by paraview, which is freely available 
  from www.paraview.org.  Supports 1D/2D/3D point cloud visualization for 
  aggregates, as well as solution visualization.

-------------------------------------------------------------------------------

New_Package

- PyTrilinos support:  Illustrates how a package can provide Python support.  
  Used by several other packages to provide new capabilities for PyTrilinos.

-------------------------------------------------------------------------------

NOX

- Refactor of configure for nox to align with the rest of Trilinos.  We now use 
  the same m4's that other packages use.  Also changed the way the examples are 
  configured so they are consistent with the tests.  Added implicit compilation 
  of ml and anasazi support.
- Addition of the export makefile system to enable easy interfacing to external 
  applications.
-  NOX now has a required dependency on Teuchos, it must be built as part of 
  Trilinos.

-------------------------------------------------------------------------------

Pliris

- No notable changes.

-------------------------------------------------------------------------------

PyTrilinos

In addition to python support present in Trilinos Release 5.0 for

  Epetra
  EpetraExt
  NOX
  NOX.Epetra

python interfaces have been added for the following packages:

  Amesos
  AztecOO
  IFPACK
  LOCA
  ML
  New_Package
  Triutils

Additionally, MPI support has been added.  Specifically, the Epetra.MpiComm 
class has been wrapped.  A new class, Epetra.PyComm, has been added, which 
returns an Epetra.SerialComm for serial builds and an Epetra.MpiComm for MPI 
builds.  For an MPI build, MPI_Init() is automatically called when the Epetra 
module is imported and MPI_Finalize() is automatically registered with the 
"atexit" module. Thus python scripts can be written that are identical for 
serial and MPI runs.

Configuration, building and installing
--------------------------------------

Python interfaces are enabled at configuration time now using the

--with-python[=path]    or
--enable-python[=path]

options, which are equivalent.  During "make", python interfaces will be built 
for every package that both supports python and is enabled.

(In Release 5.0, the four supported packages all had to be enabled. The 
--enable-pytrilinos configuration option, which enabled PyTrilinos in Release 
5.0, now only enables a small utility library used by all of the python 
interfaces.  The --enable-pytrilinos option is not strictly needed by end 
users, as the PyTrilinos package is automatically enabled by either 
--with-python or --enable-python.)

Python 2.3 or higher is highly recommended.  Some packages can be built against 
python 2.2, but there are some packages that require python 2.3.

SWIG (Simple Wrapper Interface Generator) version 1.3.23 or higher is required 
to generate the wrapper code.  These wrappers are not pre-built because they 
can be affected by configuration options. Configure will find swig if it is in 
your standard path, or you can tell configure where to find it using the 
--with-swig=PATH option.

The Numeric python module is required.

Do not configure with C flags -ansi or -pedantic.  Python supports arbitrary 
precision integers and these options will cause the compiler to fail.

The "make install" command will install the python interfaces (in addition to 
the standard package libraries and header files, of course).  If configured 
with --prefix=PATH, the modules will be installed in PATH/lib.  Make sure your 
PYTHONPATH environment variable is set correctly.  If --prefix=PATH is not 
provided, the modules will be installed in the standard location determined by 
where the python executable is installed.  This is often not /usr/local/, 
which is the default installation location for other Trilinos packages.  
Depending on how python was installed, this usually requires root access.

Testing
-------

>From the top build directory, or from a package top build directory, you can 
invoke "make run-pyexamples" or "make run-pytests" to execute all the scripts 
in the example or test directories, respectively. This will give concise output 
regarding failure or success for each script.  Detailed results of thes tests 
that have been run can be found in the

packages/PACKAGE_NAME/test/runtests-results/

directory of the build directory.

Examples
--------

An important change was made to the directory structure for Release 6.0.  The 
python wrapper generation code is now contained within each package, under a 
directory named "python".  Within this directory are "src", "test", "example" 
and possibly other sub-directories.  For example, the epetra directory 
structure now includes

packages/epetra/python/
packages/epetra/python/example/
packages/epetra/python/src/
packages/epetra/python/test/

In the python/example sub-directory of each supported package, there will be 
one or more example python scripts demonstrating how to use the given module 
interface.  The python/test sub-directories are for unit tests.  If you are 
familiar with the python unittest module, these test scripts can provide 
additional examples of how to use the given module interface.

The example and test scripts are copied from the source directory to the build 
directory when "make" is run.  If these scripts are run from the build 
directory, they are designed to import the local build (uninstalled) versions 
of the Trilinos python interface modules.  If run from a different location 
(say, the source directory, or if you have copied them to another location), 
the scripts will still work as long as the python interfaces have been 
installed in a location where python can find them.

Using PyTrilinos
----------------

At this time, PyTrilinos documentation is admittedly incomplete. However, some 
documentation is available at

http://software.sandia.gov/trilinos/packages/pytrilinos/documentation.html

where you can find current lists of what packages are supported and which 
classes and functions within those packages have been wrapped.

PyTrilinos modules should be imported from a python script using, for 
example, the

>>> from PyTrilinos import Epetra

syntax.  Not all classes of all supported packages have been wrapped. One way 
to see what is available is to use the dir() function on a module:

>>> dir(Epetra)

For the most part, the python versions of functions, constructors and class 
methods use the same return values and argument lists as their C++ counterparts.  
Therefore, the individual package documentation is a good starting place for 
what is available, and for proper usage. However, it often makes sense to 
change the python argument lists --
for example, we may allow the use of a python list in place of a pointer to a 
C array, and we may then eliminate the integer size argument from the argument 
list, since it can now be obtained implicitly; or an output argument may be 
moved to a function's return value, often changing the return value to a tuple.  
Fortunately, all wrapped methods and functions have a documentation string that 
indicates correct usage.  Documentation strings in python can be obtained with 
the help() function.  For example:

>>> help(Epetra.CrsMatrix.InsertGlobalValues)
Help on method InsertGlobalValues in module Epetra:

InsertGlobalValues(*args) unbound Epetra.CrsMatrix method
InsertGlobalValues(self, int GlobalRow, int NumEntries, double Values, int 
Indices) -> int
InsertGlobalValues(self, int Row, int Size, SerialDenseVector Values, 
IntSerialDenseVector Entries) -> int
InsertGlobalValues(self, int row, PyObject Values, PyObject Indices) -> int

The PyObject type that will often appear in these documentation strings refer 
to arbitrary python objects, but often are expected to be containers such as 
lists, tuples or Numeric arrays.  In these cases, some experimentation may be 
in order.

For Developers
--------------

By convention, the code to build individual python interfaces now resides 
within each package, in the sub-directory "python".  For a template of how to 
wrap a Trilinos package, see the new-package package, and in particular the 

packages/new_package/python/Instructions.txt

file.

The PyTrilinos package itself is now a small library of utility classes and 
functions, intended to ease repetitive tasks that come up frequently when 
wrapping Trilinos packages.  For more details, contact Bill Spotz, 
wfspotz@sandia.gov.

-------------------------------------------------------------------------------

Teuchos

- No notable changes.

-------------------------------------------------------------------------------

Thyra (new)

- Defines fundamental abstract interfaces for vectors, multi-vectors, vector 
  spaces, and linear operators that form the foundation for all abstract 
  numerical algorithms.

- These interfaces will eventually be use to provide uniform interoperability 
  between a number of Trilinos (e.g. Belos, Anasazi, NOX, Rythmos, MOOCHO) and 
  non-Trilinos packages and to encapsulate application/physics codes.

- Also included are a small number of extended interoperability interfaces 
  such as:
  - Interface for linear operators that support a solve operation
  - Other miscellaneous interoperability interfaces
- Also included is adapter support code and very general concrete 
  implementations for:
  - Support for specialized scalar products for vector spaces
  - Support serial vector, multi-vector, vector space, and linear operator 
    implementations
  - Support MPI-based parallel vector, multi-vector, vector space, and linear 
    operator implementations
- Also included is utility code for helping to write abstract numerical 
  algorithms:
  - Unit tests for linear operators
  - Composite objects: product vectors, implicit operators (diagonal, 
    scaled/transposed, multiplicative etc.)
  - Explicit access to vector and multi-vector coefficients

-------------------------------------------------------------------------------

Triutils

- Python interface for the matrix gallery

-------------------------------------------------------------------------------

CLAPS (limited release only)

- The CLAPS package now contains two domain decomposition 
  preconditioners/solvers. The first, named CLOP, is based on a classic 
  overlapping Schwarz approach with an algebraically constructed coarse 
  space. The second, named CLIP, is an iterative substructuring (Schur 
  complement) approach that can be viewed as a primal counterpart of FETI-DP.


###############################################################################
#                                                                             #
# Trilinos Release 5.0 Release Notes                                          #
#                                                                             #
###############################################################################

Overview:

Trilinos is a collection of compatible software packages that support parallel 
linear algebra computations, solution of linear, non-linear and eigen systems 
of equations and related capabilities. The majority of packages are written in 
C++ using object-oriented techniques. All packages are self-contained, with the 
Trilinos top layer providing a common look-and-feel and infrastructure. 

Packages:

The version 5.0 general release contains 17 packages: Amesos, Anasazi, AztecOO, 
Didasko, Epetra, EpetraExt, Ifpack, Kokkos, Komplex, LOCA, ML, New_Package, 
NOX, Pliris, PyTrilinos, Teuchos, and Triutils.

The limited release contains an additional 9 packages that are available in 
special situations by request. These are: Belos, Claps, Jpetra, Meros, Tpetra, 
TSF, TSFCore, TSFCoreUtils and TSFExtended.

Some of the significant new features:

- Four new packages: Anasazi (Eigensolvers), Didasko (Tutorial), Pliris
  (Distributed dense solvers), PyTrilinos (Python interface to Trilinos
  libraries).
- Trilinos tutorial delivered as part of a new package called Didasko.
- Kernel performance in Epetra substantially improved, especially for
  multiple rights.
- Initial kernel support for vector architectures in Epetra.
- Significant improvements and enhancements in most existing packages.

More information:

Trilinos website: http://software.sandia.gov/trilinos 

===============================================================================

Amesos (version 2.0)

- Improved handling of Epetra_RowMatrix operators 
- Memory leaks have been reduced 
- Simplified configuration using
    --with-ldflags=-L/home/kstanley/Trilinos3PL/lib
    --with-libs=-lsuperludist
    --with-incdirs=-I/home/kstanley/Trilinos3PL/include
- Known bugs: 
  - Amesos_Dscpack has memory leaks, prints to standard out and may crash if 
    SymbolicFactorization() is called multiple times on the same Amesos 
    object. 
  - Amesos packages do not accept non-contiguous maps (e.g. one with indices 
    {1,2,5,8,9, ... } ) 
  - Superludist fails on some matrices 
  - Error handling on singular and near singular matrices is inconsistent 

-------------------------------------------------------------------------------

Anasazi (new)

- Anasazi framework includes abstract description of eigenproblem, eigensolver,
  sorting, and linear algebra. 
- Templated implementations of two block eigensolvers ( block Krylov-Schur and 
  block Davidson ) are included in this release. 
- Anasazi eigensolvers can use Epetra through linear algebra adapters. 
- A basic implementation of the abstract eigenproblem class is given for 
  solving standard and generalized eigenvalue problems. 
- A basic implementation of the abstract sorting class is given for the block 
  Krylov-Schur method. The block Davidson computes only the smallest 
  eigenvalues at this time. 
- Many examples for solving standard and generalized eigenvalues problems using 
  Anasazi are provided in this release. 

-------------------------------------------------------------------------------

AztecOO

- Robust support for multiple simultaneous instances of AztecOO objects.
  Prior releases had a very fragile memory management approach that require
  user intervention.
- Support (optional dependence on Teuchos) for ParameterList-driven use 
  of AztecOO via Teuchos ParameterList objects.

-------------------------------------------------------------------------------

Didasko (new)

- Didasko now contains the tutorial PDF file and examples. All the tutorial 
  material is located in the Trilinos/packages/didasko subdirectory. 
- The doxygen documentation has been improved. 
- All examples are configured with autotools. Users can enable the compilations 
  of the examples by adding --enable-didasko to their configure line. 

------------------------------------------------------------------------------- 
Epetra

- Memory efficiency improvement for MultiVector, CrsGraph and CrsMatrix 
  classes. 
- MultiVector uses much less O(NumVector) storage in important situations. 
- CrsGraph and CrsMatrix support a static profile mode that allows one-time 
  allocation of memory. 
- CrsGraph and CrsMatrix support a more robust OptimizeStorage capability that 
  improves memory use and performance. 
- Performance improvement for CrsMatrix and VbrMatrix kernels. 
- CrsMatrix matrix multiplication and triangular solves are 20% to 100% faster 
  that Version 4.0 
- VbrMatrix matrix multiplication is also improved for some important classes 
  of problems. 
- Initial vector architecture support for sparse matrix-vector multiplication. 
- A new class called JadOperator supports matrix-vector multiplication using 
  the so-called Jagged Diagonal data format. This format is especially 
  effective for vector machines such as the Cray X1 and NEC SX series machines.

-------------------------------------------------------------------------------
 
EpetraExt

- Scalable parallel distance-1 and distance-2 graph coloring. 
- Sparse matrix Add for Epetra CRS matrices. 
- Global index map "reindexing" tool for Epetra objects. 

-------------------------------------------------------------------------------

Ifpack

- IFPACK 3.0 defines a general interface for preconditioners, through class 
  Ifpack_Preconditioner. 
- Class Ifpack_AdditiveSchwarz can be used to define general overlapping 
  one-level domain decomposition preconditioners. 
- IFPACK now offers point and block relaxation schemes, of Jacobi, 
  Gauss-Seidel, and symmetric Gauss-Seidel type. For block schemes, the 
  package supports both dense and sparse blocks. 
- Two new factorizations, ILUT and ICT, have been introduced. 
- A new user's guide is available. The doxygen documentation has been improved. 

-------------------------------------------------------------------------------

Kokkos (version 1.1)

- No notable new features. 

-------------------------------------------------------------------------------

Komplex (version 2.0)

- No notable new features. 

-------------------------------------------------------------------------------

LOCA

- The LOCA library can now be built as a shared library using libtool. Known 
  issues with this are: 
  - Extra link libraries passed using the --with-libs configure flag should 
    use the "-Lpath -lname" format instead of "path/libname.a" 
  - Building LOCA as a static library on DEC architectures using template 
    repositories does not work. On these architectures, only build LOCA as a 
    shared library using the --enable-shared and --disable-static configure 
    flags, or turn off template repositories using the "-tweak" C++ compiler 
    flag. Note that if the later method is chosen, a large number of warnings 
    will be issued each time an executable is linked against LOCA. 
  - When building shared libraries on SGI systems in 64 bit, one must supply 
    the "-64" C++ compiler flag to not only the compiler and linker through 
    CXXFLAGS and LDFLAGS, but also to libtool using LIBTOOL_CCLINKER_FLAGS 
    or --with-libtool-cclinker-flags. Also one must turn off template 
    repositories and the template prelinker using the flags "-ptused 
    -no_prelink -no_auto_include". 
  - When building shared libraries on Solaris systems, one should add 
    "-xlic_lib=sunperf" to CFLAGS, "-library=sunperf" to CXXFLAGS and 
    LIBTOOL_CCLINKER_FLAGS, and make sure neither of these flags appear in 
    LDFLAGS. 
  - A basic, but functional python interface to NOX and LOCA now exists. A 
    test exhibiting this functionality can be found in the 
    Trilinos/packages/nox/test/lapack/LOCA_python directory. 

-------------------------------------------------------------------------------

ML (version 3.1)

- ML now supports Zoltan as a coarsening scheme (RCB only). Zoltan
  can be used to create the aggregates and to redistribute
  the next-level operator among the specified number of
  processors (which can be less than the available number of processes,
  for Maxwell solver only).
- a variable-block partitioning scheme (based on METIS) is now available. 
- ML now supports IFPACK smoothers, like variable block Jacobi, 
  Gauss-Seidel and symmetric Gauss-Seidel preconditioners, and 
  generic additive Schwarz preconditioner.
- Updated ML user's guide and Doxygen documentation.
- Improved MultiLevelPreconditioner class (now derived from
  Epetra_Operator and no longer from Epetra_RowMatrix). Updated
  filtering/GGB algorithm, based on the Anasazi package.
- Solving Maxwell equations via MultiLevelPreconditioner is now supported.
- Improved organization of the examples, more detailed comments and 
  additional README files. 
- Wrapping an ML_Operator struct as Epetra_RowMatrix is now supported.
- Improved test coverage.

-------------------------------------------------------------------------------

New_Package (version 1.1)

- New tests are working examples of how to add tests to the Trilinos 
  Test-Harness. 

-------------------------------------------------------------------------------

NOX

- A new Tensor based solver that is independent of the underlying linear 
  solver is now implemented (in the prerelease section). Previously the 
  Tensor method was hardwired to use an iterative solver. 
- Inexact Trust Region Techniques are fully supported (also in the prerelease 
  section). 
- Improved support for Epetra objects - The NOX::EpetraNew::Group should be 
  used in place of the NOX::Epetra::Group. In the future we will be phasing 
  out the NOX::Epetra::Group and replace it with NOX::EpetraNew::Group. 
- A multi-physics technique for code coupling has been demonstrated in the 
  test/epetra/Multiphysics directory. This will be expanded to a generic 
  capability in the next year. 

-------------------------------------------------------------------------------

Pliris (new)

- An Object Oriented interface to a Dense Parallel LU Solver is now in place.
- The matrix is described in terms of Epetra Vectors and Multivectors.
- Multiple right hand sides can be addressed.
- Configure with --enable-pliris
- Test code allows performance studies - performance is dependent on highly 
  optimized Level 3 BLAS.

-------------------------------------------------------------------------------

PyTrilinos (new)

- Requires SWIG version 1.3.23 or higher (http://www.swig.org). 
- Requires python Numeric (http://www.pfdubois.com/numpy). 
- Configure with --enable-pytrilinos. 
- Currently provides access to Epetra, EpetraExt and NOX. From python, use 
  "from PyTrilinos import name", where "name" is the desired module. 
- Online documentation provides list of which classes have been wrapped. 
- Wrapped classes support almost all of the class methods. See documentation 
  of wrapped packages for details. 

-------------------------------------------------------------------------------

Teuchos

- Additional BLAS/LAPACK wrappers 
- Teuchos::ScalarTraits template specializations for the GNU MP and Arprec 
  arbitrary precision libraries 
- Code enabling the conversion from NOX::Parameter::List to 
  Teuchos::ParameterList, and vice versa. 

-------------------------------------------------------------------------------

Triutils

- No notable new features.

