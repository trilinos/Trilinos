Usage: checkin-test.py [OPTIONS]

This tool does testing of a TriBITS-based project using CTest and this script
can actually do the push itself using eg/git in a safe way.  In fact, it is
recommended that one uses this script to push since it will amend the last
commit message with a (minimal) summary of the builds and tests run with
results and/or send out a summary email about the builds/tests performed.


Quickstart:
-----------

In order to do a safe push, perform the following recommended workflow
(different variations on this workflow are described below):

1) Commit changes in the local repo:

  # 1.a) See what files are changed, newly added, etc. that need to be committed
  # or stashed.
  $ eg status

  # 1.b) Stage the files you want to commit (optional)
  $ eg stage <files you want to commit>

  # 1.c) Create your local commits
  $ eg commit -- SOMETHING
  $ eg commit -- SOMETHING_ELSE
  ...

  # 1.d) Stash whatever changes are left you don't want to test/push (optional)
  $ eg stash

  NOTE: You can group your commits any way that you would like (see the basic
  eg/git documentation).

  NOTE: If not installed on your system, the eg script can be found at
  tribits/common_tools/git/eg.  Just add it to your path.

  NOTE: When multiple repos are involved, use egdist instead.  It is provided
  at tribits/common_tools/git/egdist.  See egdist --help for details.

2) Review the changes that you have made to make sure it is safe to push:

  $ cd $PROJECT_HOME
  $ eg local-stat                  # Look at the full status of local repo
  $ eg diff --name-status origin   # [Optional] Look at the files that have changed

  NOTE: The command 'local-stat' is a git alias that can be installed with the
  script tribits/common_tools/git/git-config-alias.sh.  It is highly
  recommended over just a raw 'eg status' or 'eg log' to review commits before
  attempting to test/push commits.

  NOTE: If you see any files/directories that are listed as 'unknown' returned
  from 'eg local-stat', then you will need to do an 'eg add' to track them or
  add them to an ignore list *before* you run the checkin-test.py script.
  The eg script will not allow you to push if there are new 'unknown' files or
  uncommitted changes to tracked files.

3) Set up the checkin base build directory (first time only):

  $ cd $PROJECT_HOME
  $ echo CHECKIN >> .git/info/exclude
  $ mkdir CHECKIN
  $ cd CHECKIN

  NOTE: You may need to set up some configuration files if CMake can not find
  the right compilers, MPI, and TPLs by default (see detailed documentation
  below).

  NOTE: You might want to set up a simple shell driver script.

  NOTE: You can set up a CHECKIN directory of any name in any location
  you want.  If you create one outside of the main source dir, then
  you will not have to add the git exclude shown above.

4) Do the pull, configure, build, test, and push:

  $ cd $PROJECT_HOME
  $ cd CHECKIN
  $ ../checkin-test.py -j4 --do-all --push

  NOTE: The above will: a) pull updates from the global repo(s), b)
  automatically enable the correct packages, c) configure and build the right
  packages, d) run the tests, e) send you emails about what happened, f) do a
  final pull from the global repo, g) optionally amend the last local commit
  with the test results, and h) finally push local commits to the global
  repo(s) if everything passes.

  NOTE: You must have installed the official versions of eg/git with the
  install-git.py script in order to run this script.  If you don't, the script
  will die right away with an error message telling you what the problem is.

  NOTE: The current branch will be used to pull and push to.  A raw 'eg pull'
  is performed which will get all of the branches from 'origin'.  This means
  that your current branch must be a tracking branch so that it will get
  updated correctly.  The branch 'master' is the most common branch but
  release tracking branches are also common.

  NOTE: You must not have any uncommitted changes or the 'eg pull && eg rebase
  --against origin' command will fail on the final pull/rebase before the push
  and therefore the whole script will fail.  To run the script, you will may
  need to first use 'eg stash' to stash away your unstaged/uncommitted changes
  *before* running this script.

  NOTE: You need to have SSH public/private keys set up to the remote repo
  machines for the git commands invoked in the script to work without you
  having to type a password.

  NOTE: You can do the final push in a second invocation of the script with a
  follow-up run with --push and removing --do-all (it will remember the
  results from the build/test cases just ran).  For more details, see detailed
  documentation below.

  NOTE: Once you start running the checkin-test.py script, you can go off and
  do something else and just check your email to see if all the builds and
  tests passed and if the push happened or not.

  NOTE: The commands 'cmake', 'ctest', and 'make' must be in your default path
  before running this script.

For more details on using this script, see the detailed documentation below.


Detailed Documentation:
-----------------------

The following approximate steps are performed by this script:


----------------------------------------------------------------------------


1) Check to see if the local repo(s) are clean:

  $ eg status

  NOTE: If any modified or any unknown files are shown, the process will be
  aborted.  The local repo(s) working directory must be clean and ready to
  push *everything* that is not stashed away.

2) Do a 'eg pull' to update the code (done if --pull or --do-all is set):

  NOTE: If not doing a pull, use --allow-no-pull or --local-do-all.

3) Select the list of packages to enable forward/downstream based on the
package directories where there are changed files (or from a list of packages
passed in by the user).

  NOTE: The automatic enable behavior can be overridden or modified using the
  options --enable-all-packages, --enable-packages, --disable-packages, and/or
  --no-enable-fwd-packages.

4) For each build/test case <BUILD_NAME> (e.g. MPI_DEBUG, SERIAL_RELEASE,
extra builds specified with --extra-builds):

  4.a) Configure a build directory <BUILD_NAME> in a standard way for all of
  the packages that have changed and all of the packages that depend on these
  packages forward/downstream. You can manually select which packages get
  enabled (see the enable options above).  (done if --configure, --do-all, or
  --local-do-all is set.)
  
  4.b) Build all configured code with 'make' (e.g. with -jN set through
  -j or --make-options).  (done if --build, --do-all, or --local-do-all is set.)
  
  4.c) Run all BASIC tests for enabled packages.  (done if --test, --do-all,
  or --local-do-all is set.)

  4.d) Analyze the results of the update, configure, build, and tests and send
  email about results.  (emails only sent out if --send-emails-to != "")

5) Do final pull and rebase, append test results to last commit message, and
push (done if --push is set)

  5.a) Do a final 'eg pull' (done if --pull or --do-all is set)

  5.b) Do 'eg rebase --against origin/<current_branch>' (done if --pull or
  --do-all is set and --rebase is set)

    NOTE: The final 'eg rebase --against origin/<current_branch>' is
    required to avoid trivial merge commits that the global get repo
    will reject on the push.
  
  5.c) Amend commit message of the most recent commit with the summary of the
  testing performed.  (done if --append-test-results is set.)
  
  5.d) Push the local commits to the global repo (done if --push is set)


----------------------------------------------------------------------------


The recommended way to use this script is to create a new base CHECKIN test
directory apart from your standard build directories such as with:

  $ $PROJECT_HOME
  $ mkdir CHECKIN
  $ echo CHECKIN >> .git/info/exclude

The most basic way to do pre-push testing is with:

  $ cd CHECKIN
  $ ../checkin-test.py --do-all [other options]

If your MPI installation, other compilers, and standard TPLs (i.e. BLAS and
LAPACK) can be found automatically, then this is all you will need to do.
However, if the setup cannot be determined automatically, then you can add a
set of CMake variables that will get read in the files:

  COMMON.config
  MPI_DEBUG.config
  SERIAL_RELEASE.config

(or whatever your standard --default-builds are).

Actually, for built-in build/test cases, skeletons of these files will
automatically be written out with typical CMake cache variables (commented
out) that you would need to set out.  Any CMake cache variables listed in
these files will be read into and passed on the configure line to 'cmake'.

WARNING: Please do not add any CMake cache variables than what are needed to
get the Primary Tested (PT) --default-builds builds to work.  Adding other
enables/disables will make the builds non-standard and break these PT builds.
The goal of these configuration files is to allow you to specify the minimum
environment to find MPI, your compilers, and the required TPLs (e.g. BLAS,
LAPACK, etc.).  If you need to fudge what packages are enabled, please use the
script arguments --enable-packages, --disable-packages,
--no-enable-fwd-packages, and/or --enable-all-packages to control this, not
the *.config files!

WARNING: Please do not add any CMake cache variables in the *.config files
that will alter what packages or TPLs are enabled or what tests are run.
Actually, the script will not allow you to change TPL enables in these
standard *.config files because to do so deviates from a consistent build
configuration for Primary Tested (PT) Code.

NOTE: All tentatively-enabled TPLs (e.g. Pthreads and BinUtils) are hard
disabled in order to avoid different behaviors between machines where they
would be enabled and machines where they would be disabled.

NOTE: If you want to add extra build/test cases that do not conform to
the standard build/test configurations described above, then you need
to create extra builds with the --extra-builds and/or
--st-extra-builds options (see below).

NOTE: Before running this script, you should first do an 'eg status' and 'eg
diff --name-status origin..' and examine what files are changed to make sure
you want to push what you have in your local working directory.  Also, please
look out for unknown files that you may need to add to the git repository with
'eg add' or add to your ignores list.  There cannot be any uncommitted changes
in the local repo before running this script.

NOTE: You don't need to run this script if you have not changed any files that
affect the build or the tests.  For example, if all you have changed are
documentation files, then you don't need to run this script before pushing
manually.

NOTE: To see detailed debug-level information, set
TRIBITS_CHECKIN_TEST_DEBUG_DUMP=ON in the env before running this script.


Common Use Cases (examples):
----------------------------

(*) Basic full testing with integrating with global repo(s) without push:

  ../checkin-test.py --do-all

  NOTE: This will result in a set of emails getting sent to your email address
  for the different configurations and an overall push readiness status email.

  NOTE: If everything passed, you can follow this up with a --push (see
  below).

(*) Basic full testing with integrating with local repo and push:

  ../checkin-test.py --do-all --push

(*) Push to global repo after a completed set of tests have finished:

  ../checkin-test.py [other options] --push

  NOTE: This will pick up the results for the last completed test runs with
  [other options] and append the results of those tests to the log of the most
  recent commit.

  NOTE: Take the action options for the prior run and replace --do-all with
  --push but keep all of the rest of the options the same.  For example, if
  you did:

    ../checkin-test.py --enable-packages=Blah --default-builds=MPI_DEBUG --do-all

  then follow that up with:

    ../checkin-test.py --enable-packages=Blah --default-builds=MPI_DEBUG --push

  NOTE: This is a common use case when some tests are failing which aborted
  the initial push but you determine it is okay to push anyway and do so with
  --force-push.

(*) Test only the packages modified and not the forward dependent packages:

  ../checkin-test.py --do-all --no-enable-fwd-packages

  NOTE: This is a safe thing to do when only tests in the modified packages
  are changed and not library code.  This can speed up the testing process and
  is to be preferred over not running this script at all.  It would be very
  hard to make this script automatically determine if only test code has
  changed because every package does not follow a set pattern for
  tests and test code.

(*) Run the most important default (e.g. MPI_DEBUG) build/test only:

  ../checkin-test.py --do-all --default-builds=MPI_DEBUG

(*) The minimum acceptable testing when code has been changed:

  ../checkin-test.py \
    --do-all --enable-all-packages=off --no-enable-fwd-packages \
    --default-builds=MPI_DEBUG

  NOTE: This will do only an MPI DEBUG build and will only build and run the
  tests for the packages that have directly been changed and not any forward
  packages.  Replace "MPI_DEBUG" with whatever your most important default
  build is.

(*) Test only a specific set of packages and no others:

  ../checkin-test.py \
    --enable-packages=<P0>,<P1>,<P2> --no-enable-fwd-packages \
    --do-all
  
  NOTE: This will override all logic in the script about which packages will
  be enabled and only the given packages will be enabled.

  NOTE: You might also want to pass in --enable-all-packages=off in case the
  script wants to enable all the packages (see the output in the
  checkin-test.py log file for details) and you think it is not necessary to
  do so.

  NOTE: Using these options is greatly preferred to not running this script at
  all and should not be any more expensive than the testing you would already
  do manually before a push.

(*) Test changes locally without pulling updates:

  ../checkin-test.py --local-do-all

  NOTE: This will just configure, build, test, and send an email notification
  without updating or changing the status of the local git repo in any way and
  without any communication with the global repo.  Hence, you can have
  uncommitted changes and still run configure, build, test without having to
  commit or having to stash changes.

  NOTE: This is not a sufficient level of testing in order to push the changes
  to the global repo because you have not fully integrated your changes yet
  with other developers.  However, this would be a sufficient level of testing
  in order to do a commit on the local machine and then pull to a remote
  machine for further testing and a push (see below).

(*) Adding extra build/test cases:

  Often you will be working on Secondary Tested (ST) Code or Experimental (EX)
  Code and want to include the testing of this in your pre-push testing
  process along with the standard --default-builds build/test cases which can
  only include Primary Tested (PT) Code.  In this case you can run with:
  
    ../checkin-test.py --extra-builds=<BUILD1>,<BUILD2>,... [other options]
  
  For example, if you have a build that enables the TPL CUDA you would do:
  
    echo "
    -DTPL_ENABLE_MPI:BOOL=ON
    -DTPL_ENABLE_CUDA:BOOL=ON
    " > MPI_DEBUG_CUDA.config
  
  and then run with:
  
    ../checkin-test.py --extra-builds=MPI_DEBUG_CUDA --do-all
  
  This will do the standard --default-builds (e.g. MPI_DEBUG and
  SERIAL_RELEASE) build/test cases along with your non-standard MPI_DEBUG_CUDA
  build/test case.

  NOTE: You can disable the default build/test cases with --default-builds="".
  However, please only do this when you are not going to push because you need
  at least one default build/test case (the most important default PT case,
  e.g. MPI_DEBUG) to do a safe push.

(*) Including extra repos and extra packages:

  You can also use the checkin-test.py script to continuously integrate
  multiple git repos containing add-on packages. To do so, just run:
    
    ../checkin-test.py --extra-repos=<REPO1>,<REPO2>,... [options]

  NOTE: You have to create local commits in all of the extra repos where there
  are changes or the script will abort.

  NOTE: Extra repos can be specified with more flexibility using the
  --extra-repos-file and --extra-repos-type arguments (also see
  --ignore-missing-extra-repos).

  NOTE: Each of the last local commits in each of the changed repos will get
  amended with the appended summary of what was enabled in the build/test (if
  --append-test-results is set).

(*) Avoid changing any of the local commit SHA1s:

  If you are pushing commits from a shared branch, it is critical that you
  don't not change any of the SHA1s of the commits.  To change the SHA1s for
  any of the commits will mess up various multi-repo, multi-branch workflows.
  To avoid changing any of the SHA1s of the local commits, one must run with:

    ../checkin-test.py --no-rebase --no-append-test-results [options]

(*) Performing a remote test/push:

  If you develop on a slow machine like your laptop, doing an appropriate
  level of testing can take a long time.  In this case, you can pull the
  changes to another faster remote workstation and do a more complete set of
  tests and push from there.  If you are knowledgeable with git, this will be
  easy and natural to do, without any help from this script.  However, this
  script can still help and automate the steps and can do so in one command
  invocation on the part of the developer.

  On your slow local development machine 'mymachine', do the limited testing
  with:

    ../checkin-test.py --do-all --no-enable-fwd-packages
  
  On your fast remote test machine, do a full test and push with:
  
    ../checkin-test.py \
      --extra-pull-from=<remote-name>:master \
      --do-all --push

  where <remote-name> is a git repo pointing to
  mymachine:/some/dir/to/your/src:master (see 'git help remote').
  
  NOTE: You can of course adjust the packages and/or build/test cases that get
  enabled on the different machines.
  
  NOTE: Once you invoke the checkin-test.py script on the remote test machine
  and it has pulled the commits from mymachine, then you can start changing
  files again on your local development machine and just check your email to
  see what happens on the remote test machine.
  
  NOTE: If something goes wrong on the remote test machine, you can either
  work on fixing the problem there or you can fix the problem on your local
  development machine and then do the process over again.

  NOTE: If you alter the commits on the remote machine (such as squashing
  commits), you will have trouble merging back on our local machine.
  Therefore, if you have to to fix problems, make new commits and don't alter
  the ones you pulled from your local machine (but rebasing them should be
  okay as long as the local commits on mymachine are not pushed to other
  repos).

  NOTE: Git will resolve the duplicated commits when you pull the commits
  pushed from the remote machine.  Git knows that the commits are the same and
  will do the right thing when rebasing (or just merging).
  
(*) Check push readiness status:

  ../checkin-test.py

  NOTE: This will examine results for the last testing process and send out an
  email stating if the a push is ready to perform or not.

(*) See the default option values without doing anything:

  ../checkin-test.py --show-defaults

  NOTE: This is the easiest way to figure out what all of the default options
  are.

Hopefully the above documentation, the example use cases, the documentation of
the command-line arguments below, and some experimentation will be enough to
get you going using this script for all of your pre-push testing and pushes.
If that is not sufficient, send email to your development support team to ask
for help.


Handling of PT, ST, and EX Code in built-in and extra builds:
-------------------------------------------------------------

This script will only process PT (Primary Tested) packages in the
--default-builds (e.g. MPI_DEBUG and SERIAL_RELEASE) builds.  This is to avoid
problems of side-effects of turning on ST packages that would impact PT
packages (e.g. an ST package getting enabled that enables an ST TPL which
turns on support for that TPL in a PT package producing different code which
might work but the pure PT build without the extra TPL may actually be broken
and not know it).  Therefore, any non-PT packages that are enabled (either
implicitly through changed files or explicitly by listing in --enable-packages)
will be turned off in the --default-builds builds.  If none of the enabled
packages are PT, then they will all be disabled and the --default-builds
builds will be skipped.

In order to better support the development of ST and EX packages, this script
allows you to define some extra builds that will be invoked and used to
determine overall pass/fail before a potential push.  The option
--st-extra-builds is used to specify extra builds that will test ST packages
(and also PT packages if any are enabled).  If only PT packages are enabled
then the builds specified in --st-extra-builds will still be run.  The
reasoning is that PT packages may contain extra ST features and therefore if
the goal is to test these ST builds it is desirable to also run these builds
because they also my impact downstream ST packages.

Finally, the option --extra-builds will test all enabled packages, including
EX packages, regardless of their test group.  Therefore, when using
--extra-builds, be careful that you watch what packages are enabled.  If you
change an EX package, it will be enabled in --extra-builds builds.

A few use cases might help better demonstrate the behavior.  Consider
the following input arguments specifying extra builds

  --st-extra-builds=MPI_DEBUG_ST --extra-builds=INTEL_DEBUG

with the packages Teuchos, Phalanx, and Meros where Teuchos is PT, Phalanx is
ST, and Meros is EX.

Here is what packages would be enabled in each of the builds:

  --default-builds=MPI_DEBUG,SERIAL_RELEASE \
  --st-extra-builds=MPI_DEBUG_ST \
  --extra-builds=INTEL_DEBUG

and which packages would be excluded:

A) --enable-packages=Teuchos:
   MPI_DEBUG:       [Teuchos]
   SERIAL_RELEASE:  [Teuchos]
   MPI_DEBUG_ST:    [Teuchos]
   INTEL_DEBUG:     [Teuchos]     Always enabled!

B) --enable-packages=Phalanx:
   MPI_DEBUG:       []            Skipped, no PT packages!
   SERIAL_RELEASE:  []            Skipped, no PT packages!
   MPI_DEBUG_ST:    [Phalanx]
   INTEL_DEBUG:     [Phalanx]

C) --enable-packages=Meros:
   MPI_DEBUG:       []            Skipped, no PT packages!
   SERIAL_RELEASE:  []            Skipped, no PT packages!
   MPI_DEBUG_ST:    []            Skipped, no PT or ST packages!
   INTEL_DEBUG:     [Meros]

D) --enable-packages=Teuchos,Phalanx:
   MPI_DEBUG:       [Teuchos]
   SERIAL_RELEASE:  [Teuchos]
   MPI_DEBUG_ST:    [Teuchos,Phalanx]
   INTEL_DEBUG:     [Teuchos,Phalanx]

E) --enable-packages=Teuchos,Phalanx,Meros:
   MPI_DEBUG:       [Teuchos]
   SERIAL_RELEASE:  [Teuchos]
   MPI_DEBUG_ST:    [Teuchos,Phalanx]
   INTEL_DEBUG:     [Teuchos,Phalanx,Meros]

The --extra-builds=INTEL_DEBUG build is always performed with all of the
enabled packages.  This logic given above must be understood in order to
understand the output given in the script.


Conventions for Command-Line Arguments:
---------------------------------------

The command-line arguments are segregated into three broad categories: a)
action commands, b) aggregate action commands, and c) others.

a) The action commands are those such as --build, --test, etc. and are shown
with [ACTION] in their documentation.  These action commands have no off
complement.  If the action command appears, then the action will be performed.

b) Aggregate action commands such as --do-all and --local-do-all turn on sets
of other action commands and are shown with [AGGR ACTION] in their
documentation.  The sub-actions that these aggregate action commands turn on
cannot be disabled with other arguments.

c) Other arguments are those that are not marked with [ACTION] or [AGGR
ACTION] tend to either pass in data and turn control flags on or off.


Exit Code:
---------

This script returns 0 if the actions requested are successful.  This does not
necessarily imply that it is okay to do a push.  For example, if only --pull
is passed in and is successful, then 0 will be returned but that does *not*
mean that it is okay to do a push.  A 0 return value is a necessary but not
sufficient condition for readiness to push.



Options:
  -h, --help            show this help message and exit
  --project-configuration=PROJECTCONFIGURATION
                        Custom file to provide configuration defaults for the
                        project.  By default, the file project-checkin-test-
                        config.py is looked for in <checkin-test-path>/../..
                        (assuming default <projectDir>/cmake/tribits/
                        directory structure and second is looked for in
                        <checkin-test-path>/ (which is common practice to
                        symlink the checkin-test.py script into the project's
                        base directory).  If this file is set to a location
                        that is not in the project's base directory, then
                        --src-dir must be set to point to the project's base
                        directory.
  --show-defaults       Show the default option values and do nothing at all.
  --project-name=PROJECTNAME
                        Set the project's name. This is used to locate various
                        files.
  --eg-git-version-check
                        Enable automatic check for the right versions of eg
                        and git. [default]
  --no-eg-git-version-check
                        Do not check the versions of eg and git, just trust
                        they are okay.
  --src-dir=SRCDIR      The source base directory for code to be tested.  The
                        default is determined by the location of the found
                        project-checkin-test-config.py file.
  --default-builds=DEFAULTBUILDS
                        Comma separated list of builds that should always be
                        run by default.
  --extra-repos-file=EXTRAREPOSFILE
                        File path to an extra repositories list file.  If set
                        to 'project', then
                        <project_dir>/cmake/ExtraRepositoriesList.cmake is
                        read.  See the argument --extra-repos for details on
                        how this list is used (default empty '')
  --extra-repos-type=EXTRAREPOSTYPE
                        The test type of repos to read from
                        <extra_repos_file>. Choices = ('', 'Continuous',
                        'Nightly', 'Experimental').  [default = '']
  --extra-repos=EXTRAREPOS
                        List of comma separated extra repositories containing
                        extra  packages that can be enabled.  The order these
                        repos is listed in not important.  This option
                        overrides --extra-repos-file.
  --ignore-missing-extra-repos
                        If set, then extra repos read in from
                        <extra_repos_file> will be ignored and removed from
                        list.  This option is not applicable if
                        <extra_repos_file>=='' or <extra_repos_type>==''.
  --require-extra-repos-exist
                        If set, then all listed extra repos must exist or the
                        script will exit. [default]
  --with-cmake=WITHCMAKE
                        CMake executable to use with cmake -P scripts
                        internally (only set by unit testing code).
  --skip-deps-update    If set, skip the update of the dependency XML file.
                        If the package structure has not changed since the
                        last invocation, then it is safe to use this option.
  --enable-packages=ENABLEPACKAGES
                        List of comma separated packages to test changes for
                        (example, 'Teuchos,Epetra').  If this list of packages
                        is empty, then the list of packages to enable will be
                        determined automatically by examining the set of
                        modified files from the version control update log.
  --disable-packages=DISABLEPACKAGES
                        List of comma separated packages to explicitly disable
                        (example, 'Tpetra,NOX').  This list of disables will
                        be appended after all of the listed enables no mater
                        how they are determined (see --enable-packages
                        option).  NOTE: Only use this option to remove
                        packages that will not build for some reason.  You can
                        disable tests that run by using the CTest option -E
                        passed through the --ctest-options argument in this
                        script.
  --enable-all-packages=ENABLEALLPACKAGES
                        Determine if all packages are enabled 'on', or 'off',
                        or let other logic decide 'auto'.  Setting to 'off' is
                        appropriate when the logic in this script determines
                        that a global build file has changed but you know that
                        you don't need to rebuild every package for a
                        reasonable test.  Setting --enable-packages
                        effectively disables this option.  NOTE: Setting this
                        to 'off' does *not* stop the forward enabling of
                        downstream packages for packages that are modified or
                        set by --enable-packages. Choices = ('auto', 'on',
                        'off').  [default = 'auto']
  --enable-fwd-packages
                        Enable forward packages. [default]
  --no-enable-fwd-packages
                        Do not enable forward packages.
  --continue-if-no-updates
                        If set, then the script will continue if no updates
                        are pulled from any repo. [default]
  --abort-gracefully-if-no-updates
                        If set, then the script will abort gracefully if no
                        updates are pulled from any repo.
  --continue-if-no-changes-to-push
                        If set, then the script will continue if no changes to
                        push from any repo. [default]
  --abort-gracefully-if-no-changes-to-push
                        If set, then the script will abort gracefully if no
                        changes to push from any repo.
  --continue-if-no-enables
                        If set, then the script will continue if no packages
                        are enabled. [default]
  --abort-gracefully-if-no-enables
                        If set, then the script will abort gracefully if no
                        packages are enabled.
  --extra-cmake-options=EXTRACMAKEOPTIONS
                        Extra options to pass to 'cmake' after all other
                        options. This should be used only as a last resort.
                        To disable packages, instead use --disable-packages.
                        To change test categories, use --test-categories.
  --test-categories=TESTCATEGORIES
                        . Change the test categories.  Can be 'BASIC',
                        'CONTINUOUS',  'NIGHTLY', or 'WEEKLY' (default
                        'BASIC').
  -j OVERALLNUMPROCS    The options to pass to make and ctest (e.g. -j4).
  --make-options=MAKEOPTIONS
                        The options to pass to make (e.g. -j4).
  --ctest-options=CTESTOPTIONS
                        Extra options to pass to 'ctest' (e.g. -j2).
  --ctest-timeout=CTESTTIMEOUT
                        timeout (in seconds) for each single 'ctest' test
                        (e.g. 180 for three minutes).
  --show-all-tests      Show all of the tests in the summary email and in the
                        commit message summary (see --append-test-results).
  --no-show-all-tests   Don't show all of the test results in the summary
                        email. [default]
  --without-default-builds
                        Skip the default builds (same as --default-builds='').
                        You would use option along with --extra-
                        builds=BUILD1,BUILD2,... to run your own local custom
                        builds.
  --st-extra-builds=STEXTRABUILDS
                        List of comma-separated ST extra build names.  For
                        each of the build names in --st-extra-
                        builds=<BUILD1>,<BUILD2>,..., there must be a file
                        <BUILDN>.config in the local directory along side the
                        COMMON.config file that defines the special build
                        options for the extra build.
  --ss-extra-builds=SSEXTRABUILDS
                        DEPRECATED!  Use --st-extra-builds instead!.
  --extra-builds=EXTRABUILDS
                        List of comma-separated extra build names.  For each
                        of the build names in --extra-
                        builds=<BUILD1>,<BUILD2>,..., there must be a file
                        <BUILDN>.config in the local directory along side the
                        COMMON.config file that defines the special build
                        options for the extra build.
  --send-email-to=SENDEMAILTO
                        List of comma-separated email addresses to send email
                        notification to after every build/test case finishes
                        and at the end for an overall summary and push status.
                        By default, this is the email address you set for git
                        returned by `git config --get user.email`.  In order
                        to turn off email notification, just set --send-email-
                        to='' and no email will be sent.
  --skip-case-send-email
                        If set then if a build/test case is skipped for some
                        reason (i.e. because no packages are enabled) then an
                        email will go out for that case. [default]
  --skip-case-no-email  If set then if a build/test case is skipped for some
                        reason (i.e. because no packages are enabled) then no
                        email will go out for that case. [default]
  --send-email-for-all  If set, then emails will get sent out for all
                        operations. [default]
  --send-email-only-on-failure
                        If set, then emails will only get sent out for
                        failures.
  --send-email-to-on-push=SENDEMAILTOONPUSH
                        List of comma-separated email addresses to send email
                        notification to on a successful push.  This is used to
                        log pushes to a central list.  In order to turn off
                        this email notification, just set --send-email-to-on-
                        push='' and no email will be sent to these email
                        lists.
  --force-push          Force the local push even if there are build/test
                        errors. WARNING: Only do this when you are 100%
                        certain that the errors are not caused by your code
                        changes.  This only applies when --push is specified
                        and this script.
  --no-force-push       Do not force a push if there are failures. [default]
  --do-push-readiness-check
                        Check the push readiness status at the end and send
                        email if not actually pushing. [default]
  --skip-push-readiness-check
                        Skip push status check.
  --rebase              Rebase the local commits on top of origin/master
                        before amending the last commit and pushing.  Rebasing
                        keeps a nice linear commit history like with CVS or
                        SVN and will work perfectly for the basic workflow of
                        adding commits to the 'master' branch and then syncing
                        up with origin/master before the final push. [default]
  --no-rebase           Do not rebase the local commits on top of
                        origin/master before amending the final commit and
                        pushing.  This allows for some more  complex workflows
                        involving local branches with multiple merges.
                        However, this will result in non-linear history and
                        will allow for trivial merge commits with
                        origin/master to get pushed.  This mode should only be
                        used in cases where the rebase mode will not work or
                        when it is desired to use a merge commit to integrate
                        changes on a branch that you wish be able to easily
                        back out.  For sophisticated users of git, this may in
                        fact be the preferred mode.
  --append-test-results
                        Before the final push, amend the most recent local
                        commit by appending a summary of the test results.
                        This provides a record of what builds and tests were
                        performed in order to test the local changes.  This is
                        only  performed if --push is also set.  NOTE: If the
                        same local commit is amended more than once, the prior
                        test summary sections will be overwritten with the
                        most recent test results from the current run.
                        [default]
  --no-append-test-results
                        Do not amend the last local commit with test results.
                        NOTE: If you have uncommitted local changes that you
                        do not want this script to commit then you must select
                        this option to avoid this last amending commit.  Also,
                        if you are pushing commits from a shared branch and
                        don't want to change any of the SHA1s for the commits,
                        then you must set this option!
  --extra-pull-from=EXTRAPULLFROM
                        Optional extra git pull '<repository>:<branch>' to
                        merge in changes from after pulling in changes from
                        'origin'.  This option uses a colon with no spaces in
                        between <repository>:<branch>' to avoid issues with
                        passing arguments with spaces.  For example --extra-
                        pull-from=machine:/base/dir/repo:master.  This extra
                        pull is only done if --pull is also specified.  NOTE:
                        when using --extra-repo=REPO1,REPO2,... the
                        <repository> must be a named repository that is
                        present in all of the git repos or it will be an
                        error.
  --allow-no-pull       Allowing for there to be no pull performed and still
                        doing the other actions.  This option is useful for
                        testing against local changes without having to get
                        the updates from the global repo.  However, if you
                        don't pull, you can't push your changes to the global
                        repo.  WARNING: This does *not* stop a pull attempt
                        from being performed by --pull or --do-all!
  --wipe-clean          [ACTION] Blow existing build directories and
                        build/test results.  The action can be performed on
                        its own or with other actions in which case the wipe
                        clean will be performed before any other actions.
                        NOTE: This will only wipe clean the builds that are
                        specified and will not touch those being ignored (e.g.
                        SERIAL_RELEASE will not be removed if --default-
                        builds=MPI_DEBUG is specified).
  --pull                [ACTION] Do the pull from the default (origin)
                        repository and optionally also merge in changes from
                        the repo pointed to by --extra-pull-from.
  --configure           [ACTION] Do the configure step.
  --build               [ACTION] Do the build step.
  --test                [ACTION] Do the running of the enabled tests.
  --local-do-all        [AGGR ACTION] Do configure, build, and test with no
                        pull (same as setting --allow-no-pull ---configure
                        --build --test).  This is the same as --do-all except
                        it does not do --pull and also allows for no pull.
  --do-all              [AGGR ACTION] Do update, configure, build, and test
                        (same as --pull --configure --build --test).  NOTE:
                        This will do a --pull regardless if --allow-no-pull is
                        set or not.  To avoid the pull, use --local-do-all.
  --push                [ACTION] Push the committed changes in the local repo
                        into to global repo 'origin' for the current branch.
                        Note: If you have uncommitted changes this command
                        will fail.  Note: You must have SSH public/private
                        keys set up with the origin machine (e.g.
                        software.sandia.gov) for the push to happen without
                        having to type your password.
  --execute-on-ready-to-push=EXECUTEONREADYTOPUSH
                        [ACTION] A command to execute on successful execution
                        and 'READY TO PUSH' status from this script.  This can
                        be used to do a remote SSH invocation to a remote
                        machine to do a remote pull/test/push after this
                        machine finishes.
