.. WARNING: The file UtilsMacroFunctionDoc.rst is autogenerated from
.. the file UtilsMacroFunctionDocTemplate.rst in the script
.. generate-dev-guide.sh.  Only the file UtilsMacroFunctionDoc.rst
.. should be directly modified!

ADD_SUBDIRECTORIES()
++++++++++++++++++++

Macro that adds a list of subdirectories all at once (removes boiler-place
code).

Usage::

  ADD_SUBDIRECTORIES(<dir1> <dir2> ...)

instead of::

  ADD_SUBDIRECTORY(<dir1>)
  ADD_SUBDIRECTORY(<dir2>)
  ...

ADVANCED_OPTION()
+++++++++++++++++

Macro that sets an option and marks it as advanced (removes boiler-plate and
duplication).

Usage::

  ADVANCED_OPTION(<varName> [other arguments])

This just calls the built-in CMake commands::

  OPTION(<varName> [other arguments])
  MARK_AS_ADVANCED(<varName>)

ADVANCED_SET()
++++++++++++++

Macro that sets a variable and marks it as advanced (removes boiler-plate
and duplication).

Usage::

  ADVANCED_SET(<varName> [other arguments])

This just calls the built-in commands::

  SET(<varName> [other arguments])
  MARK_AS_ADVANCED(<varName>)

APPEND_CMNDLINE_ARGS()
++++++++++++++++++++++

Utility function that appends command-line arguments to a variable of
command-line arguments.

Usage::

  APPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

This function just appends the command-line arguments in the string
``"<extraArgs>"`` but does not add an extra space if ``<var>`` is empty on
input.  This just makes the formatting of command-line arguments easier.

APPEND_GLOB()
+++++++++++++

Utility macro that does a ``FILE(GLOB ...)`` and appends to an existing list
(removes boiler-plate code).

Usage::

  APPEND_GLOB(<fileListVar> <glob0> <glob1> ...)

On output, ``<fileListVar>`` will have the list of glob files appended.

APPEND_GLOBAL_SET()
+++++++++++++++++++

Utility macro that appends arguments to a global variable (reduces
boiler-plate code and mistakes).

Usage::

  APPEND_GLOBAL_SET(<varName> <arg0> <arg1> ...)

NOTE: The variable ``<varName>`` must exist before calling this function.
To set it empty initially use `GLOBAL_NULL_SET()`_.

APPEND_SET()
++++++++++++

Utility function to append elements to a variable (reduces boiler-plate
code).

Usage::

  APPEND_SET(<varName> <arg0> <arg1> ...)

This just calls::

  LIST(APPEND <varName> <arg0> <arg1> ...)

There is better error reporting if one misspells ``APPEND_SET`` than if one
misspells ``APPEND``.

APPEND_STRING_VAR()
+++++++++++++++++++

Append strings to an existing string variable (reduces boiler-place code and
reduces mistakes).

Usage::

  APPEND_STRING_VAR(<stringVar> "<string1>" "<string2>" ...)

Note that the usage of the characters ``'['``, ``']'``, ``'{'``, ``'}'`` are
taken by CMake to bypass the meaning of ';' to separate string characters.
If one wants to ignore the meaning of these special characters and are okay
with just adding one string at a time, then use `APPEND_STRING_VAR_EXT()`_.

APPEND_STRING_VAR_EXT()
+++++++++++++++++++++++

Append a single string to an existing string variable, ignoring ';' (reduces
boiler-place code and reduces mistakes).

Usage::

  APPEND_STRING_VAR_EXT(<stringVar> "<string>")

Simply sets ``<stringVar> = "${<stringVar>}<string>"`` and leaves in ``';'``
without creating new array elements.

APPEND_STRING_VAR_WITH_SEP()
++++++++++++++++++++++++++++

Append strings to a given string variable, joining them using a separator
string.

Usage::

  APPEND_STRING_VAR_WITH_SEP(<stringVar> "<sepStr>" "<str0>" "<str1>" ...)

Each of the strings ``<stri>`` are appended to ``<stringVar>`` using the
separation string ``<sepStr>``.

ASSERT_DEFINED()
++++++++++++++++

Assert that a variable is defined and if not call ``MESSAGE(SEND_ERROR
...)``.

Usage::

  ASSERT_DEFINED(<varName>)

This is used to get around the problem of CMake not asserting the
dereferencing of undefined variables.  For example, how does one know if one
did not misspell the name of a variable in an if statement like::

  IF (SOME_VARBLE)
    ...
  ENDIF()

?

 If one misspelled the variable ``SOME_VARBLE`` (which is likely in this
 case), then the if statement will always be false!  To avoid this problem
 when one always expects that a variable is explicitly set, instead do::

  ASSERT_DEFINED(SOME_VARBLE)
  IF (SOME_VARBLE)
    ...
  ENDIF()

Now if one misspells this variable, then CMake will asset and stop
processing.  This is not a perfect solution since one can misspell the
variable name in the following if statement but typically one would always
just copy and paste between the two statements so these names are always the
same.  This is the best that can be done in CMake unfortunately to catch
usage of misspelled undefined variables.

COMBINED_OPTION()
+++++++++++++++++

Set up a ``BOOL`` cache variable (i.e. an option) based on a set of
dependent options.

Usage::

  COMBINED_OPTION( <combinedOptionName>
    DEP_OPTIONS_NAMES <depOpName0> <depOptName1> ...
    DOCSTR "<docstr0>" "<docstr1" ...
    )

This sets up a ``BOOL`` cache variable ``<combinedOptionName>`` which is
defaulted to ``ON`` if all of the listed dependent option variables
``<depOpName0>``, ``<depOptName1>``, ... are all ``ON``.  However, if
``<combinedOptionName>`` is set to ``ON`` by the user and not all of the
dependent option variables are also ``ON``, then this results in a fatal
error and all processing stops.

This is used by a CMake project to automatically turn on a feature that
requires a set of other features (when they are all enabled) but allows a
user to disable the feature if desired.

CONCAT_STRINGS()
++++++++++++++++

Concatenate a set of string arguments.

Usage::

  CONCAT_STRINGS(<outputVar> "<str0>" "<str1>" ...)

On output, ``<outputVar>`` is set to ``"<str0><str1>..."``.  This makes it
easier to format a long string over multiple CMake source code lines.

DUAL_SCOPE_APPEND_CMNDLINE_ARGS()
+++++++++++++++++++++++++++++++++

Utility function that appends command-line arguments to a variable of
command-line options and sets the result in current scope and parent scope.

Usage::

  DUAL_SCOPE_APPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

Just calls `APPEND_CMNDLINE_ARGS()`_ and then ``SET(<var> ${<var>} PARENT_SCOPE)``.

DUAL_SCOPE_PREPEND_CMNDLINE_ARGS()
++++++++++++++++++++++++++++++++++

Utility function that prepends command-line arguments to a variable of
command-line arguments and sets the result in current scope and parent
scope.

Usage::

  DUAL_SCOPE_PREPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

Just calls `PREPEND_CMNDLINE_ARGS()`_ and then ``SET(<var> ${<var>} PARENT_SCOPE)``.

DUAL_SCOPE_SET()
++++++++++++++++

Macro that sets a variable name both in the current scope and the
parent scope.

Usage::

   DUAL_SCOPE_SET(<varName> [other args])

It turns out that when one calls ``ADD_SUBDIRECTORY(<someDir>)`` or enters a
``FUNCTION`` that CMake actually creates a copy of all of the regular
non-cache variables in the current scope in order to create a new set of
variables for the ``CMakeLists.txt`` file in ``<someDir>``.  This means that
if you call ``SET(SOMEVAR Blah PARENT_SCOPE)`` that it will not affect the
value of ``SOMEVAR`` in the current scope!  This macro therefore is designed
to set the value of the variable in the current scope and the parent scope
in one shot to avoid confusion.

Global variables are different.  When one moves to a subordinate
``CMakeLists.txt`` file or enters a ``FUNCTION``, then a local copy of the
variable is *not* created.  If one sets the variable locally, it will shadow
the global variable.  However, if one sets the global cache value with
``SET(SOMEVAR someValue CACHE INTERNAL "")``, then the value will get
changed in the current subordinate scope and in all parent scopes all in one
shot!

GLOBAL_NULL_SET()
+++++++++++++++++

Set a variable as a null internal global (cache) variable (removes
boiler-plate code).

Usage::

  GLOBAL_NULL_SET(<varName>)

This just calls::

  SET(<varName> "" CACHE INTERNAL "")

This avoid problems with misspelling ``CACHE``.

GLOBAL_SET()
++++++++++++

Set a variable as an internal global (cache) variable (removes boiler-plate
code).

Usage::

  GLOBAL_SET(<varName> [other args])

This just calls::

  SET(<varName> [other args] CACHE INTERNAL "")

This avoid misspelling ``CACHE``.

JOIN()
++++++

Join a set of strings into a single string using a join string.

Usage::

  JOIN(<outputStrVar> "<sepStr>" <quoteElements>
    "<string0>" "<string1>" ...)

Arguments:

  ``<outputStrVar>``

    The name of a variable that will hold the output string.

  ``"<sepStr>"``

    A string to use to join the list of strings.

  ``<quoteElements>``

    If ``TRUE``, then each ``<stringi>`` is quoted using an escaped quote
     char ``\"``.  If ``FALSE`` then no escaped quote is used.

  ``"<string0>" "<string1>" ...``

    Zero or more string arguments to be joined.

On output, the variable ``<outputStrVar>`` is set to::

  "<string0><sepStr><string1><sepStr>..."

If ``<quoteElements>=TRUE``, then ``<outputStrVar>`` is set to::

  "\"<string0>\"<sepStr>\"<string1>\"<sepStr>..."

For example, the latter can be used to set up a set of command-line
arguments given a CMake array like::

  JOIN(CMND_LINE_ARGS " " TRUE ${CMND_LINE_ARRAY})

WARNING: Be careful to quote string arguments that have spaces because CMake
interprets those as array boundaries.

MESSAGE_WRAPPER()
+++++++++++++++++

Function that wraps the standard CMake/CTest ``MESSAGE()`` function call in
order to allow unit testing to intercept the output.

Usage::

  MESSAGE_WRAPPER(...)

This function takes exactly the same arguments as built-in ``MESSAGE()``
function.  However, when the variable ``MESSAGE_WRAPPER_UNIT_TEST_MODE`` is
set to ``TRUE``, then this function will not call ``MESSAGE(...)`` but
instead will prepend set to the global variable ``MESSAGE_WRAPPER_INPUT``
the input argument that would have gon to ``MESSAGE()``.  To capture just
this call's input, first call::

  GLOBAL_NULL_SET(MESSAGE_WRAPPER_INPUT)

before calling this function (or the functions/macros that call this
function).

This function allows one to unit test other user-defined CMake macros and
functions that call this function to catch error conditions without stopping
the CMake program.  Otherwise, this is used to capture print messages to
verify that they say the right thing.

MULTILINE_SET()
+++++++++++++++

Function to set a single string by concatenating a list of separate strings

Usage::

  MULTILINE_SET(<outputStrVar>
    "<string0>"
    "<string1>"
    ...
    )

On output, the local variables ``<outputStrVar>`` is set to::

  "<string0><string1>..."

The purpose of this is function to make it easier to set longer strings over
multiple lines.

This function is exactly the same as `CONCAT_STRINGS()`_ and should not even
exist :-(

PARSE_ARGUMENTS()
+++++++++++++++++

Parse a set of macro/function input arguments into different lists.  This
allows the easy implementation of keyword-based user-defined macros and
functions.

Usage::

  PARSE_ARGUMENTS(
    <prefix>  <argNamesList>  <optionNamesList>
    <inputArgsList>
    )

Arguments to this macro are:

  ``<prefix>``

    Prefix ``<prefix>_`` added the list and option variables created listed
    in ``<argNamesList>`` and ``<optionNamesList>``.

  ``<argNamesList>``

    Quoted array of list arguments (e.g. ``"<argName0>;<argName1>;..."``).
    For each variable name ``<argNamei>``, a local variable will be created
    in the current scope with the name ``<prefix>_<argNamei>`` which gives
    the list of variables parsed out of ``<inputArgsList>``.

  ``<optionNamesList>``

    Quoted array of list options (e.g. ``"<optName0>;<optName1>;..."``)
    typically pass in as ``${ARGN}`` in the outer function/macro.  For each
    variable name ``<optNamei>``, a local variable will be created in the
    current scope with the name ``<prefix>_<optNamei>`` that is either set
    to ``TRUE`` or ``FALSE`` depending if ``<optNamei>`` appears in
    ``<inputArgsList>`` or not.

  ``<inputArgsList>``

    List of arguments keyword-based arguments passed in through the outer
    macro or function to be parsed out into the different argument and
    option lists.

What this macro does is very simple yet very useful.  What it does is to
allow one to create one's own user-defined keyword-based macros and
functions like is used by some built-in CMake commands.

For example, consider the following user-defined macro that uses both
positional and keyword-based arguments using ``PARSE_ARGUMENTS()``::

  MACRO(PARSE_SPECIAL_VARS  BASE_NAME)

    PARSE_ARGUMENTS(
      #prefix
      ${BASE_NAME}
      #lists
      "ARG0;ARG1;ARG2"
      #options
      "OPT0;OPT1"
      ${ARGN}
      )

  ENDMACRO()

Calling this macro as::

  PARSE_SPECIAL_VARS(MyVar ARG0 a b ARG2 c OPT1)

sets the following variables in the current scope::

  MyVar_ARG0="a;b"
  MyVar_ARG1=""
  MyVar_ARG2="c"
  MyVar_OPT0="FALSE"
  MyVar_OPT1="TRUE"

This allows one to define user-defined macros and functions that have a
mixture of positional arguments and keyword-based arguments like one can do
in other languages.  The keyword-based arguments can be passed in any order
and those that are missing are empty (or false for options) by default.

Any initial arguments that are not recognized as ``<argNamesList>`` or
``<optionNamesList>`` keyword arguments will be put into the local variable
``<prefix>_DEFAULT_ARGS``.  If no arguments in ``<inputArgsList>``
(typically ``${ARGN}``) match any in ``<argNamesList>``, then all non-option
arguments are put into ``<prefix>_DEFAULT_ARGS``.  For example, if one
passes in::

  PARSE_SPECIAL_VARS(MyVar ARG5 a b c)

you will get::

  MyVar_DEFAULT_ARGS="ARG5;a;b;c"
  MyVar_ARG0=""
  MyVar_ARG1=""
  MyVar_ARG2=""
  MyVar_OPT0="FALSE"
  MyVar_OPT1="FALSE"

Multiple occurrences of keyword arguments in ``<inputArgsList>`` is allowed
but only the last one listed will be recorded.  For example, if one calls::

  PARSE_SPECIAL_VARS(MyVar ARG1 a b ARG1 c)

then this will set::

  MyVar_ARG0=""
  MyVar_ARG1="c"
  MyVar_ARG2=""
  MyVar_OPT0="FALSE"
  MyVar_OPT1="FALSE"

This is actually consistent with the way that most argument list parsers
behave with respect to multiple instances of the same argument so hopefully
this will not be a surprise to anyone.

If one puts an option keyword in the middle of a keyword argument list, the
option keyword will get pulled out of the list.  For example, if one calls::

  PARSE_SPECIAL_VARS(MyVar ARG0 a OPT0 c)

then this will set::

  MyVar_ARG0="a;c"
  MyVar_ARG1=""
  MyVar_ARG2=""
  MyVar_OPT0="TRUE"
  MyVar_OPT1="FALSE"

This is confusing behavior so users would be smart not to mix option
arguments inside of list arguments.

If ``PARSE_ARGUMENTS_DUMP_OUTPUT_ENABLED`` is set to ``TRUE``, then a bunch
of detailed debug info will be printed.  This should only be used in the
most desperate of debug situations because it will print a *lot* of output!

**PERFORMANCE:** This function will scale as::

  O( (len(<argNamesList>) * len(<optionNamesList>)) * len(<inputArgsList>) )

Therefore, this could scale very badly for large sets of argument and option
names and input argument list names.

PREPEND_CMNDLINE_ARGS()
+++++++++++++++++++++++

Utility function that prepends command-line arguments to a variable of
command-line arguments.

Usage::

  PREPEND_CMNDLINE_ARGS(<var> "<extraArgs>")

This function just prepends the command-line arguments in the string
``"<extraArgs>"`` but does not add an extra space if ``<var>`` is empty on
input.

PREPEND_GLOBAL_SET()
++++++++++++++++++++

Utility macro that prepends arguments to a global variable (reduces
boiler-plate code and mistakes).

Usage::

  PREPEND_GLOBAL_SET(<varName> <arg0> <arg1> ...)

The variable ``<varName>`` must exist before calling this function.  To set
it empty initially use `GLOBAL_NULL_SET()`_.

PRINT_NONEMPTY_VAR()
++++++++++++++++++++

Print a defined variable giving its name then value only if it is not empty.

Usage::

   PRINT_NONEMPTY_VAR(<varName>)

Calls ``PRINT_VAR(<varName>)`` if ``${<varName>}`` is not empty.

PRINT_NONEMPTY_VAR_WITH_SPACES()
++++++++++++++++++++++++++++++++

Print a defined variable giving its name then value printed with spaces
instead of ``';'`` but only if it is not empty.

Usage::

   PRINT_NONEMPTY_VAR_WITH_SPACES(<varName>  <printedVarInOut>)

Prints the variable as::

   <varName>: <ele0> <ele1> ...

If ``$<printedVarInOut>`` is ``TRUE`` on input, then the varible is not
touched. If however, the varible ``$<printedVarInOut>`` is not ``TRUE`` on
input, then it is set to ``TRUE`` on output.

PRINT_VAR()
+++++++++++

Unconditionally print a variable giving its name then value.

Usage::

  PRINT_VAR(<varName>)

This prints::

  MESSAGE("-- " "${VARIBLE_NAME}='${${VARIBLE_NAME}}'")

The variable ``<varName>`` can be defined or undefined or empty.  This uses
an explicit "-- " line prefix so that it prints nice even on Windows CMake.

REMOVE_GLOBAL_DUPLICATES()
++++++++++++++++++++++++++

Remove duplicate elements from a global list variable (removes boiler-plate
code and errors).

Usage::

  REMOVE_GLOBAL_DUPLICATES(<globalVarName>)

This function is necessary in order to preserve the "global" nature of the
variable.  If one just calls ``LIST(REMOVE_DUPLICATES ...)`` it will
actually create a local variable of the same name and shadow the global
variable!  That is a fun bug to track down!  The variable
``<globalVarName>`` must be defined before this function is called.  If
``<globalVarName>`` is actually not a global cache variable before this
function is called it will be after it completes.

SET_AND_INC_DIRS()
++++++++++++++++++

Set a variable to an include directory and call ``INCLUDE_DIRECTORIES()``
(removes boiler-plate code).

Usage:

  SET_AND_INC_DIRS(<dirVarName> <includeDir>)

On output, this sets ``<dirVarName>`` to ``<includeDir>`` in the local scope
and calls ``INCLUDE_DIRECTORIES(<includeDir>)``.

SET_CACHE_ON_OFF_EMPTY()
++++++++++++++++++++++++

Usage::

  SET_CACHE_ON_OFF_EMPTY(<varName> <initialVal> "<docString>" [FORCE])

Sets a special string cache variable with possible values "", "ON", or
"OFF".  This results in a nice drop-down box in the CMake cache manipulation
GUIs.

SET_DEFAULT()
+++++++++++++

Give a local variable a default value if a non-empty value is not already
set.

Usage::

  SET_DEFAULT(<varName> <arg0> <arg1> ...)

If on input ``"${<varName>}"==""``, then ``<varName>`` is set to the given
default ``<arg0> <arg1> ...``.  Otherwise, the existing non-empty value is
preserved.

SET_DEFAULT_AND_FROM_ENV()
++++++++++++++++++++++++++

Set a default value for a local variable and override from an environment
variable of the same name if it is set.

Usage::

  SET_DEFAULT_AND_FROM_ENV(<varName> <defaultVal>)

First calls ``SET_DEFAULT(<varName> <defaultVal>)`` and then looks for an
environment variable named ``<varName>``, and if non-empty then overrides
the value of the local variable ``<varName>``.

This macro is primarily used in CTest code to provide a way to pass in the
value of CMake variables.  Older versions of ``ctest`` did not support the
option ``-D <var>:<type>=<value>`` to allow variables to be set through the
command-line like ``cmake`` always allowed.

SPLIT()
+++++++

Split a string variable into a string array/list variable.

Usage::

  SPLIT("<inputStr>" "<sepStr>" <outputStrListVar>)

The ``<sepStr>`` string is used with ``STRING(REGEX ...)`` to replace all
occurrences of ``<sepStr>`` in ``<inputStr>`` with ``";"`` and writing into
``<outputStrListVar>``.

WARNING: ``<sepStr>`` is interpreted as a regular expression (regex) so keep
that in mind when considering special regex chars like ``'*'``, ``'.'``,
etc!

TIMER_GET_RAW_SECONDS()
+++++++++++++++++++++++

Return the raw time in seconds (nano-second accuracy) since epoch, i.e.,
since 1970-01-01 00:00:00 UTC.

Usage::

  TIMER_GET_RAW_SECONDS(<rawSecondsVar>)

This function is used along with `TIMER_GET_REL_SECONDS()`_, and
`TIMER_PRINT_REL_TIME()`_ to time big chunks of CMake code for timing and
profiling purposes.  See `TIMER_PRINT_REL_TIME()`_ for more details and an
example.

NOTE: This function runs an external process with ``EXECUTE_PROCESS()`` to
run the ``date`` command.  Therefore, it only works on Unix/Linux and other
systems that have a standard ``date`` command.  Since this uses
``EXECUTE_PROCESS()``, this function should only be used to time very
course-grained operations (i.e. that take longer than a second).

TIMER_GET_REL_SECONDS()
+++++++++++++++++++++++

Return the relative time between start and stop seconds.

Usage::

  TIMER_GET_REL_SECONDS(<startSeconds> <endSeconds> <relSecondsOutVar>)

This simple function computes the relative number of seconds between
``<startSeconds>`` and ``<endSeconds>`` (returned from
`TIMER_GET_RAW_SECONDS()`_) and sets the result in the local variable
``<relSecondsOutVar>``.

TIMER_PRINT_REL_TIME()
++++++++++++++++++++++

Print the relative time between start and stop timers in ``<min>m<sec>s``
format.

Usage::

  TIMER_PRINT_REL_TIME(<startSeconds> <endSeconds> "<messageStr>")

Differences the raw times ``<startSeconds>`` and ``<endSeconds>``
(i.e. gotten from `TIMER_GET_RAW_SECONDS()`_) and prints the time in
``<min>m<sec>s`` format.

This is meant to be used with `TIMER_GET_RAW_SECONDS()`_ to time expensive
blocks of CMake code like::

  TIMER_GET_RAW_SECONDS(REAL_EXPENSIVE_START)

  REAL_EXPENSIVE(...)

  TIMER_GET_RAW_SECONDS(REAL_EXPENSIVE_END)

  TIMER_PRINT_REL_TIME(${REAL_EXPENSIVE_START} ${REAL_EXPENSIVE_END}
     "REAL_EXPENSIVE() time")

This will print something like::

  REAL_EXPENSIVE() time: 0m5.235s

UNITTEST_COMPARE_CONST()
++++++++++++++++++++++++

Perform a single unit test equality check and update overall test statistics

Usage::

  UNITTEST_COMPARE_CONST(<varName> <expectedValue>)

If ``${<varName>} == <expectedValue>``, then the check passes, otherwise it
fails.  This prints the variable name and values and shows the test result.

This updates the global variables ``UNITTEST_OVERALL_NUMRUN``,
``UNITTEST_OVERALL_NUMPASSED``, and ``UNITTEST_OVERALL_PASS`` which are used
by the unit test harness system to assess overall pass/fail.

UNITTEST_HAS_SUBSTR_CONST()
+++++++++++++++++++++++++++

Check that a given string var contains the given substring and update
overall test statistics

Usage::

  UNITTEST_HAS_SUBSTR_CONST(<varName> <substr>)

If ``${<varName>}`` contains the substring ``<substr>``, then the check
passes, otherwise it fails.  This prints the variable name and values and
shows the test result.

This updates the global variables ``UNITTEST_OVERALL_NUMRUN``,
``UNITTEST_OVERALL_NUMPASSED``, and ``UNITTEST_OVERALL_PASS`` which are used
by the unit test harness system to assess overall pass/fail.

UNITTEST_STRING_REGEX()
+++++++++++++++++++++++

Perform a series regexes of given strings and update overall test statistics.

Usage::

  UNITTEST_STRING_REGEX(
    <inputString>
    REGEX_STRINGS "<str0>" "<str1>" ...
    )

If the ``<inputString>`` matches all of the of the regexs ``"<str0>"``,
``"<str1>"``, ..., then the test passes.  Otherwise it fails.

This updates the global variables ``UNITTEST_OVERALL_NUMRUN``,
``UNITTEST_OVERALL_NUMPASSED``, and ``UNITTEST_OVERALL_PASS`` which are used
by the unit test harness system to assess overall pass/fail.

UNITTEST_FILE_REGEX()
+++++++++++++++++++++

Perform a series regexes of given strings and update overall test statistics.

Usage::

  UNITTEST_FILE_REGEX(
    <inputFileName>
    REGEX_STRINGS "<str1>" "<str2>" ...
    )

The contents of ``<inputFileName>`` are read into a string and then passed
to `UNITTEST_STRING_REGEX()`_ to assess pass/fail.

UNITTEST_FINAL_RESULT()
+++++++++++++++++++++++

Print final statistics from all tests and assert final pass/fail

Usage::

  UNITTEST_FINAL_RESULT(<expectedNumPassed>)

If ``${UNITTEST_OVERALL_PASS}==TRUE`` and ``${UNITTEST_OVERALL_NUMPASSED} ==
<expectedNumPassed>``, then the overall test program is determined to have
passed and string::

 "Final UnitTests Result: PASSED"

is printed.  Otherwise, the overall test program is determined to have
failed, the string::

 "Final UnitTests Result: FAILED"

is printed, and ``MESSAGE(SEND_ERROR "FAIL")`` is called.

The reason that we require passing in the expected number of passed tests is
as an extra precaution to make sure that important unit tests are not left
out.  CMake is a very loosely typed language and it pays to be a little
paranoid.

