% @HEADER
% ***********************************************************************
% 
%            Trilinos: An Object-Oriented Solver Framework
%                 Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This library is free software; you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License as
% published by the Free Software Foundation; either version 2.1 of the
% License, or (at your option) any later version.
%  
% This library is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% Lesser General Public License for more details.
%  
% You should have received a copy of the GNU Lesser General Public
% License along with this library; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
% USA
% Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
% 
% ***********************************************************************
% @HEADER

\section{Incomplete Factorizations with IFPACK}
\label{chap:ifpack}

IFPACK provides a suite of object-oriented algebraic preconditioners for
the solution of preconditioned iterative solvers. IFPACK offers a
variety of overlapping (one-level) Schwarz preconditioners, The packages
uses Epetra for basic matrix-vector calculations, and accepts user
matrices via abstract matrix interface. A concrete implementation for
Epetra matrices is provided. The package separates graph construction
for factorization, improving performances in a substantial manner with
respect to other factorization packages.

In this Chapter we present how to use IFPACK objects as a preconditioner
for an AztecOO solver. 

In this Chapter, we will
\begin{itemize}
\item Present few notes on incomplete factorizations and set the
  notation (in Section~\ref{sec:ifpack_theoretical});
\item Show how to compute incomplete Cholesky factorizations (in
  Section~\ref{sec:ifpack_chol});
\item Present IFPACK's RILU-type factorizations (in
  Section~\ref{sec:ifpack_rilu}).
\end{itemize}

%%%
%%%
%%%

\subsection{Theoretical Background}
\label{sec:ifpack_theoretical}

Aim of this Section is to briefly present some aspects on incomplete
factorization methods, to establish a notation. The Section is not
supposed to be exhaustive, nor complete on this subject. The reader is
referred to the existing literature for a rigorous presentation.

\medskip

A broad class of effective preconditioners is based on incomplete
factorization of the linear system matrix, and it is usually indicated
as ILU.  The ILU-type preconditioning techniques lie between direct and
iterative methods and provide a balance between reliability and
numerical efficiency.

The preconditioner is given in the factored form
$P=\tilde{L} \tilde{U}$, with $\tilde{L}$ and $\tilde{U}$ being lower
and upper triangular matrices. Solving with $P$ involves two triangular
solutions.

The incomplete LU factorization of a matrix $A$ can be described as
follows. Let $A_0=A$. Then, for $k=2,\ldots,n$, we have
\[
A_{k-1} = 
\left(
\begin{array}{c c}
B_k & F_k \\
E_k & C_k \\
\end{array}
\right) .
\]
Thus, we can write the $k-$step of the Gaussian elimination in a block
form as
\[
A_{k-1} = 
\left(
\begin{array}{c c}
I & 0 \\
E_k B_k^{-1} & I \\
\end{array}
\right)
\;
\left(
\begin{array}{c c}
B_k & F_k \\
0 & A_k \\
\end{array}
\right) ,
\]
where $A_k = C_k - E_k B_k^{-1} F_k$. If $B_k$ is a scalar, then we have
the typical point-wise factorization, otherwise we have a block
factorization. Pivoting, if it is necessary, can be accomplished by
reordering $A_k$ at every step.

To make the factorization incomplete, entries as dropped in $A_k$, i.e.
the factorization proceeds with
\[
\tilde{A}_k = A_k - R_k
\]
where $R_k$ is the matrix of dropped entries. 

Dropping can be performed
by position, for example, dropping those entries in the update matrix
$E_k B_k^{-1} F_k$ that are not in the pattern of $C_k$. 
This simple ILU factorization is known as ILU(0). Although effective, in
some cases the accuracy of the ILU(0) may be insufficient to yield an
adequate rate of convergence. More accurate factorizations will differ
from ILU(0) by allowing some {\em fill-in}. The resulting class of
methods is called ILU($f$), where $f$ is the level-of-fill. A
level-of-fill is attributed to each element that is processed by
Gaussian elimination, and dropping will be based on the level-of-fill.
The level-of-fill should be indicative of the size of the element: the
higher the level-of-fill, the smaller the elements.  

Other strategies consider dropping by value -- for example, dropping
entries smaller than a prescribed threshold. Alternative dropping
techniques can be based on the numerical size of the element to be
discarded. Numerical dropping strategies generally yield more accurate
factorizations with the same amount of fill-in than level-of-fill
methods. The general strategy is to compute an entire row of the
$\tilde{L}$ and $\tilde{U}$ matrices, and then keep only the biggest
entries in a certain number. In this way, the amount of fill-in is
controlled; however, the structure of the resulting matrices is
undefined. These factorizations are usually referred to as ILUT, and a
variant which performs pivoting is called ILUTP.

%%%
%%%
%%%

\subsection{Incomplete Cholesky Factorizations}
\label{sec:ifpack_chol}

Ifpack\_CrsIct is a class for constructing and using incomplete Cholecky
factorizations of an Epetra\_CrsMatrix. The factorization is produced
based on several parameters:
\begin{itemize}
\item Maximum number of entries per row/column. The factorization
  will contain at most this number of nonzero elements in each
  row/column;
\item Diagonal perturbation.  By default, the factorization will be
  computed on the input matrix. However, it is possible to modify the
  diagonal entries of the matrix to be factorized, via functions
  \verb!SetAbsoluteThreshold()! and \verb!SetRelativeThreshold()!. Refer
  to the IFPACK's documentation for more details.
\end{itemize}

It is very easy to compute the incomplete factorization. First, define
an Ifpack\_CrsIct object,
\begin{verbatim}
Ifpack_CrsIct * ICT = NULL;
ICT = Ifpack_CrsIct(A,DropTol,LevelFill);
\end{verbatim}
where \verb!A! is an Epetra\_CrsMatrix (already FillComplete'd), and
\verb!DropTop! and \verb!LevelFill! are the drop tolerance and the
level-of-fill, respectively. Then, we can set the values and compute the
factors,
\begin{verbatim}
ICT->InitValues(A);
ICT->Factor();
\end{verbatim}

IFPACK can compute the estimation of the condition number
\[
cond(L_i U_i) \approx \|(LU)^{-1} e \|_\infty ,
\]
where $e = (1,1,\dots,1)^T$. (More details can be found in the IFPACK's
documentation.) This estimation can be computed as follows:
\begin{verbatim}
double Condest;
ICT->Condest(false,Condest);
\end{verbatim}
Please refer to file \TriExe{ifpack/ex1.cpp} for a complete example of
incomplete Cholesky factorization.

%%%
%%%
%%%

\subsection{RILU  Factorizations}
\label{sec:ifpack_rilu}

IFPACK implements various incomplete factorization for non-symmetric
matrices. In this Section, we will consider the Epetra\_CrsRiluk class,
that can be used to produce RILU factorization of a Epetra\_CrsMatrix.
The class required an Ifpack\_OverlapGraph in the construction phase.
This means that the factorization is split into two parts:
\begin{enumerate}
\item Definition of the level filled graph;
\item Computation of the factors.
\end{enumerate}
This approach can significantly improve the performances of code, when
an ILU preconditioner has to be computed for several matrices, with
different entries but with the same sparsity pattern. An
Ifpack\_IlukGraph object of an Epetra matrix \verb!A! can be constructed
as
\begin{verbatim}
Ifpack_IlukGraph Graph = 
  Ifpack_IlukGraph(A.Graph(),LevelFill,LevelOverlap);
\end{verbatim}
Here, \verb!LevelOverlap! is the required overlap among the subdomains.

A call to \verb!ConstructFilledGraph()! completes the process.

\begin{remark}
  An Ifpack\_IlukGraph object has two Epetra\_CrsGraph objects,
  containing the $L_i$ and $U_i$ graphs. Thus, it is possible to
  manually insert and delete graph entries in $L_i$ and $U_i$ via the
  Epetra\_CrsGraphInsertIndices and RemoveIndices functions. However, in
  this cas FillComplete must be called before the graph is used for
  subsequent operations.
\end{remark}

At this point, we can create an Ifpack\_CrsRiluk object,
\begin{verbatim}
ILUT = Ifpack_CrsRiluk(Graph);
\end{verbatim}
This phase defined the graph for the incomplete factorization, without
computing the actual values of the $L_i$ and $U_i$ factors. Instead,
this operation is accomplished with
\begin{verbatim}
int initerr = ILUT->InitValues(A);
\end{verbatim}
The ILUT object can be used with AztecOO simply setting
\begin{verbatim}
solver.SetPrecOperator(ILUK);
\end{verbatim}
where \verb!solver! is an AztecOO pbject.
\smallskip
Example \TriExe{ifpack/ex2.cpp} shows the use of Ifpack\_CrsRiluk class.

\medskip

The application of the incomplete factors to a global vector, $z =
(L_iU_i^{-1}) r$, results in redundant approximation for any element of
$z$ that correspond to rows that are part of more than one local ILU
factor. The OverlapMode defines how those redundant values are managed.
OverlapMode is an Epetra\_CombinedMode enum, that can assume the
following values: {\tt Add, Zero, Insert, Average, AbxMax}. The default
is to zero out all the values of $z$ for rows that were not part of the
original matrix row distribution.

%A technique, sometimes called relaxation, can be used to obtain RILU
%factorization. If RelaxValue (set by \verb!SetRelaxValue()!) is
%different from zero, the extra-term, dropped during the factorization,
%are not dropped. This can be of help for operators that should have zero
%row-sum. 

%%%
%%%
%%%


\subsection{Concluding Remarks on IFPACK}
\label{sec:ifpack_concluding}

More documentation on the IFPACK package can be found in
\cite{Ifpack-Ref-Guide,Ifpack-User-Guide}.

